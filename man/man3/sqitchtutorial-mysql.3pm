.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sqitchtutorial-mysql 3"
.TH sqitchtutorial-mysql 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
sqitchtutorial-mysql \- A tutorial introduction to Sqitch change management on MySQL
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  sqitch *
.Ve
.SH "Description"
.IX Header "Description"
This tutorial explains how to create a sqitch-enabled MySQL project, use a \s-1VCS\s0
for deployment planning, and work with other developers to make sure changes
remain in sync and in the proper order.
.PP
We'll start by creating new project from scratch, a fictional antisocial
networking site called Flipr. All examples use Git <https://git-scm.com/> as
the \s-1VCS\s0 and MySQL <https://dev.mysql.com/> as the storage engine.
.PP
If you'd like to manage a PostgreSQL database, see sqitchtutorial.
.PP
If you'd like to manage an SQLite database, see sqitchtutorial-sqlite.
.PP
If you'd like to manage an Oracle database, see sqitchtutorial-oracle.
.PP
If you'd like to manage a Firebird database, see sqitchtutorial-firebird.
.PP
If you'd like to manage a Vertica database, see sqitchtutorial-vertica.
.PP
If you'd like to manage an Exasol database, see sqitchtutorial-exasol.
.PP
If you'd like to manage a Snowflake database, see sqitchtutorial-snowflake.
.SH "Starting a New Project"
.IX Header "Starting a New Project"
Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:
.PP
.Vb 10
\&  > mkdir flipr
\&  > cd flipr
\&  > git init .
\&  Initialized empty Git repository in /flipr/.git/
\&  > touch README.md
\&  > git add .
\&  > git commit \-am \*(AqInitialize project, add README.\*(Aq
\&  [master (root\-commit) fdf2a40] Initialize project, add README.
\&   1 file changed, 38 insertions(+)
\&   create mode 100644 README.md
.Ve
.PP
If you're a Git user and want to follow along the history, the repository used
in these examples is on GitHub <https://github.com/sqitchers/sqitch-mysql-intro>.
.PP
Now that we have a repository, let's get started with Sqitch. Every Sqitch
project must have a name associated with it, and, optionally, a unique \s-1URI.\s0 We
recommend including the \s-1URI,\s0 as it increases the uniqueness of object
identifiers internally, and will prevent the deployment of a different project
with the same name. So let's specify one when we initialize Sqitch:
.PP
.Vb 6
\&  > sqitch init flipr \-\-uri https://github.com/sqitchers/sqitch\-mysql\-intro/ \-\-engine mysql
\&  Created sqitch.conf
\&  Created sqitch.plan
\&  Created deploy/
\&  Created revert/
\&  Created verify/
.Ve
.PP
Let's have a look at \fIsqitch.conf\fR:
.PP
.Vb 9
\&  > cat sqitch.conf
\&  [core]
\&        engine = mysql
\&        # plan_file = sqitch.plan
\&        # top_dir = .
\&  # [engine "mysql"]
\&        # target = db:mysql:
\&        # registry = sqitch
\&        # client = mysql
.Ve
.PP
Good, it picked up on the fact that we're creating changes for the MySQL
engine, thanks to the \f(CW\*(C`\-\-engine mysql\*(C'\fR option, and saved it to the file.
Furthermore, it wrote a commented-out \f(CW\*(C`[engine "mysql"]\*(C'\fR section with all the
available MySQL engine-specific settings commented out and ready to be edited
as appropriate.
.PP
By default, Sqitch will read \fIsqitch.conf\fR in the current directory for
settings. But it will also read \fI~/.sqitch/sqitch.conf\fR for user-specific
settings. Since MySQL's
\&\f(CW\*(C`mysql\*(C'\fR client <https://dev.mysql.com/doc/refman/5.6/en/mysql.html> is not
in the path on my system, let's go ahead an tell it where to find the client
on our computer (don't bother if you're using the
Docker image <https://hub.docker.com/r/sqitch/sqitch/> because it uses the
client inside the container, not on your host machine):
.PP
.Vb 1
\&  > sqitch config \-\-user engine.mysql.client /usr/local/mysql/bin/mysql
.Ve
.PP
And let's also tell it who we are, since this data will be used in all
of our projects:
.PP
.Vb 2
\&  > sqitch config \-\-user user.name \*(AqMarge N. OXVera\*(Aq
\&  > sqitch config \-\-user user.email \*(Aqmarge@example.com\*(Aq
.Ve
.PP
Have a look at \fI~/.sqitch/sqitch.conf\fR and you'll see this:
.PP
.Vb 6
\&  > cat ~/.sqitch/sqitch.conf
\&  [engine "mysql"]
\&        client = /usr/local/mysql/bin/mysql
\&  [user]
\&        name = Marge N. OXVera
\&        email = marge@example.com
.Ve
.PP
Which means that Sqitch should be able to find \f(CW\*(C`mysql\*(C'\fR for any project, and
that it will always properly identify us when planning and committing changes.
.PP
Back to the repository. Have a look at the plan file, \fIsqitch.plan\fR:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-mysql\-intro/
.Ve
.PP
Note that it has picked up on the name and \s-1URI\s0 of the app we're building.
Sqitch uses this data to manage cross-project dependencies. The
\&\f(CW\*(C`%syntax\-version\*(C'\fR pragma is always set by Sqitch, so that it always knows how
to parse the plan, even if the format changes in the future.
.PP
Let's commit these changes and start creating the database changes.
.PP
.Vb 6
\&  > git add .
\&  > git commit \-am \*(AqInitialize Sqitch configuration.\*(Aq
\&  [master 79fe2cc] Initialize Sqitch configuration.
\&   2 files changed, 19 insertions(+)
\&   create mode 100644 sqitch.conf
\&   create mode 100644 sqitch.plan
.Ve
.SH "Our First Change"
.IX Header "Our First Change"
First, our app will need a database user, so let's create one. Run this
command:
.PP
.Vb 5
\&  > sqitch add appuser \-n \*(AqCreates a an application user.\*(Aq
\&  Created deploy/appuser.sql
\&  Created revert/appuser.sql
\&  Created verify/appuser.sql
\&  Added "appuser" to sqitch.plan
.Ve
.PP
The \f(CW\*(C`add\*(C'\fR command adds a database change to the plan and writes
deploy, revert, and verify scripts that represent the change. Now we edit
these files. The \f(CW\*(C`deploy\*(C'\fR script's job is to create the table. By default,
the \fIdeploy/appuser.sql\fR file looks like this:
.PP
.Vb 1
\&  \-\- Deploy flipr:appuser to mysql
\&
\&  BEGIN;
\&
\&  \-\- XXX Add DDLs here.
\&
\&  COMMIT;
.Ve
.PP
What we want to do is to replace the \f(CW\*(C`XXX\*(C'\fR comment with the \f(CW\*(C`CREATE USER\*(C'\fR
statement, like so:
.PP
.Vb 1
\&  \-\- Deploy flipr:users to mysql
\&
\&  BEGIN;
\&
\&  CREATE USER flipr;
\&
\&  COMMIT;
.Ve
.PP
The \f(CW\*(C`revert\*(C'\fR script's job is to precisely revert the change to the deploy
script, so we edit this to \fIrevert/appuser.sql\fR to look like this:
.PP
.Vb 1
\&  \-\- Revert flipr:users from mysql
\&
\&  BEGIN;
\&
\&  DROP USER flipr;
\&
\&  COMMIT;
.Ve
.PP
Now we can try deploying this change. First, we need to create a database
to deploy to:
.PP
.Vb 1
\&  > mysql \-u root \-\-execute \*(AqCREATE DATABASE flipr_test\*(Aq
.Ve
.PP
Now we tell Sqitch where to send the change via a
database \s-1URI\s0 <https://github.com/libwww-perl/uri-db/>:
.PP
.Vb 3
\&  > sqitch deploy db:mysql://root@/flipr_test
\&  Deploying changes to db:mysql://root@/flipr_test
\&    + appuser .. ok
.Ve
.PP
First Sqitch created the registry database and tables used to track database
changes. The registry database is separate from the database to which the
\&\f(CW\*(C`appuser\*(C'\fR change was deployed; by default, its name is \f(CW\*(C`sqitch\*(C'\fR, and will be
used to manage \fIall\fR projects on a single MySQL server. Ideally, only Sqitch
data will be stored in this database, so it probably makes the most sense to
create a superuser named \f(CW\*(C`sqitch\*(C'\fR or something similar and use it to deploy
changes.
.PP
If you'd like it to use a different database as the registry database, use
\&\f(CW\*(C`sqitch engine add mysql $name\*(C'\fR to configure it (or via the
\&\f(CW\*(C`target\*(C'\fR command; more below). This will be
useful if you don't want to use the same registry database to manage multiple
databases on the same server.
.PP
Next, Sqitch deploys changes to the target database, which we specified on the
command-line. We only have one change so far; the \f(CW\*(C`+\*(C'\fR reinforces the idea
that the change is being \fIadded\fR to the database.
.PP
With this change deployed, if you connect to the database, you'll be able to
see the user:
.PP
.Vb 6
\&  > mysql \-u root \-\-execute "SELECT user from mysql.user WHERE user = \*(Aqflipr\*(Aq;"
\&  +\-\-\-\-\-\-\-+
\&  | User  |
\&  +\-\-\-\-\-\-\-+
\&  | flipr |
\&  +\-\-\-\-\-\-\-+
.Ve
.SS "Trust, But Verify"
.IX Subsection "Trust, But Verify"
But that's too much work. do you really want to do something like that after
every deploy?
.PP
Here's where the \f(CW\*(C`verify\*(C'\fR script comes in. Its job is to test that the deploy
did was it was supposed to. It should do so without regard to any data that
might be in the database, and should throw an error if the deploy was not
successful. The simplest way to see if a user exists is to check the
\&\f(CW\*(C`mysql.user\*(C'\fR table. However, throwing an error in the event that the user
does not exist is tricky in MySQL. To simplify things, on MySQL 5.5.0 and
higher, Sqitch provides a custom function you can use in your tests,
\&\f(CW\*(C`checkit()\*(C'\fR. It works kind of like a \f(CW\*(C`CHECK\*(C'\fR constraint in other databases:
pass an expression as the first argument, and an error message as the second.
If the expression evaluates to false, an exception will be thrown with the
error message.
.PP
Give it a try. Put this query into \fIverify/appuser.sql\fR:
.PP
.Vb 2
\&  SELECT sqitch.checkit(COUNT(*), \*(AqUser "flipr" does not exist\*(Aq)
\&    FROM mysql.user WHERE user = \*(Aqflipr\*(Aq;
.Ve
.PP
This will work well as long as we know that the registry database is named
\&\f(CW\*(C`sqitch\*(C'\fR. If you've set \f(CW\*(C`engine.mysql.registry\*(C'\fR to a different value, you
will need to make sure you specify the correct database name in the script.
.PP
Now you can run the \f(CW\*(C`verify\*(C'\fR script with the \f(CW\*(C`verify\*(C'\fR
command:
.PP
.Vb 4
\&  > sqitch verify db:mysql://root@/flipr_test
\&  Verifying flipr_test
\&    * appuser .. ok
\&  Verify successful
.Ve
.PP
Looks good! If you want to make sure that the verify script correctly dies if
the table doesn't exist, temporarily change the user name in the script to
something that doesn't exist, something like:
.PP
.Vb 2
\&  SELECT sqitch.checkit(COUNT(*), \*(AqUser "flipr" does not exist\*(Aq)
\&    FROM mysql.user WHERE user = \*(Aqnonesuch\*(Aq;
.Ve
.PP
Then \f(CW\*(C`verify\*(C'\fR again:
.PP
.Vb 5
\&  > sqitch verify db:mysql://root@/flipr_test
\&  Verifying db:mysql://root@/flipr_test
\&    * appuser .. ERROR 1644 (ERR0R) at line 5 in file: \*(Aqverify/appuser.sql\*(Aq: User "flipr" does not exist
\&  # Verify script "verify/appuser.sql" failed.
\&  not ok
\&
\&  Verify Summary Report
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Changes: 1
\&  Errors:  1
\&  Verify failed
.Ve
.PP
The \f(CW\*(C`checkit()\*(C'\fR function is kind enough to use the error message to tell us
what the problem is. Don't forget to change the table name back before
continuing!
.SS "Status, Revert, Log, Repeat"
.IX Subsection "Status, Revert, Log, Repeat"
For purely informational purposes, we can always see how a deployment was
recorded via the \f(CW\*(C`status\*(C'\fR command, which reads the tables
from the registry database:
.PP
.Vb 9
\&  > sqitch status db:mysql://root@/flipr_test
\&  # On database db:mysql://root@/flipr_test
\&  # Project:  flipr
\&  # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
\&  # Name:     appuser
\&  # Deployed: 2013\-12\-31 13:13:17 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Let's make sure that we can revert the change:
.PP
.Vb 3
\&  > sqitch revert db:mysql://root@/flipr_test
\&  Revert all changes from db:mysql://root@/flipr_test? [Yes] 
\&    \- appuser .. ok
.Ve
.PP
The \f(CW\*(C`revert\*(C'\fR command first prompts to make sure that we
really do want to revert. This is to prevent unnecessary accidents. You can
pass the \f(CW\*(C`\-y\*(C'\fR option to disable the prompt. Also, notice the \f(CW\*(C`\-\*(C'\fR before the
change name in the output, which reinforces that the change is being
\&\fIremoved\fR from the database. And now the schema should be gone:
.PP
.Vb 1
\&  > mysql \-u root \-\-execute "SELECT user from mysql.user WHERE user = \*(Aqflipr\*(Aq;"
.Ve
.PP
And the status message should reflect as much:
.PP
.Vb 3
\&  > sqitch status db:mysql://root@/flipr_test
\&  # On database db:mysql://root@/flipr_test
\&  No changes deployed
.Ve
.PP
Of course, since nothing is deployed, the \f(CW\*(C`verify\*(C'\fR command
has nothing to verify:
.PP
.Vb 3
\&  > sqitch verify db:mysql://root@/flipr_test
\&  Verifying db:mysql://root@/flipr_test
\&  No changes deployed
.Ve
.PP
However, we still have a record that the change happened, visible via the
\&\f(CW\*(C`log\*(C'\fR command:
.PP
.Vb 6
\&  > sqitch log db:mysql://root@/flipr_test
\&  On database db:mysql://root@/flipr_test
\&  Revert f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
\&  Name:      appuser
\&  Committer: Marge N. OXVera <marge@example.com>
\&  Date:      2013\-12\-31 13:26:39 \-0800
\&
\&      Creates a an application user.
\&
\&  Deploy f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
\&  Name:      appuser
\&  Committer: Marge N. OXVera <marge@example.com>
\&  Date:      2013\-12\-31 13:13:17 \-0800
\&
\&      Creates a an application user.
.Ve
.PP
Note that the actions we took are shown in reverse chronological order, with
the revert first and then the deploy.
.PP
Cool. Now let's commit it.
.PP
.Vb 7
\&  > git add .
\&  > git commit \-m \*(AqAdd the "flipr" user.\*(Aq
\&  [master c63acb9] Add the "flipr" user.
\&   4 files changed, 23 insertions(+)
\&   create mode 100644 deploy/appuser.sql
\&   create mode 100644 revert/appuser.sql
\&   create mode 100644 verify/appuser.sql
.Ve
.PP
And then deploy again. This time, let's use the \f(CW\*(C`\-\-verify\*(C'\fR option, so that
the \f(CW\*(C`verify\*(C'\fR script is applied when the change is deployed:
.PP
.Vb 3
\&  > sqitch deploy \-\-verify db:mysql://root@/flipr_test
\&  Deploying changes to db:mysql://root@/flipr_test
\&    + appuser .. ok
.Ve
.PP
And now the \f(CW\*(C`flipr\*(C'\fR user should be back:
.PP
.Vb 6
\&  > mysql \-u root \-\-execute "SELECT user from mysql.user WHERE user = \*(Aqflipr\*(Aq;"
\&  +\-\-\-\-\-\-\-+
\&  | user  |
\&  +\-\-\-\-\-\-\-+
\&  | flipr |
\&  +\-\-\-\-\-\-\-+
.Ve
.PP
When we look at the status, the deployment will be there:
.PP
.Vb 9
\&  > sqitch status db:mysql://root@/flipr_test
\&  # On database db:mysql://root@/flipr_test
\&  # Project:  flipr
\&  # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
\&  # Name:     appuser
\&  # Deployed: 2013\-12\-31 13:28:23 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.SH "On Target"
.IX Header "On Target"
I'm getting a little tired of always having to type
\&\f(CW\*(C`db:mysql://root@/flipr_test\*(C'\fR, aren't you?  This
database connection \s-1URI\s0 <https://github.com/libwww-perl/uri-db/> tells Sqitch how
to connect to the deployment target, but we don't have to keep using the \s-1URI.\s0
We can name the target:
.PP
.Vb 1
\&  > sqitch target add flipr_test db:mysql://root@/flipr_test
.Ve
.PP
The \f(CW\*(C`target\*(C'\fR command, inspired by
\&\f(CW\*(C`git\-remote\*(C'\fR <https://git-scm.com/docs/git-remote>, allows management of one
or more named deployment targets. We've just added a target named
\&\f(CW\*(C`flipr_test\*(C'\fR, which means we can use the string \f(CW\*(C`flipr_test\*(C'\fR for the target,
rather than the \s-1URI.\s0 But since we're doing so much testing, we can also tell
Sqitch to deploy to the \f(CW\*(C`flipr_test\*(C'\fR target by default:
.PP
.Vb 1
\&  > sqitch engine add mysql flipr_test
.Ve
.PP
Now we can omit the target argument altogether, unless we need to deploy to
another database. Which we will, eventually, but at least our examples will be
simpler from here on in, e.g.:
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
\&  # Name:     appuser
\&  # Deployed: 2013\-12\-31 13:28:23 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Yay, that allows things to be a little more concise. Let's also make sure that
changes are verified after deploying them:
.PP
.Vb 2
\&  > sqitch config \-\-bool deploy.verify true
\&  > sqitch config \-\-bool rebase.verify true
.Ve
.PP
We'll see the \f(CW\*(C`rebase\*(C'\fR command a bit later. In the meantime,
let's commit the new configuration and and make some more changes!
.PP
.Vb 3
\&  > git commit \-am \*(AqSet default target and always verify.\*(Aq
\&  [master c793050] Set default target and always verify.
\&   1 file changed, 8 insertions(+)
.Ve
.SH "Deploy with Dependency"
.IX Header "Deploy with Dependency"
Let's add another change, this time to create a table. Our app will need
users, of course, so we'll create a table for them. First, add the new change:
.PP
.Vb 5
\&  > sqitch add users \-\-requires appuser \-n \*(AqCreates table to track our users.\*(Aq
\&  Created deploy/users.sql
\&  Created revert/users.sql
\&  Created verify/users.sql
\&  Added "users [appuser]" to sqitch.plan
.Ve
.PP
Note that we're requiring the \f(CW\*(C`appuser\*(C'\fR change as a dependency of the new
\&\f(CW\*(C`users\*(C'\fR change. Although that change has already been added to the plan and
therefore should always be applied before the \f(CW\*(C`users\*(C'\fR change, it's a good
idea to be explicit about dependencies.
.PP
Now edit the scripts. When you're done, \fIdeploy/users.sql\fR should look like
this:
.PP
.Vb 2
\&  \-\- Deploy flipr:users to mysql
\&  \-\- requires: appuser
\&
\&  BEGIN;
\&
\&  CREATE TABLE users (
\&      nickname  VARCHAR(512) PRIMARY KEY,
\&      password  VARCHAR(512) NOT NULL,
\&      timestamp DATETIME(6)  NOT NULL
\&  );
\&
\&  GRANT SELECT ON TABLE users TO flipr;
\&
\&  COMMIT;
.Ve
.PP
A few things to notice here. On the second line, the dependence on the
\&\f(CW\*(C`appuser\*(C'\fR change has been listed. This doesn't do anything, but the default
MySQL \f(CW\*(C`deploy\*(C'\fR template lists it here for your reference while editing the
file. Useful, right?
.PP
The \f(CW\*(C`flipr\*(C'\fR user has been granted \f(CW\*(C`SELECT\*(C'\fR access to the table. The app
needs to read the data, right? This is why we need to require the \f(CW\*(C`appuser\*(C'\fR
change.
.PP
Now for the verify script. The simplest way to check that the table was
created and has the expected columns without touching the data? Just select
from the table with a false \f(CW\*(C`WHERE\*(C'\fR clause. Add this to \fIverify/users.sql\fR:
.PP
.Vb 3
\&  SELECT nickname, password, timestamp
\&    FROM users
\&   WHERE 0;
.Ve
.PP
Now for the revert script: all we have to do is drop the table. Add this to
\&\fIrevert/users.sql\fR:
.PP
.Vb 1
\&  DROP TABLE users;
.Ve
.PP
Couldn't be much simpler, right? Let's deploy this bad boy:
.PP
.Vb 3
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + users .. ok
.Ve
.PP
We know, since verification is enabled, that the table must have been created.
But for the purposes of visibility, let's have a quick look:
.PP
.Vb 6
\&  > mysql \-u root \-D flipr_test \-\-execute \*(AqSHOW TABLES\*(Aq
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | Tables_in_flipr_test |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | users                |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
We can also verify all currently deployed changes with the
\&\f(CW\*(C`verify\*(C'\fR command:
.PP
.Vb 5
\&  > sqitch verify
\&  Verifying flipr_test
\&    * appuser .. ok
\&    * users .... ok
\&  Verify successful
.Ve
.PP
Now have a look at the status:
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   2bd1190fdb324c2609f0c7f0cef73d8cb434ba0e
\&  # Name:     users
\&  # Deployed: 2013\-12\-31 13:34:25 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Success! Let's make sure we can revert the change, as well:
.PP
.Vb 3
\&  > sqitch revert \-\-to @HEAD^ \-y
\&  Reverting changes to appuser from flipr_test
\&    \- users .. ok
.Ve
.PP
Note that we've used the \f(CW\*(C`\-\-to\*(C'\fR option to specify the change to revert to.
And what do we revert to? The symbolic tag \f(CW@HEAD\fR, when passed to
\&\f(CW\*(C`revert\*(C'\fR, always refers to the last change deployed to the
database. (For other commands, it refers to the last change in the plan.)
Appending the caret (\f(CW\*(C`^\*(C'\fR) tells Sqitch to select the change \fIprior\fR to the
last deployed change. So we revert to \f(CW\*(C`appuser\*(C'\fR, the penultimate change. The
other potentially useful symbolic tag is \f(CW@ROOT\fR, which refers to the first
change deployed to the database (or in the plan, depending on the command).
.PP
Back to the database. The \f(CW\*(C`users\*(C'\fR table should be gone but the \f(CW\*(C`flipr\*(C'\fR user
should still be around:
.PP
.Vb 7
\&  > mysql \-u root \-D flipr_test \-\-execute \*(AqSHOW TABLES\*(Aq
\&  > mysql \-u root \-\-execute "SELECT user from mysql.user WHERE user = \*(Aqflipr\*(Aq;"
\&  +\-\-\-\-\-\-\-+
\&  | User  |
\&  +\-\-\-\-\-\-\-+
\&  | flipr |
\&  +\-\-\-\-\-\-\-+
.Ve
.PP
The \f(CW\*(C`status\*(C'\fR command politely informs us that we have
undeployed changes:
.PP
.Vb 10
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   f56dd1a1ab029f398cec2cebb2ecc527fa0332c2
\&  # Name:     appuser
\&  # Deployed: 2013\-12\-31 13:28:23 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Undeployed change:
\&    * users
.Ve
.PP
As does the \f(CW\*(C`verify\*(C'\fR command:
.PP
.Vb 6
\&  > sqitch verify
\&  Verifying flipr_test
\&    * appuser .. ok
\&  Undeployed change:
\&    * users
\&  Verify successful
.Ve
.PP
Note that the verify is successful, because all currently-deployed changes are
verified. The list of undeployed changes (just \*(L"users\*(R" here) reminds us about
the current state.
.PP
Okay, let's commit and deploy again:
.PP
.Vb 10
\&  > git add .
\&  > git commit \-am \*(AqAdd users table.\*(Aq
\&  [master 7c99fb0] Add users table.
\&   4 files changed, 31 insertions(+)
\&   create mode 100644 deploy/users.sql
\&   create mode 100644 revert/users.sql
\&   create mode 100644 verify/users.sql
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + users .. ok
.Ve
.PP
Looks good. Check the status:
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   2bd1190fdb324c2609f0c7f0cef73d8cb434ba0e
\&  # Name:     users
\&  # Deployed: 2013\-12\-31 13:37:02 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Excellent. Let's do some more!
.SH "Add Two at Once"
.IX Header "Add Two at Once"
Let's add a couple more changes to add functions for managing users.
.PP
.Vb 6
\&  > sqitch add insert_user \-\-requires users \-\-requires appuser \e
\&    \-n \*(AqCreates a function to insert a user.\*(Aq
\&  Created deploy/insert_user.sql
\&  Created revert/insert_user.sql
\&  Created verify/insert_user.sql
\&  Added "insert_user [users appuser]" to sqitch.plan
\&
\&  > sqitch add change_pass \-\-requires users \-\-requires appuser \e
\&    \-n \*(AqCreates a function to change a user password.\*(Aq
\&  Created deploy/change_pass.sql
\&  Created revert/change_pass.sql
\&  Created verify/change_pass.sql
\&  Added "change_pass [users appuser]" to sqitch.plan
.Ve
.PP
Now might be a good time to have a look at the deployment plan:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-mysql\-intro/
\&
\&  appuser 2013\-12\-31T21:04:04Z Marge N. OXVera <marge@example.com> # Creates a an application user.
\&  users [appuser] 2013\-12\-31T21:32:48Z Marge N. OXVera <marge@example.com> # Creates table to track our users.
\&  insert_user [users appuser] 2013\-12\-31T21:37:29Z Marge N. OXVera <marge@example.com> # Creates a function to insert a user.
\&  change_pass [users appuser] 2013\-12\-31T21:37:36Z Marge N. OXVera <marge@example.com> # Creates a function to change a user password.
.Ve
.PP
Each change appears on a single line with the name of the change, a bracketed
list of dependencies, a timestamp, the name and email address of the user who
planned the change, and a note.
.PP
Let's write the code for the new changes. Here's what
\&\fIdeploy/insert_user.sql\fR should look like:
.PP
.Vb 3
\&  \-\- Deploy flipr:insert_user to mysql
\&  \-\- requires: users
\&  \-\- requires: appuser
\&
\&  BEGIN;
\&
\&  DELIMITER //
\&
\&  CREATE PROCEDURE insert_user(
\&      nickname VARCHAR(512),
\&      password VARCHAR(512)
\&  ) SQL SECURITY DEFINER
\&  BEGIN
\&      INSERT INTO users (nickname, password, timestamp)
\&      VALUES (nickname, md5(password), UTC_TIMESTAMP(6));
\&  END
\&  //
\&
\&  DELIMITER ;
\&
\&  GRANT EXECUTE ON PROCEDURE insert_user to flipr;
\&
\&  COMMIT;
.Ve
.PP
Here's what \fIverify/insert_user.sql\fR might look like, using the Sqitch
\&\f(CW\*(C`checkit()\*(C'\fR function again:
.PP
.Vb 1
\&  \-\- Verify flipr:insert_user on mysql
\&
\&  BEGIN;
\&
\&  SELECT sqitch.checkit(COUNT(*), \*(AqProcedure "insert_user" does not exist\*(Aq)
\&    FROM mysql.proc
\&   WHERE db = database()
\&     AND specific_name = \*(Aqinsert_user\*(Aq;
\&
\&  ROLLBACK;
.Ve
.PP
We simply take advantage of the fact that the new procedure should be listed
in the \f(CW\*(C`mysql.proc\*(C'\fR table and throw an exception if it does not exist.
.PP
And \fIrevert/insert_user.sql\fR should look something like this:
.PP
.Vb 4
\&  \-\- Revert flipr:insert_user from mysql
\&  BEGIN;
\&  DROP PROCEDURE insert_user;
\&  COMMIT;
.Ve
.PP
Now for \f(CW\*(C`change_pass\*(C'\fR; \fIdeploy/change_pass.sql\fR might look like this:
.PP
.Vb 3
\&  \-\- Deploy flipr:change_pass to mysql
\&  \-\- requires: users
\&  \-\- requires: appuser
\&
\&  BEGIN;
\&
\&  DELIMITER //
\&
\&  CREATE FUNCTION change_pass(
\&      nickname VARCHAR(512),
\&      oldpass  VARCHAR(512),
\&      newpass  VARCHAR(512)
\&  ) RETURNS INTEGER SQL SECURITY DEFINER
\&  BEGIN
\&      UPDATE users
\&         SET password = md5(newpass)
\&       WHERE nickname = nickname
\&         AND password = md5(oldpass);
\&      RETURN ROW_COUNT();
\&  END;
\&  //
\&
\&  DELIMITER ;
\&
\&  GRANT EXECUTE ON FUNCTION change_pass to flipr;
\&
\&  COMMIT;
.Ve
.PP
Use \f(CW\*(C`checkit()\*(C'\fR in \fIverify/change_pass.sql\fR again:
.PP
.Vb 6
\&  BEGIN;
\&  SELECT sqitch.checkit(COUNT(*), \*(AqProcedure "change_pass" does not exist\*(Aq)
\&    FROM mysql.proc
\&   WHERE db = database()
\&     AND specific_name = \*(Aqchange_pass\*(Aq;
\&  COMMIT;
.Ve
.PP
And of course, its \f(CW\*(C`revert\*(C'\fR script, \fIrevert/change_pass.sql\fR, should look
something like:
.PP
.Vb 4
\&  \-\- Revert flipr:change_pass from mysql
\&  BEGIN;
\&  DROP FUNCTION change_pass;
\&  COMMIT;
.Ve
.PP
Try em out!
.PP
.Vb 4
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + insert_user .. ok
\&    + change_pass .. ok
.Ve
.PP
Do we have the functions? Of course we do, they were verified. Still, have a
look:
.PP
.Vb 7
\&  > mysql \-u root \-\-execute "SELECT name FROM mysql.proc WHERE db = \*(Aqflipr_test\*(Aq"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | name        |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | change_pass |
\&  | insert_user |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
And what's the status?
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   b0a598b91ce97cf1b95ded97a6452bf03231a2cd
\&  # Name:     change_pass
\&  # Deployed: 2013\-12\-31 13:39:49 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Looks good. Let's make sure revert works:
.PP
.Vb 5
\&  > sqitch revert \-y \-\-to @HEAD^^
\&  Reverting changes to users from flipr_test
\&    \- change_pass .. ok
\&    \- insert_user .. ok
\&  > mysql \-u root \-\-execute "SELECT name FROM mysql.proc WHERE db = \*(Aqflipr_test\*(Aq"
.Ve
.PP
Note the use of \f(CW\*(C`@HEAD^^\*(C'\fR to specify that the revert be to two changes prior
the last deployed change. Looks good. Let's do the commit and re-deploy dance:
.PP
.Vb 10
\&  > git add .
\&  > git commit \-m \*(AqAdd \`insert_user()\` and \`change_pass()\`.\*(Aq
\&  [master 0f95e13] Add \`insert_user()\` and \`change_pass()\`.
\&   7 files changed, 86 insertions(+)
\&   create mode 100644 deploy/change_pass.sql
\&   create mode 100644 deploy/insert_user.sql
\&   create mode 100644 revert/change_pass.sql
\&   create mode 100644 revert/insert_user.sql
\&   create mode 100644 verify/change_pass.sql
\&   create mode 100644 verify/insert_user.sql
\&
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + insert_user .. ok
\&    + change_pass .. ok
\&
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   b0a598b91ce97cf1b95ded97a6452bf03231a2cd
\&  # Name:     change_pass
\&  # Deployed: 2013\-12\-31 13:40:40 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
\&
\&  > sqitch verify
\&  Verifying flipr_test
\&    * appuser ...... ok
\&    * users ........ ok
\&    * insert_user .. ok
\&    * change_pass .. ok
\&  Verify successful
.Ve
.PP
Great, we're fully up-to-date!
.SH "Ship It!"
.IX Header "Ship It!"
Let's do a first release of our app. Let's call it \f(CW\*(C`1.0.0\-dev1\*(C'\fR Since we want
to have it go out with deployments tied to the release, let's tag it:
.PP
.Vb 6
\&  > sqitch tag v1.0.0\-dev1 \-n \*(AqTag v1.0.0\-dev1.\*(Aq
\&  Tagged "change_pass" with @v1.0.0\-dev1
\&  > git commit \-am \*(AqTag the database with v1.0.0\-dev1.\*(Aq
\&  [master 0595297] Tag the database with v1.0.0\-dev1.
\&   1 file changed, 1 insertion(+)
\&  > git tag v1.0.0\-dev1 \-am \*(AqTag v1.0.0\-dev1\*(Aq
.Ve
.PP
Now let's bundle everything up for release:
.PP
.Vb 9
\&  > sqitch bundle
\&  Bundling into bundle/
\&  Writing config
\&  Writing plan
\&  Writing scripts
\&    + appuser
\&    + users
\&    + insert_user
\&    + change_pass @v1.0.0\-dev1
.Ve
.PP
Now we can package the \fIbundle\fR directory and distribute it. When it gets
installed somewhere, users can use Sqitch to deploy to the database. We ought
to try deploying it, but first we'll need to revert our existing databases, as
a single Sqitch project cannot be deployed to two databases on the same server
unless it uses a different registry database and the \f(CW\*(C`checkit()\*(C'\fR function is
not used in verify scripts. We have used \f(CW\*(C`checkit()\*(C'\fR quite a bit, so we need
to keep the Sqitch database name just where it is. Fortunately, it's easy to
build the database again, so let's just revert it.
.PP
.Vb 6
\&  > sqitch revert \-y
\&  Reverting all changes from flipr_test
\&    \- change_pass .. ok
\&    \- insert_user .. ok
\&    \- users ........ ok
\&    \- appuser ...... ok
.Ve
.PP
Now we can try deploying the bundle:
.PP
.Vb 8
\&  > cd bundle
\&  > mysql \-u root \-\-execute \*(AqCREATE DATABASE flipr_dev\*(Aq
\&  > sqitch deploy db:mysql://root@/flipr_dev
\&  Deploying changes to db:mysql://root@/flipr_dev
\&    + appuser ................... ok
\&    + users ..................... ok
\&    + insert_user ............... ok
\&    + change_pass @v1.0.0\-dev1 .. ok
.Ve
.PP
Great, all four changes were deployed and \f(CW\*(C`change_pass\*(C'\fR was tagged with
\&\f(CW\*(C`@v1.0.0\-dev1\*(C'\fR. Let's have a look at the status:
.PP
.Vb 10
\&  > sqitch status db:mysql://root@/flipr_dev
\&  # On database db:mysql://root@/flipr_dev
\&  # Project:  flipr
\&  # Change:   b0a598b91ce97cf1b95ded97a6452bf03231a2cd
\&  # Name:     change_pass
\&  # Tag:      @v1.0.0\-dev1
\&  # Deployed: 2013\-12\-31 13:44:04 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Looks good, eh? Go ahead and revert it:
.PP
.Vb 6
\&  > sqitch revert \-y db:mysql://root@/flipr_dev
\&  Reverting all changes from db:mysql://root@/flipr_dev
\&    \- change_pass @v1.0.0\-dev1 .. ok
\&    \- insert_user ............... ok
\&    \- users ..................... ok
\&    \- appuser ................... ok
.Ve
.PP
Now package it up and ship it!
.PP
.Vb 3
\&  > cd ..
\&  > mv bundle flipr\-v1.0.0\-dev1
\&  > tar \-czf flipr\-v1.0.0\-dev1.tgz flipr\-v1.0.0\-dev1
.Ve
.SH "Flip Out"
.IX Header "Flip Out"
Now that we've got the basics of user management done, let's get to work on
the core of our product, the \*(L"flip.\*(R" Since other folks are working on other
tasks in the repository, we'll work on a branch, so we can all stay out of
each other's way. So let's branch:
.PP
.Vb 2
\&  > git checkout \-b flips
\&  Switched to a new branch \*(Aqflips\*(Aq
.Ve
.PP
Now we can add a new change to create a table for our flips.
.PP
.Vb 5
\&  > sqitch add flips \-r appuser \-r users \-n \*(AqAdds table for storing flips.\*(Aq
\&  Created deploy/flips.sql
\&  Created revert/flips.sql
\&  Created verify/flips.sql
\&  Added "flips [appuser users]" to sqitch.plan
.Ve
.PP
You know the drill by now. Edit \fIdeploy/flips.sql\fR:
.PP
.Vb 3
\&  \-\- Deploy flipr:flips to mysql
\&  \-\- requires: appuser
\&  \-\- requires: users
\&
\&  BEGIN;
\&
\&  CREATE TABLE flips (
\&      id        BIGINT UNSIGNED PRIMARY KEY AUTO_INCREMENT,
\&      nickname  VARCHAR(512) NOT NULL REFERENCES users(nickname),
\&      body      VARCHAR(180) NOT NULL,
\&      timestamp DATETIME(6)  NOT NULL
\&  );
\&
\&  GRANT SELECT ON TABLE flips TO flipr;
\&
\&  COMMIT;
.Ve
.PP
Edit \fIverify/flips.sql\fR:
.PP
.Vb 1
\&  \-\- Verify flipr:flips on mysql
\&
\&  BEGIN;
\&
\&  SELECT id
\&       , nickname
\&       , body
\&       , timestamp
\&    FROM flipr.flips
\&   WHERE 0;
\&
\&  ROLLBACK;
.Ve
.PP
And edit \fIrevert/flips.sql\fR:
.PP
.Vb 1
\&  \-\- Revert flipr:flips from mysql
\&
\&  BEGIN;
\&
\&  DROP TABLE flips;
\&
\&  COMMIT;
.Ve
.PP
And give it a whirl:
.PP
.Vb 6
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + appuser ................... ok
\&    + users ..................... ok
\&    + insert_user ............... ok
\&    + change_pass @v1.0.0\-dev1 .. ok
.Ve
.PP
Look good?
.PP
.Vb 12
\&  > sqitch status \-\-show\-tags
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   b3ccd37da58ac232c23edfa0adaf2d6f483842fd
\&  # Name:     flips
\&  # Deployed: 2013\-12\-31 13:55:04 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  # Tag:
\&  #   @v1.0.0\-dev1 \- 2013\-12\-31 13:55:04 \-0800 \- Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Note the use of \f(CW\*(C`\-\-show\-tags\*(C'\fR to show all the deployed tags. Now make it so:
.PP
.Vb 7
\&  > git add .
\&  > git commit \-am \*(AqAdd flips table.\*(Aq
\&  [flips ce1b53d] Add flips table.
\&   4 files changed, 37 insertions(+)
\&   create mode 100644 deploy/flips.sql
\&   create mode 100644 revert/flips.sql
\&   create mode 100644 verify/flips.sql
.Ve
.SH "Wash, Rinse, Repeat"
.IX Header "Wash, Rinse, Repeat"
Now comes the time to add functions to manage flips. I'm sure you have things
nailed down now. Go ahead and add \f(CW\*(C`insert_flip\*(C'\fR and \f(CW\*(C`delete_flip\*(C'\fR changes
and commit them. The \f(CW\*(C`insert_flip\*(C'\fR deploy script might look something like:
.PP
.Vb 3
\&  \-\- Deploy flipr:insert_flip to mysql
\&  \-\- requires: flips
\&  \-\- requires: appuser
\&
\&  BEGIN;
\&
\&  DELIMITER //
\&
\&  CREATE FUNCTION insert_flip(
\&      nickname VARCHAR(512),
\&      body     VARCHAR(180)
\&  ) RETURNS BIGINT SQL SECURITY DEFINER
\&  BEGIN
\&      INSERT INTO flips (nickname, body)
\&      VALUES (nickname, body);
\&      RETURN LAST_INSERT_ID();
\&  END;
\&  //
\&
\&  DELIMITER ;
\&
\&  GRANT EXECUTE ON FUNCTION insert_flip to flipr;
\&
\&  COMMIT;
.Ve
.PP
And the \f(CW\*(C`delete_flip\*(C'\fR deploy script might look something like:
.PP
.Vb 3
\&  \-\- Deploy flipr:delete_flip to mysql
\&  \-\- requires: flips
\&  \-\- requires: appuser
\&
\&  BEGIN;
\&
\&  DELIMITER //
\&
\&  CREATE FUNCTION delete_flip(
\&      flip_id BIGINT
\&  ) RETURNS INTEGER SQL SECURITY DEFINER
\&  BEGIN
\&      DELETE FROM flips WHERE id = flip_id;
\&      RETURN ROW_COUNT();
\&  END;
\&  //
\&
\&  DELIMITER ;
\&
\&  GRANT EXECUTE ON FUNCTION delete_flip to flipr;
\&
\&  COMMIT;
.Ve
.PP
The \f(CW\*(C`verify\*(C'\fR scripts are:
.PP
.Vb 1
\&  \-\- Verify flipr:insert_flip on mysql
\&
\&  BEGIN;
\&
\&  SELECT sqitch.checkit(COUNT(*), \*(AqFunction "insert_flip" does not exist\*(Aq)
\&    FROM mysql.proc
\&   WHERE db = database()
\&     AND specific_name = \*(Aqinsert_flip\*(Aq;
\&
\&  ROLLBACK;
.Ve
.PP
And:
.PP
.Vb 1
\&  \-\- Verify flipr:delete_flip on mysql
\&
\&  BEGIN;
\&
\&  SELECT sqitch.checkit(COUNT(*), \*(AqFunction "delete_flip" does not exist\*(Aq)
\&    FROM mysql.proc
\&   WHERE db = database()
\&     AND specific_name = \*(Aqdelete_flip\*(Aq;
\&
\&  ROLLBACK;
.Ve
.PP
The \f(CW\*(C`revert\*(C'\fR scripts are:
.PP
.Vb 1
\&  \-\- Revert flipr:insert_flip from mysql
\&
\&  BEGIN;
\&
\&  DROP FUNCTION insert_flip;
\&
\&  COMMIT;
.Ve
.PP
And:
.PP
.Vb 1
\&  \-\- Revert flipr:delete_flip from mysql
\&
\&  BEGIN;
\&
\&  DROP FUNCTION delete_flip;
\&
\&  COMMIT;
.Ve
.PP
Check the example git repository <https://github.com/sqitchers/sqitch-intro> for
the complete details. Test \f(CW\*(C`deploy\*(C'\fR and
\&\f(CW\*(C`revert\*(C'\fR, then commit it to the repository. The status
should end up looking something like this:
.PP
.Vb 12
\&  > sqitch status \-\-show\-tags
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   7bf30e6b7b0a4e61f30dd4148f5b837bdddae086
\&  # Name:     delete_flip
\&  # Deployed: 2013\-12\-31 13:58:54 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  # Tag:
\&  #   @v1.0.0\-dev1 \- 2013\-12\-31 13:55:04 \-0800 \- Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Good, we've finished this feature. Time to merge back into \f(CW\*(C`master\*(C'\fR.
.SS "Emergency"
.IX Subsection "Emergency"
Let's do it:
.PP
.Vb 10
\&  > git checkout master
\&  Switched to branch \*(Aqmaster\*(Aq
\&  > git pull
\&  Updating 0595297..5a58089
\&  Fast\-forward
\&   deploy/delete_list.sql | 22 ++++++++++++++++++++++
\&   deploy/insert_list.sql | 25 +++++++++++++++++++++++++
\&   deploy/lists.sql       | 17 +++++++++++++++++
\&   revert/delete_list.sql |  7 +++++++
\&   revert/insert_list.sql |  7 +++++++
\&   revert/lists.sql       |  7 +++++++
\&   sqitch.plan            |  4 ++++
\&   verify/delete_list.sql | 10 ++++++++++
\&   verify/insert_list.sql | 10 ++++++++++
\&   verify/lists.sql       |  8 ++++++++
\&   10 files changed, 117 insertions(+)
\&   create mode 100644 deploy/delete_list.sql
\&   create mode 100644 deploy/insert_list.sql
\&   create mode 100644 deploy/lists.sql
\&   create mode 100644 revert/delete_list.sql
\&   create mode 100644 revert/insert_list.sql
\&   create mode 100644 revert/lists.sql
\&   create mode 100644 verify/delete_list.sql
\&   create mode 100644 verify/insert_list.sql
\&   create mode 100644 verify/lists.sql
.Ve
.PP
Hrm, that's interesting. Looks like someone made some changes to \f(CW\*(C`master\*(C'\fR.
They added list support. Well, let's see what happens when we merge our
changes.
.PP
.Vb 4
\&  > git merge \-\-no\-ff flips
\&  Auto\-merging sqitch.plan
\&  CONFLICT (content): Merge conflict in sqitch.plan
\&  Automatic merge failed; fix conflicts and then commit the result.
.Ve
.PP
Oh, a conflict in \fIsqitch.plan\fR. Not too surprising, since both the merged
\&\f(CW\*(C`lists\*(C'\fR branch and our \f(CW\*(C`flips\*(C'\fR branch added changes to the plan. Let's try a
different approach.
.PP
The truth is, we got lazy. Those changes when we pulled master from the origin
should have raised a red flag. It's considered a bad practice not to look at
what's changed in \f(CW\*(C`master\*(C'\fR before merging in a branch. What one \fIshould\fR do
is either:
.IP "\(bu" 4
Rebase the \fIflips\fR branch from master before merging. This \*(L"rewinds\*(R" the
branch changes, pulls from \f(CW\*(C`master\*(C'\fR, and then replays the changes back on top
of the pulled changes.
.IP "\(bu" 4
Create a patch and apply \fIthat\fR to master. This is the sort of thing you
might have to do if you're sending changes to another user, especially if the
\&\s-1VCS\s0 is not Git.
.PP
So let's restore things to how they were at master:
.PP
.Vb 2
\&  > git reset \-\-hard HEAD
\&  HEAD is now at 5a58089 Merge branch \*(Aqlists\*(Aq
.Ve
.PP
That throws out our botched merge. Now let's go back to our branch and rebase
it on \f(CW\*(C`master\*(C'\fR:
.PP
.Vb 10
\&  > git checkout flips
\&  Switched to branch \*(Aqflips\*(Aq
\&  > git rebase master
\&  First, rewinding head to replay your work on top of it...
\&  Applying: Add flips table.
\&  Using index info to reconstruct a base tree...
\&  M     sqitch.plan
\&  Falling back to patching base and 3\-way merge...
\&  Auto\-merging sqitch.plan
\&  CONFLICT (content): Merge conflict in sqitch.plan
\&  Failed to merge in the changes.
\&  Patch failed at 0001 Add flips table.
\&  The copy of the patch that failed is found in:
\&     .git/rebase\-apply/patch
\&
\&  When you have resolved this problem, run "git rebase \-\-continue".
\&  If you prefer to skip this patch, run "git rebase \-\-skip" instead.
\&  To check out the original branch and stop rebasing, run "git rebase \-\-abort".
.Ve
.PP
Oy, that's kind of a pain. It seems like no matter what we do, we'll need to
resolve conflicts in that file. Except in Git. Fortunately for us, we can tell
Git to resolve conflicts in \fIsqitch.plan\fR differently. Because we only ever
append lines to the file, we can have it use the \*(L"union\*(R" merge driver, which,
according to its
docs <https://git-scm.com/docs/gitattributes#_built-in_merge_drivers>:
.Sp
.RS 4
Run 3\-way file level merge for text files, but take lines from both versions,
instead of leaving conflict markers. This tends to leave the added lines in
the resulting file in random order and the user should verify the result. Do
not use this if you do not understand the implications.
.RE
.PP
This has the effect of appending lines from all the merging files, which is
exactly what we need. So let's give it a try. First, back out the botched
rebase:
.PP
.Vb 1
\&  > git rebase \-\-abort
.Ve
.PP
Now add the union merge driver to \fI.gitattributes\fR for \fIsqitch.plan\fR
and rebase again:
.PP
.Vb 10
\&  > echo sqitch.plan merge=union > .gitattributes
\&  > git rebase master
\&  First, rewinding head to replay your work on top of it...
\&  Applying: Add flips table.
\&  Using index info to reconstruct a base tree...
\&  M     sqitch.plan
\&  Falling back to patching base and 3\-way merge...
\&  Auto\-merging sqitch.plan
\&  Applying: Add functions to insert and delete flips.
\&  Using index info to reconstruct a base tree...
\&  M     sqitch.plan
\&  Falling back to patching base and 3\-way merge...
\&  Auto\-merging sqitch.plan
.Ve
.PP
Ah, that looks a bit better. Let's have a look at the plan:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-mysql\-intro/
\&
\&  appuser 2013\-12\-31T21:04:04Z Marge N. OXVera <marge@example.com> # Creates a an application user.
\&  users [appuser] 2013\-12\-31T21:32:48Z Marge N. OXVera <marge@example.com> # Creates table to track our users.
\&  insert_user [users appuser] 2013\-12\-31T21:37:29Z Marge N. OXVera <marge@example.com> # Creates a function to insert a user.
\&  change_pass [users appuser] 2013\-12\-31T21:37:36Z Marge N. OXVera <marge@example.com> # Creates a function to change a user password.
\&  @v1.0.0\-dev1 2013\-12\-31T21:41:08Z Marge N. OXVera <marge@example.com> # Tag v1.0.0\-dev1.
\&
\&  lists [appuser users] 2013\-12\-31T21:46:22Z Marge N. OXVera <marge@example.com> # Adds table for storing lists.
\&  insert_list [lists appuser] 2013\-12\-31T21:48:14Z Marge N. OXVera <marge@example.com> # Creates a function to insert a list.
\&  delete_list [lists appuser] 2013\-12\-31T21:49:41Z Marge N. OXVera <marge@example.com> # Creates a function to insert a list.
\&  flips [appuser users] 2013\-12\-31T21:53:03Z Marge N. OXVera <marge@example.com> # Adds table for storing flips.
\&  insert_flip [flips appuser] 2013\-12\-31T21:56:12Z Marge N. OXVera <marge@example.com> # Creates a function to insert a flip.
\&  delete_flip [flips appuser] 2013\-12\-31T21:56:22Z Marge N. OXVera <marge@example.com> # Creates a function to delete a flip.
.Ve
.PP
Note that it has appended the changes from the merged \*(L"lists\*(R" branch, and then
merged the changes from our \*(L"flips\*(R" branch. Test it to make sure it works as
expected:
.PP
.Vb 10
\&  > sqitch rebase \-y
\&  Reverting all changes from flipr_test
\&    \- delete_flip ............... ok
\&    \- insert_flip ............... ok
\&    \- flips ..................... ok
\&    \- change_pass @v1.0.0\-dev1 .. ok
\&    \- insert_user ............... ok
\&    \- users ..................... ok
\&    \- appuser ................... ok
\&  Deploying changes to flipr_test
\&    + appuser ................... ok
\&    + users ..................... ok
\&    + insert_user ............... ok
\&    + change_pass @v1.0.0\-dev1 .. ok
\&    + lists ..................... ok
\&    + insert_list ............... ok
\&    + delete_list ............... ok
\&    + flips ..................... ok
\&    + insert_flip ............... ok
\&    + delete_flip ............... ok
.Ve
.PP
Note the use of \f(CW\*(C`rebase\*(C'\fR, which combines a
\&\f(CW\*(C`revert\*(C'\fR and a \f(CW\*(C`deploy\*(C'\fR into a single
command. Handy, right? It correctly reverted our changes, and then deployed
them all again in the proper order. So let's commit \fI.gitattributes\fR; seems
worthwhile to keep that change:
.PP
.Vb 5
\&  > git add .
\&  > git commit \-m \*(AqAdd \`.gitattributes\` with union merge for \`sqitch.plan\`.\*(Aq
\&  [flips d813f7c] Add \`.gitattributes\` with union merge for \`sqitch.plan\`.
\&   1 file changed, 1 insertion(+)
\&   create mode 100644 .gitattributes
.Ve
.SS "Merges Mastered"
.IX Subsection "Merges Mastered"
And now, finally, we can merge into \f(CW\*(C`master\*(C'\fR:
.PP
.Vb 10
\&  > git checkout master
\&  Switched to branch \*(Aqmaster\*(Aq
\&  > git merge \-\-no\-ff flips \-m "Merge branch \*(Aqflips\*(Aq"
\&  Merge made by the \*(Aqrecursive\*(Aq strategy.
\&   .gitattributes         |  1 +
\&   deploy/delete_flip.sql | 22 ++++++++++++++++++++++
\&   deploy/flips.sql       | 16 ++++++++++++++++
\&   deploy/insert_flip.sql | 24 ++++++++++++++++++++++++
\&   revert/delete_flip.sql |  7 +++++++
\&   revert/flips.sql       |  7 +++++++
\&   revert/insert_flip.sql |  7 +++++++
\&   sqitch.plan            |  3 +++
\&   verify/delete_flip.sql | 10 ++++++++++
\&   verify/flips.sql       | 12 ++++++++++++
\&   verify/insert_flip.sql | 10 ++++++++++
\&   11 files changed, 119 insertions(+)
\&   create mode 100644 .gitattributes
\&   create mode 100644 deploy/delete_flip.sql
\&   create mode 100644 deploy/flips.sql
\&   create mode 100644 deploy/insert_flip.sql
\&   create mode 100644 revert/delete_flip.sql
\&   create mode 100644 revert/flips.sql
\&   create mode 100644 revert/insert_flip.sql
\&   create mode 100644 verify/delete_flip.sql
\&   create mode 100644 verify/flips.sql
\&   create mode 100644 verify/insert_flip.sql
.Ve
.PP
And double-check our work:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-mysql\-intro/
\&
\&  appuser 2013\-12\-31T21:04:04Z Marge N. OXVera <marge@example.com> # Creates a an application user.
\&  users [appuser] 2013\-12\-31T21:32:48Z Marge N. OXVera <marge@example.com> # Creates table to track our users.
\&  insert_user [users appuser] 2013\-12\-31T21:37:29Z Marge N. OXVera <marge@example.com> # Creates a function to insert a user.
\&  change_pass [users appuser] 2013\-12\-31T21:37:36Z Marge N. OXVera <marge@example.com> # Creates a function to change a user password.
\&  @v1.0.0\-dev1 2013\-12\-31T21:41:08Z Marge N. OXVera <marge@example.com> # Tag v1.0.0\-dev1.
\&
\&  lists [appuser users] 2013\-12\-31T21:46:22Z Marge N. OXVera <marge@example.com> # Adds table for storing lists.
\&  insert_list [lists appuser] 2013\-12\-31T21:48:14Z Marge N. OXVera <marge@example.com> # Creates a function to insert a list.
\&  delete_list [lists appuser] 2013\-12\-31T21:49:41Z Marge N. OXVera <marge@example.com> # Creates a function to insert a list.
\&  flips [appuser users] 2013\-12\-31T21:53:03Z Marge N. OXVera <marge@example.com> # Adds table for storing flips.
\&  insert_flip [flips appuser] 2013\-12\-31T21:56:12Z Marge N. OXVera <marge@example.com> # Creates a function to insert a flip.
\&  delete_flip [flips appuser] 2013\-12\-31T21:56:22Z Marge N. OXVera <marge@example.com> # Creates a function to delete a flip.
.Ve
.PP
Much much better, a nice clean master now. And because it is now identical to
the \*(L"flips\*(R" branch, we can just carry on. Go ahead and tag it, bundle, and
release:
.PP
.Vb 10
\&  > sqitch tag v1.0.0\-dev2 \-n \*(AqTag v1.0.0\-dev2.\*(Aq
\&  Tagged "delete_flip" with @v1.0.0\-dev2
\&  > git commit \-am \*(AqTag the database with v1.0.0\-dev2.\*(Aq
\&  [master 76d6e15] Tag the database with v1.0.0\-dev2.
\&   1 file changed, 1 insertion(+)
\&  > git tag v1.0.0\-dev2 \-am \*(AqTag v1.0.0\-dev2\*(Aq
\&  > sqitch bundle \-\-dest\-dir flipr\-1.0.0\-dev2
\&  Bundling into flipr\-1.0.0\-dev2
\&  Writing config
\&  Writing plan
\&  Writing scripts
\&    + appuser
\&    + users
\&    + insert_user
\&    + change_pass @v1.0.0\-dev1
\&    + lists
\&    + insert_list
\&    + delete_list
\&    + flips
\&    + insert_flip
\&    + delete_flip @v1.0.0\-dev2
.Ve
.PP
Note the use of the \f(CW\*(C`\-\-dest\-dir\*(C'\fR option to \f(CW\*(C`sqitch bundle\*(C'\fR. Just a nicer way
to create the top-level directory name so we don't have to rename it from
\&\fIbundle\fR.
.SH "In Place Changes"
.IX Header "In Place Changes"
Uh-oh, someone just noticed that \s-1MD5\s0 hashing is not particularly secure. Why?
Have a look at this:
.PP
.Vb 11
\&  > mysql \-u root \-D flipr_test \-\-execute "
\&      CALL insert_user(\*(Aqfoo\*(Aq, \*(Aqsecr3t\*(Aq);
\&      CALL insert_user(\*(Aqbar\*(Aq, \*(Aqsecr3t\*(Aq);
\&      SELECT * FROM users;
\&  "
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | nickname | password                         | timestamp                  |
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | bar      | 9695da4dd567a19f9b92065f240c6725 | 2013\-12\-31 22:06:28.359118 |
\&  | foo      | 9695da4dd567a19f9b92065f240c6725 | 2013\-12\-31 22:06:28.358789 |
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
If user \*(L"foo\*(R" ever got access to the database, she could quickly discover that
user \*(L"bar\*(R" has the same password and thus be able to exploit the account. Not
a great idea. So we need to modify the \f(CW\*(C`insert_user()\*(C'\fR and \f(CW\*(C`change_pass()\*(C'\fR
functions to fix that. How?
.PP
We can use MySQL's
\&\f(CW\*(C`ENCRYPT()\*(C'\fR <https://dev.mysql.com/doc/refman/5.5/en/encryption-functions.html#function_encrypt>
function to encrypt passwords with a salt, so that they're all unique. But how
to deploy the changes to \f(CW\*(C`insert_user()\*(C'\fR and \f(CW\*(C`change_pass()\*(C'\fR?
.PP
Normally, modifying functions in database changes is a
\&\s-1PITA\s0 <https://www.urbandictionary.com/define.php?term=pita>. You have to make
changes like these:
.IP "1." 4
Copy \fIdeploy/insert_user.sql\fR to \fIdeploy/insert_user_encrypt.sql\fR.
.IP "2." 4
Edit \fIdeploy/insert_user_encrypt.sql\fR to switch from \f(CW\*(C`MD5()\*(C'\fR to \f(CW\*(C`ENCRYPT()\*(C'\fR.
.IP "3." 4
Copy \fIdeploy/insert_user.sql\fR to \fIrevert/insert_user_encrypt.sql\fR.
Yes, copy the original change script to the new revert change.
.IP "4." 4
Copy \fIverify/insert_user.sql\fR to \fIverify/insert_user_encrypt.sql\fR.
.IP "5." 4
Edit \fIverify/insert_user_encrypt.sql\fR to test that the function now properly
uses \f(CW\*(C`ENCRYPT()\*(C'\fR.
.IP "6." 4
Test the changes to make sure you can deploy and revert the
\&\f(CW\*(C`insert_user_encrypt\*(C'\fR change.
.IP "7." 4
Now do the same for the \f(CW\*(C`change_pass\*(C'\fR scripts.
.PP
But you can have Sqitch do it for you. The only requirement is that a tag
appear between the two instances of a change we want to modify. In general,
you're going to make a change like this after a release, which you've tagged
anyway, right? Well we have, with \f(CW\*(C`@v1.0.0\-dev2\*(C'\fR added in the previous
section. With that, we can let Sqitch do most of the hard work for us, thanks
to the \f(CW\*(C`rework\*(C'\fR command, which is similar to
\&\f(CW\*(C`add\*(C'\fR:
.PP
.Vb 6
\&  > sqitch rework insert_user \-n \*(AqChange insert_user to use encyrpt().\*(Aq
\&  Added "insert_user [insert_user@v1.0.0\-dev2]" to sqitch.plan.
\&  Modify these files as appropriate:
\&    * deploy/insert_user.sql
\&    * revert/insert_user.sql
\&    * verify/insert_user.sql
.Ve
.PP
Oh, so we can edit those files in place. Nice! How does Sqitch do it? Well, in
point of fact, it has copied the files to stand in for the previous instance
of the \f(CW\*(C`insert_user\*(C'\fR change, which we can see via \f(CW\*(C`git status\*(C'\fR:
.PP
.Vb 10
\&  > git status
\&  # On branch master
\&  # Your branch is ahead of \*(Aqorigin/master\*(Aq by 5 commits.
\&  #   (use "git push" to publish your local commits)
\&  #
\&  # Changes not staged for commit:
\&  #   (use "git add <file>..." to update what will be committed)
\&  #   (use "git checkout \-\- <file>..." to discard changes in working directory)
\&  #
\&  #     modified:   revert/insert_user.sql
\&  #     modified:   sqitch.plan
\&  #
\&  # Untracked files:
\&  #   (use "git add <file>..." to include in what will be committed)
\&  #
\&  #     deploy/insert_user@v1.0.0\-dev2.sql
\&  #     revert/insert_user@v1.0.0\-dev2.sql
\&  #     verify/insert_user@v1.0.0\-dev2.sql
\&  no changes added to commit (use "git add" and/or "git commit \-a")
.Ve
.PP
The \*(L"untracked files\*(R" part of the output is the first thing to notice. They
are all named \f(CW\*(C`insert_user@v1.0.0\-dev2.sql\*(C'\fR. What that means is: "the
\&\f(CW\*(C`insert_user\*(C'\fR change as it was implemented as of the \f(CW\*(C`@v1.0.0\-dev2\*(C'\fR tag."
These are copies of the original scripts, and thereafter Sqitch will find them
when it needs to run scripts for the first instance of the \f(CW\*(C`insert_user\*(C'\fR
change. As such, it's important not to change them again. But hey, if you're
reworking the change, you shouldn't need to.
.PP
The other thing to notice is that \fIrevert/insert_user.sql\fR has changed.
Sqitch replaced it with the original deploy script. As of now,
\&\fIdeploy/insert_user.sql\fR and \fIrevert/insert_user.sql\fR are identical. This is
on the assumption that the deploy script will be changed (we're reworking it,
remember?), and that the revert script should actually change things back to
how they were before. Of course, the original deploy script may not be
idempotent <https://en.wikipedia.org/wiki/Idempotence> \*(-- that is, able to be
applied multiple times without changing the result beyond the initial
application. If it's not, you will likely need to modify it so that it
properly restores things to how they were after the original deploy script was
deployed. Or, more simply, it should revert changes back to how they were
as-of the deployment of \fIdeploy/insert_user@v1.0.0\-dev2.sql\fR.
.PP
Had MySQL supported an \f(CW\*(C`OR REPLACE\*(C'\fR expression on \f(CW\*(C`CREATE FUNCTION\*(C'\fR and we
had used it, our function deploy scripts would already idempotent. No matter
how many times they were run, the end results would be the same instance of
the function, with no duplicates or errors.
.PP
Alas, such is not the case for MySQL, so we will have to modify the scripts to
drop the function before re-creating it. So let's do it. We'll modify the
scripts drop and re-create the functions with to use \f(CW\*(C`ENCRYPT()\*(C'\fR. Make this
change to \fIdeploy/insert_user.sql\fR:
.PP
.Vb 1
\&  @@ \-6,13 +6,14 @@ BEGIN;
\& 
\&   DELIMITER //
\& 
\&  +DROP PROCEDURE insert_user;
\&   CREATE PROCEDURE insert_user(
\&       nickname VARCHAR(512),
\&       password VARCHAR(512)
\&   ) SQL SECURITY DEFINER
\&   BEGIN
\&       INSERT INTO users (nickname, password, timestamp)
\&  \-    VALUES (nickname, md5(password), UTC_TIMESTAMP(6));
\&  +    VALUES (nickname, ENCRYPT(md5(password), md5(FLOOR(RAND() * 0xFFFFFFFF))), UTC_TIMESTAMP(6));
\&   END
\&   //
.Ve
.PP
We just need to add the \f(CW\*(C`DROP\*(C'\fR statement to the revert script,
\&\fIrevert/insert_user.sql\fR:
.PP
.Vb 1
\&  @@ \-6,6 +6,7 @@ BEGIN;
\& 
\&   DELIMITER //
\& 
\&  +DROP PROCEDURE insert_user;
\&   CREATE PROCEDURE insert_user(
\&       nickname VARCHAR(512),
\&       password VARCHAR(512)
.Ve
.PP
Go ahead and rework the \f(CW\*(C`change_pass\*(C'\fR change, too:
.PP
.Vb 6
\&  > sqitch rework change_pass \-n \*(AqChange change_pass to use encyrpt().\*(Aq
\&  Added "change_pass [change_pass@v1.0.0\-dev2]" to sqitch.plan.
\&  Modify these files as appropriate:
\&    * deploy/change_pass.sql
\&    * revert/change_pass.sql
\&    * verify/change_pass.sql
.Ve
.PP
And make this change to \fIdeploy/change_pass.sql\fR:
.PP
.Vb 1
\&  @@ \-6,6 +6,7 @@ BEGIN;
\& 
\&   DELIMITER //
\& 
\&  +DROP FUNCTION change_pass;
\&   CREATE FUNCTION change_pass(
\&       nickname VARCHAR(512),
\&       oldpass  VARCHAR(512),
\&  @@ \-13,9 +14,9 @@ CREATE FUNCTION change_pass(
\&   ) RETURNS INTEGER SQL SECURITY DEFINER
\&   BEGIN
\&       UPDATE users
\&  \-       SET password = md5(newpass)
\&  +       SET password = ENCRYPT(md5(newpass), md5(FLOOR(RAND() * 0xFFFFFFFF)))
\&        WHERE nickname = nickname
\&  \-       AND password = md5(oldpass);
\&  +       AND password = ENCRYPT(md5(oldpass), password);
\&       RETURN ROW_COUNT();
\&   END;
\&   //
.Ve
.PP
And add the \f(CW\*(C`DROP FUNCTION\*(C'\fR statement to its revert script, too:
.PP
.Vb 1
\&  @@ \-6,6 +6,7 @@ BEGIN;
\& 
\&   DELIMITER //
\& 
\&  +DROP FUNCTION change_pass;
\&   CREATE FUNCTION change_pass(
\&       nickname VARCHAR(512),
\&       oldpass  VARCHAR(512),
.Ve
.PP
And now we're ready to try a deployment:
.PP
.Vb 4
\&  >     sqitch deploy
\&  Deploying changes to flipr_test
\&    + insert_user .. ok
\&    + change_pass .. ok
.Ve
.PP
So, are the changes deployed?
.PP
.Vb 12
\&  > mysql \-u root \-D flipr_test \-\-execute "
\&      DELETE FROM users;
\&      CALL insert_user(\*(Aqfoo\*(Aq, \*(Aqsecr3t\*(Aq);
\&      CALL insert_user(\*(Aqbar\*(Aq, \*(Aqsecr3t\*(Aq);
\&      SELECT * FROM users;
\&  "
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | nickname | password      | timestamp                  |
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | bar      | 0aasvM1.AzY0Y | 2013\-12\-31 22:14:45.554942 |
\&  | foo      | 80v1DpnRrqbwo | 2013\-12\-31 22:14:45.554457 |
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Awesome, the stored passwords are different now. But can we revert, even
though we haven't written any reversion scripts?
.PP
.Vb 4
\&  > sqitch revert \-\-to @HEAD^^ \-y
\&  Reverting changes to delete_flip @v1.0.0\-dev2 from flipr_test
\&    \- change_pass .. ok
\&    \- insert_user .. ok
.Ve
.PP
Did that work, are the \f(CW\*(C`MD5()\*(C'\fR passwords back?
.PP
.Vb 12
\&  > mysql \-u root \-D flipr_test \-\-execute "
\&      DELETE FROM users;
\&      CALL insert_user(\*(Aqfoo\*(Aq, \*(Aqsecr3t\*(Aq);
\&      CALL insert_user(\*(Aqbar\*(Aq, \*(Aqsecr3t\*(Aq);
\&      SELECT * FROM users;
\&  "
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | nickname | password                         | timestamp                  |
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | bar      | 9695da4dd567a19f9b92065f240c6725 | 2013\-12\-31 22:15:29.843140 |
\&  | foo      | 9695da4dd567a19f9b92065f240c6725 | 2013\-12\-31 22:15:29.842700 |
\&  +\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+
.Ve
.PP
Yes, it works! Sqitch properly finds the original instances of these changes
in the new script files that include tags.
.PP
But what about the verify script? How can we verify that the functions have
been modified to use \f(CW\*(C`ENCRYPT()\*(C'\fR? I think the simplest thing to do is to
examine the body of the function as returned by
\&\f(CW\*(C`INFORMATION_SCHEMA.ROUTINES\*(C'\fR <https://dev.mysql.com/doc/refman/5.6/en/routines-table.html>
So the \f(CW\*(C`insert_user\*(C'\fR verify script looks like this:
.PP
.Vb 1
\&  \-\- Verify flipr:insert_user on mysql
\&
\&  BEGIN;
\&
\&  SELECT sqitch.checkit(COUNT(*), \*(AqProcedure "insert_user" does not exist or is not up\-to\-date\*(Aq)
\&    FROM mysql.proc
\&   WHERE db = database()
\&     AND specific_name = \*(Aqinsert_user\*(Aq
\&     AND body_utf8 LIKE \*(Aq%ENCRYPT(md5(password), md5(FLOOR(RAND() * 0xFFFFFFFF))%\*(Aq;
\&
\&  ROLLBACK;
.Ve
.PP
And the \f(CW\*(C`change_pass\*(C'\fR verify script looks like this:
.PP
.Vb 1
\&  \-\- Verify flipr:change_pass on mysql
\&
\&  BEGIN;
\&
\&  SELECT sqitch.checkit(COUNT(*), \*(AqProcedure "change_pass" does not exist or is not up\-to\-date\*(Aq)
\&    FROM mysql.proc
\&   WHERE db = database()
\&     AND specific_name = \*(Aqchange_pass\*(Aq
\&     AND body_utf8 LIKE \*(Aq%ENCRYPT(md5(oldpass), password)%\*(Aq;
\&
\&  ROLLBACK;
.Ve
.PP
Make sure these pass by re-deploying:
.PP
.Vb 4
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + insert_user .. ok
\&    + change_pass .. ok
.Ve
.PP
Excellent. Let's go ahead and commit these changes:
.PP
.Vb 10
\&  > git add .
\&  > git commit \-m \*(AqUse encrypt() to encrypt passwords.\*(Aq
\&  [master abcce73] Use encrypt() to encrypt passwords.
\&   13 files changed, 137 insertions(+), 9 deletions(\-)
\&   create mode 100644 deploy/change_pass@v1.0.0\-dev2.sql
\&   create mode 100644 deploy/insert_user@v1.0.0\-dev2.sql
\&   create mode 100644 revert/change_pass@v1.0.0\-dev2.sql
\&   create mode 100644 revert/insert_user@v1.0.0\-dev2.sql
\&   create mode 100644 verify/change_pass@v1.0.0\-dev2.sql
\&   create mode 100644 verify/insert_user@v1.0.0\-dev2.sql
\&
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   6f2e1cd4b1c031a66930811328cfcdb0389d8320
\&  # Name:     change_pass
\&  # Deployed: 2013\-12\-31 14:16:45 \-0800
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.SH "More to Come"
.IX Header "More to Come"
Sqitch is a work in progress. Better integration with version control systems
is planned to make managing idempotent reworkings even easier. Stay tuned.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
