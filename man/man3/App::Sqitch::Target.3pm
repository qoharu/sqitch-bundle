.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Sqitch::Target 3"
.TH App::Sqitch::Target 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
App::Sqitch::Target \- Sqitch deployment target
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 5
\&  my $plan = App::Sqitch::Target\->new(
\&      sqitch => $sqitch,
\&      name   => \*(Aqdevelopment\*(Aq,
\&  );
\&  $target\->engine\->deploy;
.Ve
.SH "Description"
.IX Header "Description"
App::Sqitch::Target provides collects, in one place, the
engine, plan, and file locations
required to carry out Sqitch commands. All commands should instantiate a
target to work with the plan or database.
.SH "Interface"
.IX Header "Interface"
.SS "Constructors"
.IX Subsection "Constructors"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  my $target = App::Sqitch::Target\->new( sqitch => $sqitch );
.Ve
.PP
Instantiates and returns an App::Sqitch::Target object. The most important
parameters are \f(CW\*(C`sqitch\*(C'\fR, \f(CW\*(C`name\*(C'\fR, and \f(CW\*(C`uri\*(C'\fR. The constructor tries really
hard to figure out the proper name and \s-1URI\s0 during construction. If the \f(CW\*(C`uri\*(C'\fR
parameter is passed, this is straight-forward: if no \f(CW\*(C`name\*(C'\fR is passed,
\&\f(CW\*(C`name\*(C'\fR will be set to the stringified format of the \s-1URI\s0 (minus the password,
if present).
.PP
Otherwise, when no \s-1URI\s0 is passed, the name and \s-1URI\s0 are determined by taking
the following steps:
.IP "\(bu" 4
If there is no name, get the engine key from or the \f(CW\*(C`core.engine\*(C'\fR
+configuration option. If no key can be determined, an exception will be
thrown.
.IP "\(bu" 4
Use the key to look up the target name in the \f(CW\*(C`engine.$engine.target\*(C'\fR
configuration option. If none is found, use \f(CW\*(C`db:$key:\*(C'\fR.
.IP "\(bu" 4
If the name contains a colon (\f(CW\*(C`:\*(C'\fR), assume it is also the value for the \s-1URI.\s0
.IP "\(bu" 4
Otherwise, it should be the name of a configured target, so look for a \s-1URI\s0 in
the \f(CW\*(C`target.$name.uri\*(C'\fR configuration option.
.PP
As a general rule, then, pass either a target name or \s-1URI\s0 string in the
\&\f(CW\*(C`name\*(C'\fR parameter, and Sqitch will do its best to find all the relevant target
information. And if there is no name or \s-1URI,\s0 it will try to construct a
reasonable default from the command-line options or engine configuration.
.PP
All Target attributes may be passed as parameters to \f(CW\*(C`new()\*(C'\fR. In addition,
\&\f(CW\*(C`new()\*(C'\fR accepts a few non-attribute parameters that may be used to override
parts of the connection \s-1URI.\s0 They are:
.IP "\(bu" 4
\&\f(CW\*(C`user\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`host\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`port\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`dbname\*(C'\fR
.PP
For example, if the the named target had its \s-1URI\s0 configured as
\&\f(CW\*(C`db:pg://fred@example.com/work\*(C'\fR, The \f(CW\*(C`uri\*(C'\fR would be set as such by:
.PP
.Vb 2
\&  my $target = App::Sqitch::Target\->new(sqitch => $sqitch, name => \*(Aqwork\*(Aq);
\&  say $target\->uri;
.Ve
.PP
However, passing the \s-1URI\s0 parameters like this:
.PP
.Vb 7
\&  my $target = App::Sqitch::Target\->new(
\&      sqitch => $sqitch,
\&      name => \*(Aqwork\*(Aq,
\&      user => \*(Aqbill\*(Aq,
\&      port => 1212,
\&  );
\&  say $target\->uri;
.Ve
.PP
Sets the \s-1URI\s0 to \f(CW\*(C`db:pg://bill@example.com:1212/work\*(C'\fR.
.PP
\fI\f(CI\*(C`all_targets\*(C'\fI\fR
.IX Subsection "all_targets"
.PP
Returns a list of all the targets defined by the local Sqitch configuration
file. Done by examining the configuration object to find all defined targets
and engines, as well as the default \*(L"core\*(R" target. Duplicates are removed and
the list returned. This method takes the same parameters as \f(CW\*(C`new\*(C'\fR; only
\&\f(CW\*(C`sqitch\*(C'\fR is required. All other parameters will be set on all of the returned
targets.
.SS "Accessors"
.IX Subsection "Accessors"
\fI\f(CI\*(C`sqitch\*(C'\fI\fR
.IX Subsection "sqitch"
.PP
.Vb 1
\&  my $sqitch = $target\->sqitch;
.Ve
.PP
Returns the App::Sqitch object that instantiated the target.
.PP
\fI\f(CI\*(C`name\*(C'\fI\fR
.IX Subsection "name"
.PP
\fI\f(CI\*(C`target\*(C'\fI\fR
.IX Subsection "target"
.PP
.Vb 2
\&  my $name = $target\->name;
\&  $name = $target\->target;
.Ve
.PP
The name of the target. If there was no name specified, the \s-1URI\s0 will be used
(minus the password, if there is one).
.PP
\fI\f(CI\*(C`uri\*(C'\fI\fR
.IX Subsection "uri"
.PP
.Vb 1
\&  my $uri = $target\->uri;
.Ve
.PP
The URI::db object encapsulating the database connection information.
.PP
\fI\f(CI\*(C`username\*(C'\fI\fR
.IX Subsection "username"
.PP
.Vb 1
\&  my $username = $target\->username;
.Ve
.PP
Returns the target username, if any. The username is looked up from the \s-1URI.\s0
.PP
\fI\f(CI\*(C`password\*(C'\fI\fR
.IX Subsection "password"
.PP
.Vb 1
\&  my $password = $target\->password;
.Ve
.PP
Returns the target password, if any. The password is looked up from the \s-1URI\s0
or the \f(CW$SQITCH_PASSWORD\fR environment variable.
.PP
\fI\f(CI\*(C`engine\*(C'\fI\fR
.IX Subsection "engine"
.PP
.Vb 1
\&  my $engine = $target\->engine;
.Ve
.PP
A App::Sqitch::Engine object to use for database interactions with the
target.
.PP
\fI\f(CI\*(C`registry\*(C'\fI\fR
.IX Subsection "registry"
.PP
.Vb 1
\&  my $registry = $target\->registry;
.Ve
.PP
The name of the registry used by the database. The value comes from one of
these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-registry\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.registry\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.registry\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.registry\*(C'\fR
.IP "\(bu" 4
Engine-specific default
.PP
\fI\f(CI\*(C`client\*(C'\fI\fR
.IX Subsection "client"
.PP
.Vb 1
\&  my $client = $target\->client;
.Ve
.PP
Path to the engine command-line client. The value comes from one of these
options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-client\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.client\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.client\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.client\*(C'\fR
.IP "\(bu" 4
Engine-and-OS-specific default
.PP
\fI\f(CI\*(C`top_dir\*(C'\fI\fR
.IX Subsection "top_dir"
.PP
.Vb 1
\&  my $top_dir = $target\->top_dir;
.Ve
.PP
The path to the top directory of the project. This directory generally
contains the plan file and subdirectories for deploy, revert, and verify
scripts. The value comes from one of these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-top\-dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.top_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.top_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.top_dir\*(C'\fR
.IP "\(bu" 4
\&\fI.\fR
.PP
\fI\f(CI\*(C`plan_file\*(C'\fI\fR
.IX Subsection "plan_file"
.PP
.Vb 1
\&  my $plan_file = $target\->plan_file;
.Ve
.PP
The path to the plan file. The value comes from one of these options, searched
in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-plan\-file\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.plan_file\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.plan_file\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.plan_file\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI$top_dir\fI/sqitch.plan\fR
.PP
\fI\f(CI\*(C`deploy_dir\*(C'\fI\fR
.IX Subsection "deploy_dir"
.PP
.Vb 1
\&  my $deploy_dir = $target\->deploy_dir;
.Ve
.PP
The path to the deploy directory of the project. This directory contains all
of the deploy scripts referenced by changes in the \f(CW\*(C`plan_file\*(C'\fR. The value
comes from one of these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir deploy_dir=$deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI\*(C`$top_dir/deploy\*(C'\fI\fR
.PP
\fI\f(CI\*(C`revert_dir\*(C'\fI\fR
.IX Subsection "revert_dir"
.PP
.Vb 1
\&  my $revert_dir = $target\->revert_dir;
.Ve
.PP
The path to the revert directory of the project. This directory contains all
of the revert scripts referenced by changes the \f(CW\*(C`plan_file\*(C'\fR. The value comes
from one of these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir revert_dir=$revert_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.revert_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.revert_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.revert_dir\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI\*(C`$top_dir/revert\*(C'\fI\fR
.PP
\fI\f(CI\*(C`verify_dir\*(C'\fI\fR
.IX Subsection "verify_dir"
.PP
.Vb 1
\&  my $verify_dir = $target\->verify_dir;
.Ve
.PP
The path to the verify directory of the project. This directory contains all
of the verify scripts referenced by changes in the \f(CW\*(C`plan_file\*(C'\fR. The value
comes from one of these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir verify_dir=$verify_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.verify_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.verify_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.verify_dir\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI\*(C`$top_dir/verify\*(C'\fI\fR
.PP
\fI\f(CI\*(C`reworked_dir\*(C'\fI\fR
.IX Subsection "reworked_dir"
.PP
.Vb 1
\&  my $reworked_dir = $target\->reworked_dir;
.Ve
.PP
The path to the reworked directory of the project. This directory contains
subdirectories for reworked deploy, revert, and verify scripts. The value
comes from one of these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir reworked_dir=$reworked_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.reworked_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.reworked_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.reworked_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW$top_dir\fR
.PP
\fI\f(CI\*(C`reworked_deploy_dir\*(C'\fI\fR
.IX Subsection "reworked_deploy_dir"
.PP
.Vb 1
\&  my $reworked_deploy_dir = $target\->reworked_deploy_dir;
.Ve
.PP
The path to the reworked deploy directory of the project. This directory
contains all of the reworked deploy scripts referenced by changes in the
\&\f(CW\*(C`plan_file\*(C'\fR. The value comes from one of these options, searched in this
order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir reworked_deploy_dir=$reworked_deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.reworked_deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.reworked_deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.reworked_deploy_dir\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI\*(C`$reworked_dir/reworked_deploy\*(C'\fI\fR
.PP
\fI\f(CI\*(C`reworked_revert_dir\*(C'\fI\fR
.IX Subsection "reworked_revert_dir"
.PP
.Vb 1
\&  my $reworked_revert_dir = $target\->reworked_revert_dir;
.Ve
.PP
The path to the reworked revert directory of the project. This directory
contains all of the reworked revert scripts referenced by changes the
\&\f(CW\*(C`plan_file\*(C'\fR. The value comes from one of these options, searched in this
order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir reworked_revert_dir=$reworked_revert_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.reworked_revert_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.reworked_revert_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.reworked_revert_dir\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI\*(C`$reworked_dir/reworked_revert\*(C'\fI\fR
.PP
\fI\f(CI\*(C`reworked_verify_dir\*(C'\fI\fR
.IX Subsection "reworked_verify_dir"
.PP
.Vb 1
\&  my $reworked_verify_dir = $target\->reworked_verify_dir;
.Ve
.PP
The path to the reworked verify directory of the project. This directory
contains all of the reworked verify scripts referenced by changes in the
\&\f(CW\*(C`plan_file\*(C'\fR. The value comes from one of these options, searched in this
order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-dir reworked_verify_dir=$reworked_verify_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.reworked_verify_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.reworked_verify_dir\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.reworked_verify_dir\*(C'\fR
.IP "\(bu" 4
\&\fI\f(CI\*(C`$reworked_dir/reworked_verify\*(C'\fI\fR
.PP
\fI\f(CI\*(C`extension\*(C'\fI\fR
.IX Subsection "extension"
.PP
.Vb 1
\&  my $extension = $target\->extension;
.Ve
.PP
The file name extension to append to change names to create script file names.
The value comes from one of these options, searched in this order:
.IP "\(bu" 4
\&\f(CW\*(C`\-\-extension\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.extension\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.extension\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`core.extension\*(C'\fR
.IP "\(bu" 4
\&\f(CW"sql"\fR
.PP
\fI\f(CI\*(C`variables\*(C'\fI\fR
.IX Subsection "variables"
.PP
.Vb 1
\&  my $variables = $target\->variables;
.Ve
.PP
The database variables to use in change scripts. The value are merged from
these options, in this order:
.IP "\(bu" 4
\&\f(CW\*(C`target.$name.variables\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`engine.$engine.variables\*(C'\fR
.PP
The \f(CW\*(C`core.variables\*(C'\fR configuration is not read, because command-specific
configurations, such as \f(CW\*(C`deploy.variables\*(C'\fR and \f(CW\*(C`revert.variables\*(C'\fR take
priority. The command themselves therefore pass them to the engine in the
proper priority order.
.PP
\fI\f(CI\*(C`engine_key\*(C'\fI\fR
.IX Subsection "engine_key"
.PP
.Vb 1
\&  my $key = $target\->engine_key;
.Ve
.PP
The key defining which engine to use. This value defines the class loaded by
\&\f(CW\*(C`engine\*(C'\fR. Convenience method for \f(CW\*(C`$target\->uri\->canonical_engine\*(C'\fR.
.PP
\fI\f(CI\*(C`dsn\*(C'\fI\fR
.IX Subsection "dsn"
.PP
.Vb 1
\&  my $dsn = $target\->dsn;
.Ve
.PP
The \s-1DSN\s0 to use when connecting to the target via the \s-1DBI.\s0 Convenience method
for \f(CW\*(C`$target\->uri\->dbi_dsn\*(C'\fR.
.PP
\fI\f(CI\*(C`username\*(C'\fI\fR
.IX Subsection "username"
.PP
.Vb 1
\&  my $username = $target\->username;
.Ve
.PP
The username to use when connecting to the target via the \s-1DBI.\s0 Convenience
method for \f(CW\*(C`$target\->uri\->user\*(C'\fR.
.PP
\fI\f(CI\*(C`password\*(C'\fI\fR
.IX Subsection "password"
.PP
.Vb 1
\&  my $password = $target\->password;
.Ve
.PP
The password to use when connecting to the target via the \s-1DBI.\s0 Convenience
method for \f(CW\*(C`$target\->uri\->password\*(C'\fR.
.SH "See Also"
.IX Header "See Also"
.IP "sqitch" 4
.IX Item "sqitch"
The Sqitch command-line client.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
