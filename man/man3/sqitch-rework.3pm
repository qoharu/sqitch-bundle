.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sqitch-rework 3"
.TH sqitch-rework 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
sqitch-rework \- Rework a database change
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  sqitch  rework [options] [<dependency\-options>] name
.Ve
.SH "Description"
.IX Header "Description"
This command allows for the reworking of an existing database change. It is
best used only under the following circumstances:
.IP "\(bu" 4
There are production deployments, so that you cannot revert to before the
change, modify it, and then re-deploy. Just reverting, modifying, and
re-deploying is the thing to do while developing the database, but once it
has been released and deployed to production, you must not change previous
change scripts.
.IP "\(bu" 4
The modifications will be idempotent <https://en.wikipedia.org/wiki/Idempotence>.
In other words, either the earlier instance of the change or the new, reworked
instance can be run any number of times, and the outcome of each will be the same.
They must not break each other in case one needs to deploy and revert changes.
.IP "\(bu" 4
A tag must have been applied to the plan since the previous instance of the
change. This is required so that Sqitch can disambiguate the two instances of
the change. It's a good idea to always tag a release anyway. If you haven't,
see sqitch-tag.
.PP
If all of these hold, then feel free to rework an existing change.
.PP
In effect, reworking a change is similar to adding one. However,
rather than writing new files for the change, the \f(CW\*(C`rework\*(C'\fR command copies the
files for the existing change. The new files are named with the tag that comes
between the changes, and serves as the file for the original change. This
leaves you free to edit the existing files.
.PP
By default, the \f(CW\*(C`rework\*(C'\fR command will rework the change in the default plan
and the scripts to any top directories for that plan, as defined by the core
configuration and command-line options. This works well for projects in which
there is a single plan with separate top directories for each engine, for
example. Pass the \f(CW\*(C`\-\-all\*(C'\fR option to have it iterate over all known plans and
top directories (as specified for engines and targets) and rework the change
to them all. Of course, the a change by that name must exist in all the plans
of the reworking will fail.
.PP
To specify which plans to in which to rework the change, pass the target,
engine, or plan file names to tag as arguments. Use \f(CW\*(C`\-\-change\*(C'\fR to
disambiguate the and change name from the other parameters if necessary (or
preferable). See \*(L"Examples\*(R" for examples.
.SH "Options"
.IX Header "Options"
.ie n .IP """\-c""" 4
.el .IP "\f(CW\-c\fR" 4
.IX Item "-c"
.PD 0
.ie n .IP """\-\-change""" 4
.el .IP "\f(CW\-\-change\fR" 4
.IX Item "--change"
.ie n .IP """\-\-change\-name""" 4
.el .IP "\f(CW\-\-change\-name\fR" 4
.IX Item "--change-name"
.PD
The name of the change to rework. The name can be specified with or without
this option, but the option can be useful for disambiguating the change name
from other arguments.
.ie n .IP """\-r""" 4
.el .IP "\f(CW\-r\fR" 4
.IX Item "-r"
.PD 0
.ie n .IP """\-\-requires""" 4
.el .IP "\f(CW\-\-requires\fR" 4
.IX Item "--requires"
.PD
Name of a change that is required by the new change. May be specified multiple
times. See sqitchchanges for the various ways in which changes can be
specified.
.ie n .IP """\-x""" 4
.el .IP "\f(CW\-x\fR" 4
.IX Item "-x"
.PD 0
.ie n .IP """\-\-conflicts""" 4
.el .IP "\f(CW\-\-conflicts\fR" 4
.IX Item "--conflicts"
.PD
Name of a change that conflicts with the new change. May be specified multiple
times. See sqitchchanges for the various ways in which changes can be
specified.
.ie n .IP """\-a""" 4
.el .IP "\f(CW\-a\fR" 4
.IX Item "-a"
.PD 0
.ie n .IP """\-\-all""" 4
.el .IP "\f(CW\-\-all\fR" 4
.IX Item "--all"
.PD
Rework the change in all plans in the project. Cannot be mixed with target,
engine, or plan file name arguments; doing so will result in an error. Useful
for multi-plan projects in which changes should be kept in sync. Overrides the
value of the \f(CW\*(C`add.all\*(C'\fR configuration; use \f(CW\*(C`\-\-no\-all\*(C'\fR to override a true
\&\f(CW\*(C`add.all\*(C'\fR configuration.
.ie n .IP """\-n""" 4
.el .IP "\f(CW\-n\fR" 4
.IX Item "-n"
.PD 0
.ie n .IP """\-\-note""" 4
.el .IP "\f(CW\-\-note\fR" 4
.IX Item "--note"
.PD
A brief note describing the purpose of the reworking. The note will be
attached to the change as a comment. Multiple invocations will be concatenated
together as separate paragraphs.
.Sp
For you Git folks out there, \f(CW\*(C`\-m\*(C'\fR also works.
.ie n .IP """\-e""" 4
.el .IP "\f(CW\-e\fR" 4
.IX Item "-e"
.PD 0
.ie n .IP """\-\-edit""" 4
.el .IP "\f(CW\-\-edit\fR" 4
.IX Item "--edit"
.ie n .IP """\-\-open\-editor""" 4
.el .IP "\f(CW\-\-open\-editor\fR" 4
.IX Item "--open-editor"
.PD
Open the generated change scripts in an editor.
.ie n .IP """\-\-no\-edit""" 4
.el .IP "\f(CW\-\-no\-edit\fR" 4
.IX Item "--no-edit"
.PD 0
.ie n .IP """\-\-no\-open\-editor""" 4
.el .IP "\f(CW\-\-no\-open\-editor\fR" 4
.IX Item "--no-open-editor"
.PD
Do not open the change scripts in an editor. Useful when \f(CW\*(C`rework.open_editor\*(C'\fR
is true.
.ie n .IP """\-\-plan\-file""" 4
.el .IP "\f(CW\-\-plan\-file\fR" 4
.IX Item "--plan-file"
.PD 0
.ie n .IP """\-f""" 4
.el .IP "\f(CW\-f\fR" 4
.IX Item "-f"
.PD
Path to the deployment plan file. Overrides target, engine, and core
configuration values. Defaults to \fI\f(CI$top_dir\fI/sqitch.plan\fR.
.SH "Examples"
.IX Header "Examples"
Rework a change in a project and be prompted for a note.
.PP
.Vb 1
\&  sqitch rework widgets
.Ve
.PP
Rework a change and specify the note.
.PP
.Vb 1
\&  sqitch rework sprockets \-\-note \*(AqReworks the sprockets view.\*(Aq
.Ve
.PP
Rework a change that requires the \f(CW\*(C`users\*(C'\fR change from earlier in the plan.
.PP
.Vb 1
\&  sqitch rework contacts \-\-requires users \-n \*(AqReworks the contacts view.\*(Aq
.Ve
.PP
Rework a change that requires multiple changes, including the change named
\&\f(CW\*(C`extract\*(C'\fR from a completely different Sqitch project named \f(CW\*(C`utilities\*(C'\fR:
.PP
.Vb 1
\&  sqitch rework coffee \-r users \-r utilities:extract \-n \*(AqMmmmm...coffee!\*(Aq
.Ve
.PP
Rework a change only to the plan used by the \f(CW\*(C`vertica\*(C'\fR engine in a project:
.PP
.Vb 1
\&  sqitch rework \-\-change logs vertica \-n \*(AqReworks the logs view in Vertica.\*(Aq
.Ve
.PP
Rework a change in two plans in a project, and generate the scripts only for
those plans:
.PP
.Vb 1
\&  sqitch rework \-a coolfunctions sqlite.plan pg.plan \-n \*(AqReworks functions.\*(Aq
.Ve
.SH "Configuration Variables"
.IX Header "Configuration Variables"
.ie n .IP """rework.all""" 4
.el .IP "\f(CWrework.all\fR" 4
.IX Item "rework.all"
Rework the change to all the plans in the project. Useful for multi-plan projects
in which changes should be kept in sync. May be overridden by \f(CW\*(C`\-\-all\*(C'\fR,
\&\f(CW\*(C`\-\-no\-all\*(C'\fR, or target, engine, and plan file name arguments.
.ie n .IP """rework.open_editor""" 4
.el .IP "\f(CWrework.open_editor\fR" 4
.IX Item "rework.open_editor"
Boolean indicating if the rework command should spawn an editor after
generating change scripts.  When true, equivalent to passing \f(CW\*(C`\-\-edit\*(C'\fR.
Defaults off.
.SH "Sqitch"
.IX Header "Sqitch"
Part of the sqitch suite.
