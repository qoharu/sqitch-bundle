.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Sqitch::Engine 3"
.TH App::Sqitch::Engine 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
App::Sqitch::Engine \- Sqitch Deployment Engine
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  my $engine = App::Sqitch::Engine\->new( sqitch => $sqitch );
.Ve
.SH "Description"
.IX Header "Description"
App::Sqitch::Engine provides the base class for all Sqitch storage engines.
Most likely this will not be of much interest to you unless you are hacking on
the engine code.
.SH "Interface"
.IX Header "Interface"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`key\*(C'\fI\fR
.IX Subsection "key"
.PP
.Vb 1
\&  my $name = App::Sqitch::Engine\->key;
.Ve
.PP
The key name of the engine. Should be the last part of the package name.
.PP
\fI\f(CI\*(C`name\*(C'\fI\fR
.IX Subsection "name"
.PP
.Vb 1
\&  my $name = App::Sqitch::Engine\->name;
.Ve
.PP
The name of the engine. Returns the same value as \f(CW\*(C`key\*(C'\fR by default, but
should probably be overridden to return a display name for the engine.
.PP
\fI\f(CI\*(C`default_registry\*(C'\fI\fR
.IX Subsection "default_registry"
.PP
.Vb 1
\&  my $reg = App::Sqitch::Engine\->default_registry;
.Ve
.PP
Returns the name of the default registry for the engine. Most engines just
inherit the default value, \f(CW\*(C`sqitch\*(C'\fR, but some must do more munging, such as
specifying a file name, to determine the default registry name.
.PP
\fI\f(CI\*(C`default_client\*(C'\fI\fR
.IX Subsection "default_client"
.PP
.Vb 1
\&  my $cli = App::Sqitch::Engine\->default_client;
.Ve
.PP
Returns the name of the default client for the engine. Must be implemented by
each engine.
.PP
\fI\f(CI\*(C`driver\*(C'\fI\fR
.IX Subsection "driver"
.PP
.Vb 1
\&  my $driver = App::Sqitch::Engine\->driver;
.Ve
.PP
The name and version of the database driver to use with the engine, returned
as a string suitable for passing to \f(CW\*(C`use\*(C'\fR. Used internally by \f(CW\*(C`use_driver()\*(C'\fR
to \f(CW\*(C`use\*(C'\fR the driver and, if it dies, to display an appropriate error message.
Must be overridden by subclasses.
.PP
\fI\f(CI\*(C`use_driver\*(C'\fI\fR
.IX Subsection "use_driver"
.PP
.Vb 1
\&  App::Sqitch::Engine\->use_driver;
.Ve
.PP
Uses the driver and version returned by \f(CW\*(C`driver\*(C'\fR. Returns an error on failure
and returns true on success.
.PP
\fI\f(CI\*(C`config_vars\*(C'\fI\fR
.IX Subsection "config_vars"
.PP
.Vb 1
\&  my %vars = App::Sqitch::Engine\->config_vars;
.Ve
.PP
Returns a hash of names and types to use for configuration variables for the
engine. These can be set under the \f(CW\*(C`engine.$engine_name\*(C'\fR section in any
configuration file.
.PP
The keys in the returned hash are the names of the variables. The values are
the data types. Valid data types include:
.ie n .IP """any""" 4
.el .IP "\f(CWany\fR" 4
.IX Item "any"
.PD 0
.ie n .IP """int""" 4
.el .IP "\f(CWint\fR" 4
.IX Item "int"
.ie n .IP """num""" 4
.el .IP "\f(CWnum\fR" 4
.IX Item "num"
.ie n .IP """bool""" 4
.el .IP "\f(CWbool\fR" 4
.IX Item "bool"
.ie n .IP """bool\-or\-int""" 4
.el .IP "\f(CWbool\-or\-int\fR" 4
.IX Item "bool-or-int"
.PD
.PP
Values ending in \f(CW\*(C`+\*(C'\fR (a plus sign) may be specified multiple times. Example:
.PP
.Vb 6
\&  (
\&      client => \*(Aqany\*(Aq,
\&      host   => \*(Aqany\*(Aq,
\&      port   => \*(Aqint\*(Aq,
\&      set    => \*(Aqany+\*(Aq,
\&  )
.Ve
.PP
In this example, the \f(CW\*(C`port\*(C'\fR variable will be stored and retrieved as an
integer. The \f(CW\*(C`set\*(C'\fR variable may be of any type and may be included multiple
times. All the other variables may be of any type.
.PP
By default, App::Sqitch::Engine returns:
.PP
.Vb 5
\&  (
\&      target   => \*(Aqany\*(Aq,
\&      registry => \*(Aqany\*(Aq,
\&      client   => \*(Aqany\*(Aq,
\&  )
.Ve
.PP
Subclasses for supported engines will return more.
.PP
\fI\f(CI\*(C`registry_release\*(C'\fI\fR
.IX Subsection "registry_release"
.PP
Returns the version of the registry understood by this release of Sqitch. The
\&\f(CW\*(C`needs_upgrade()\*(C'\fR method compares this value to that returned by
\&\f(CW\*(C`registry_version()\*(C'\fR to determine whether the target's registry needs
upgrading.
.SS "Constructors"
.IX Subsection "Constructors"
\fI\f(CI\*(C`load\*(C'\fI\fR
.IX Subsection "load"
.PP
.Vb 1
\&  my $cmd = App::Sqitch::Engine\->load(%params);
.Ve
.PP
A factory method for instantiating Sqitch engines. It loads the subclass for
the specified engine and calls \f(CW\*(C`new\*(C'\fR, passing the Sqitch object. Supported
parameters are:
.ie n .IP """sqitch""" 4
.el .IP "\f(CWsqitch\fR" 4
.IX Item "sqitch"
The App::Sqitch object driving the whole thing.
.PP
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  my $engine = App::Sqitch::Engine\->new(%params);
.Ve
.PP
Instantiates and returns a App::Sqitch::Engine object.
.SS "Instance Accessors"
.IX Subsection "Instance Accessors"
\fI\f(CI\*(C`sqitch\*(C'\fI\fR
.IX Subsection "sqitch"
.PP
The current Sqitch object.
.PP
\fI\f(CI\*(C`target\*(C'\fI\fR
.IX Subsection "target"
.PP
An App::Sqitch::Target object identifying the database target, usually
derived from the name of target specified on the command-line, or the default.
.PP
\fI\f(CI\*(C`uri\*(C'\fI\fR
.IX Subsection "uri"
.PP
A URI::db object representing the target database. Defaults to a \s-1URI\s0
constructed from the App::Sqitch \f(CW\*(C`db_*\*(C'\fR attributes.
.PP
\fI\f(CI\*(C`destination\*(C'\fI\fR
.IX Subsection "destination"
.PP
A string identifying the target database. Usually the same as the \f(CW\*(C`target\*(C'\fR,
unless it's a \s-1URI\s0 with the password included, in which case it returns the
value of \f(CW\*(C`uri\*(C'\fR with the password removed.
.PP
\fI\f(CI\*(C`registry\*(C'\fI\fR
.IX Subsection "registry"
.PP
The name of the registry schema or database.
.PP
\fI\f(CI\*(C`start_at\*(C'\fI\fR
.IX Subsection "start_at"
.PP
The point in the plan from which to start deploying changes.
.PP
\fI\f(CI\*(C`no_prompt\*(C'\fI\fR
.IX Subsection "no_prompt"
.PP
Boolean indicating whether or not to prompt for reverts. False by default.
.PP
\fI\f(CI\*(C`log_only\*(C'\fI\fR
.IX Subsection "log_only"
.PP
Boolean indicating whether or not to log changes \fIwithout running deploy or
revert scripts\fR. This is useful for an existing database schema that needs to
be converted to Sqitch. False by default.
.PP
\fI\f(CI\*(C`with_verify\*(C'\fI\fR
.IX Subsection "with_verify"
.PP
Boolean indicating whether or not to run the verification script after each
deploy script. False by default.
.PP
\fI\f(CI\*(C`variables\*(C'\fI\fR
.IX Subsection "variables"
.PP
A hash of engine client variables to be set. May be set and retrieved as a
list.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`username\*(C'\fI\fR
.IX Subsection "username"
.PP
.Vb 1
\&  my $username = $engine\->username;
.Ve
.PP
The username to use to connect to the database, for engines that require
authentication. The username is looked up in the following places, returning
the first to have a value:
.IP "1." 4
The \f(CW$SQITCH_USERNAME\fR environment variable.
.IP "2." 4
The username from the target \s-1URI.\s0
.IP "3." 4
An engine-specific default password, which may be derived from an environment
variable, engine configuration file, the system user, or none at all.
.PP
See sqitch-authentication for details and best practices for Sqitch engine
authentication.
.PP
\fI\f(CI\*(C`password\*(C'\fI\fR
.IX Subsection "password"
.PP
.Vb 1
\&  my $password = $engine\->password;
.Ve
.PP
The password to use to connect to the database, for engines that require
authentication. The password is looked up in the following places, returning
the first to have a value:
.IP "1." 4
The \f(CW$SQITCH_PASSWORD\fR environment variable.
.IP "2." 4
The password from the target \s-1URI.\s0
.IP "3." 4
An engine-specific default password, which may be derived from an environment
variable, engine configuration file, or none at all.
.PP
See sqitch-authentication for details and best practices for Sqitch engine
authentication.
.PP
\fI\f(CI\*(C`registry_destination\*(C'\fI\fR
.IX Subsection "registry_destination"
.PP
.Vb 1
\&  my $registry_destination = $engine\->registry_destination;
.Ve
.PP
Returns the name of the registry database. In other words, the database in
which Sqitch's own data is stored. It will usually be the same as \f(CW\*(C`target()\*(C'\fR,
but some engines, such as SQLite, may use a
separate database. Used internally to name the target when the registration
tables are created.
.PP
\fI\f(CI\*(C`variables\*(C'\fI\fR
.IX Subsection "variables"
.PP
\fI\f(CI\*(C`set_variables\*(C'\fI\fR
.IX Subsection "set_variables"
.PP
\fI\f(CI\*(C`clear_variables\*(C'\fI\fR
.IX Subsection "clear_variables"
.PP
.Vb 3
\&  my %vars = $engine\->variables;
\&  $engine\->set_variables(foo => \*(Aqbar\*(Aq, baz => \*(Aqhi there\*(Aq);
\&  $engine\->clear_variables;
.Ve
.PP
Get, set, and clear engine variables. Variables are defined as key/value pairs
to be passed to the engine client in calls to \f(CW\*(C`deploy\*(C'\fR and \f(CW\*(C`revert\*(C'\fR, if the
client supports variables. For example, the
PostgreSQL and
Vertica engines pass all the variables to
their \f(CW\*(C`psql\*(C'\fR and \f(CW\*(C`vsql\*(C'\fR clients via the \f(CW\*(C`\-\-set\*(C'\fR option, while the
MySQL engine engine sets them via the \f(CW\*(C`SET\*(C'\fR
command and the Oracle engine engine sets them
via the SQL*Plus \f(CW\*(C`DEFINE\*(C'\fR command.
.PP
\fI\f(CI\*(C`deploy\*(C'\fI\fR
.IX Subsection "deploy"
.PP
.Vb 3
\&  $engine\->deploy($to_change);
\&  $engine\->deploy($to_change, $mode);
\&  $engine\->deploy($to_change, $mode);
.Ve
.PP
Deploys changes to the target database, starting with the current deployment
state, and continuing to \f(CW$to_change\fR. \f(CW$to_change\fR must be a valid change
specification as passable to the \f(CW\*(C`index_of()\*(C'\fR method of App::Sqitch::Plan.
If \f(CW$to_change\fR is not specified, all changes will be applied.
.PP
The second argument specifies the reversion mode in the case of deployment
failure. The allowed values are:
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
In the event of failure, revert all deployed changes, back to the point at
which deployment started. This is the default.
.ie n .IP """tag""" 4
.el .IP "\f(CWtag\fR" 4
.IX Item "tag"
In the event of failure, revert all deployed changes to the last
successfully-applied tag. If no tags were applied during this deployment, all
changes will be reverted to the pint at which deployment began.
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
In the event of failure, no changes will be reverted. This is on the
assumption that a change failure is total, and the change may be applied again.
.PP
Note that, in the event of failure, if a reversion fails, the target database
\&\fBmay be left in a corrupted state\fR. Write your revert scripts carefully!
.PP
\fI\f(CI\*(C`revert\*(C'\fI\fR
.IX Subsection "revert"
.PP
.Vb 3
\&  $engine\->revert;
\&  $engine\->revert($tag);
\&  $engine\->revert($tag);
.Ve
.PP
Reverts the App::Sqitch::Plan::Tag from the database, including all of its
associated changes.
.PP
\fI\f(CI\*(C`verify\*(C'\fI\fR
.IX Subsection "verify"
.PP
.Vb 4
\&  $engine\->verify;
\&  $engine\->verify( $from );
\&  $engine\->verify( $from, $to );
\&  $engine\->verify( undef, $to );
.Ve
.PP
Verifies the database against the plan. Pass in change identifiers, as
described in sqitchchanges, to limit the changes to verify. For each
change, information will be emitted if:
.IP "\(bu" 4
It does not appear in the plan.
.IP "\(bu" 4
It has not been deployed to the database.
.IP "\(bu" 4
It has been deployed out-of-order relative to the plan.
.IP "\(bu" 4
Its verify script fails.
.PP
Changes without verify scripts will emit a warning, but not constitute a
failure. If there are any failures, an exception will be thrown once all
verifications have completed.
.PP
\fI\f(CI\*(C`check\*(C'\fI\fR
.IX Subsection "check"
.PP
.Vb 4
\&  $engine\->check;
\&  $engine\->check( $from );
\&  $engine\->check( $from, $to );
\&  $engine\->check( undef, $to );
.Ve
.PP
Compares the state of the working directory and the database by comparing the
\&\s-1SHA1\s0 hashes of the deploy scripts. Fails and reports divergence for all
changes with non-matching hashes, indicating that the project deploy scripts
differ from the scripts that were used to deploy to the database.
.PP
Pass in change identifiers, as described in sqitchchanges, to limit the
changes to check. For each change, information will be emitted if the \s-1SHA1\s0
digest of the current deploy script does not match its \s-1SHA1\s0 digest at the
time of deployment.
.PP
\fI\f(CI\*(C`check_deploy_dependencies\*(C'\fI\fR
.IX Subsection "check_deploy_dependencies"
.PP
.Vb 2
\&  $engine\->check_deploy_dependencies;
\&  $engine\->check_deploy_dependencies($to_index);
.Ve
.PP
Validates that all dependencies will be met for all changes to be deployed,
starting with the currently-deployed change up to the specified index, or to
the last change in the plan if no index is passed. If any of the changes to be
deployed would conflict with previously-deployed changes or are missing any
required changes, an exception will be thrown. Used internally by \f(CW\*(C`deploy()\*(C'\fR
to ensure that dependencies will be satisfied before deploying any changes.
.PP
\fI\f(CI\*(C`check_revert_dependencies\*(C'\fI\fR
.IX Subsection "check_revert_dependencies"
.PP
.Vb 1
\&  $engine\->check_revert_dependencies(@changes);
.Ve
.PP
Validates that the list of changes to be reverted, which should be passed in
the order in which they will be reverted, are not depended upon by other
changes. If any are depended upon by other changes, an exception will be
thrown listing the changes that cannot be reverted and what changes depend on
them. Used internally by \f(CW\*(C`revert()\*(C'\fR to ensure no dependencies will be
violated before revering any changes.
.PP
\fI\f(CI\*(C`deploy_change\*(C'\fI\fR
.IX Subsection "deploy_change"
.PP
.Vb 2
\&  $engine\->deploy_change($change);
\&  $engine\->deploy_change($change);
.Ve
.PP
Used internally by \f(CW\*(C`deploy()\*(C'\fR to deploy an individual change.
.PP
\fI\f(CI\*(C`revert_change\*(C'\fI\fR
.IX Subsection "revert_change"
.PP
.Vb 2
\&  $engine\->revert_change($change);
\&  $engine\->revert_change($change);
.Ve
.PP
Used internally by \f(CW\*(C`revert()\*(C'\fR (and, by \f(CW\*(C`deploy()\*(C'\fR when a deploy fails) to
revert an individual change.
.PP
\fI\f(CI\*(C`verify_change\*(C'\fI\fR
.IX Subsection "verify_change"
.PP
.Vb 1
\&  $engine\->verify_change($change);
.Ve
.PP
Used internally by \f(CW\*(C`deploy_change()\*(C'\fR to verify a just-deployed change if
\&\f(CW\*(C`with_verify\*(C'\fR is true.
.PP
\fI\f(CI\*(C`is_deployed\*(C'\fI\fR
.IX Subsection "is_deployed"
.PP
.Vb 2
\&  say "Tag deployed"  if $engine\->is_deployed($tag);
\&  say "Change deployed" if $engine\->is_deployed($change);
.Ve
.PP
Convenience method that dispatches to \f(CW\*(C`is_deployed_tag()\*(C'\fR or
\&\f(CW\*(C`is_deployed_change()\*(C'\fR as appropriate to its argument.
.PP
\fI\f(CI\*(C`earliest_change\*(C'\fI\fR
.IX Subsection "earliest_change"
.PP
.Vb 2
\&  my $change = $engine\->earliest_change;
\&  my $change = $engine\->earliest_change($offset);
.Ve
.PP
Returns the App::Sqitch::Plan::Change object representing the earliest
applied change. With the optional \f(CW$offset\fR argument, the returned change
will be the offset number of changes following the earliest change.
.PP
\fI\f(CI\*(C`latest_change\*(C'\fI\fR
.IX Subsection "latest_change"
.PP
.Vb 2
\&  my $change = $engine\->latest_change;
\&  my $change = $engine\->latest_change($offset);
.Ve
.PP
Returns the App::Sqitch::Plan::Change object representing the latest
applied change. With the optional \f(CW$offset\fR argument, the returned change
will be the offset number of changes before the latest change.
.PP
\fI\f(CI\*(C`change_for_key\*(C'\fI\fR
.IX Subsection "change_for_key"
.PP
.Vb 1
\&  my $change = if $engine\->change_for_key($key);
.Ve
.PP
Searches the deployed changes for a change corresponding to the specified key,
which should be in a format as described in sqitchchanges. Throws an
exception if the key matches more than one changes. Returns \f(CW\*(C`undef\*(C'\fR if it
matches no changes.
.PP
\fI\f(CI\*(C`change_id_for_key\*(C'\fI\fR
.IX Subsection "change_id_for_key"
.PP
.Vb 1
\&  my $change_id = if $engine\->change_id_for_key($key);
.Ve
.PP
Searches the deployed changes for a change corresponding to the specified key,
which should be in a format as described in sqitchchanges, and returns the
change's \s-1ID.\s0 Throws an exception if the key matches more than one change.
Returns \f(CW\*(C`undef\*(C'\fR if it matches no changes.
.PP
\fI\f(CI\*(C`change_for_key\*(C'\fI\fR
.IX Subsection "change_for_key"
.PP
.Vb 1
\&  my $change = if $engine\->change_for_key($key);
.Ve
.PP
Searches the list of deployed changes for a change corresponding to the
specified key, which should be in a format as described in sqitchchanges.
Throws an exception if the key matches multiple changes.
.PP
\fI\f(CI\*(C`change_id_for_depend\*(C'\fI\fR
.IX Subsection "change_id_for_depend"
.PP
.Vb 1
\&  say \*(AqDependency satisfied\*(Aq if $engine\->change_id_for_depend($depend);
.Ve
.PP
Returns the change \s-1ID\s0 for a dependency, if the
dependency resolves to a change currently deployed to the database. Returns
\&\f(CW\*(C`undef\*(C'\fR if the dependency resolves to no currently-deployed change.
.PP
\fI\f(CI\*(C`find_change\*(C'\fI\fR
.IX Subsection "find_change"
.PP
.Vb 1
\&  my $change = $engine\->find_change(%params);
.Ve
.PP
Finds and returns a deployed change, or \f(CW\*(C`undef\*(C'\fR if the change has not been
deployed. The supported parameters are:
.ie n .IP """change_id""" 4
.el .IP "\f(CWchange_id\fR" 4
.IX Item "change_id"
The change \s-1ID.\s0
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
A change name.
.ie n .IP """tag""" 4
.el .IP "\f(CWtag\fR" 4
.IX Item "tag"
A tag name.
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
A project name. Defaults to the current project.
.ie n .IP """offset""" 4
.el .IP "\f(CWoffset\fR" 4
.IX Item "offset"
The number of changes offset from the change found by the other parameters
should actually be returned. May be positive or negative.
.PP
The order of precedence for the search is:
.IP "1." 4
Search by change \s-1ID,\s0 if passed.
.IP "2." 4
Search by change name as of tag, if both are passed.
.IP "3." 4
Search by change name or tag.
.PP
The offset, if passed, will be applied relative to whatever change is found by
the above algorithm.
.PP
\fI\f(CI\*(C`find_change_id\*(C'\fI\fR
.IX Subsection "find_change_id"
.PP
.Vb 1
\&  my $change_id = $engine\->find_change_id(%params);
.Ve
.PP
Like \f(CW\*(C`find_change()\*(C'\fR, taking the same parameters, but returning an \s-1ID\s0 instead
of a change.
.PP
\fI\f(CI\*(C`run_deploy\*(C'\fI\fR
.IX Subsection "run_deploy"
.PP
.Vb 1
\&  $engine\->run_deploy($deploy_file);
.Ve
.PP
Runs a deploy script. The implementation is just an alias for \f(CW\*(C`run_file()\*(C'\fR;
subclasses may override as appropriate.
.PP
\fI\f(CI\*(C`run_revert\*(C'\fI\fR
.IX Subsection "run_revert"
.PP
.Vb 1
\&  $engine\->run_revert($revert_file);
.Ve
.PP
Runs a revert script. The implementation is just an alias for \f(CW\*(C`run_file()\*(C'\fR;
subclasses may override as appropriate.
.PP
\fI\f(CI\*(C`run_verify\*(C'\fI\fR
.IX Subsection "run_verify"
.PP
.Vb 1
\&  $engine\->run_verify($verify_file);
.Ve
.PP
Runs a verify script. The implementation is just an alias for \f(CW\*(C`run_file()\*(C'\fR;
subclasses may override as appropriate.
.PP
\fI\f(CI\*(C`run_upgrade\*(C'\fI\fR
.IX Subsection "run_upgrade"
.PP
.Vb 1
\&  $engine\->run_upgrade($upgrade_file);
.Ve
.PP
Runs an upgrade script. The implementation is just an alias for \f(CW\*(C`run_file()\*(C'\fR;
subclasses may override as appropriate.
.PP
\fI\f(CI\*(C`needs_upgrade\*(C'\fI\fR
.IX Subsection "needs_upgrade"
.PP
.Vb 3
\&  if ($engine\->needs_upgrade) {
\&      $engine\->upgrade_registry;
\&  }
.Ve
.PP
Determines if the target's registry needs upgrading and returns true if it
does.
.PP
\fI\f(CI\*(C`upgrade_registry\*(C'\fI\fR
.IX Subsection "upgrade_registry"
.PP
.Vb 1
\&  $engine\->upgrade_registry;
.Ve
.PP
Upgrades the target's registry, if it needs upgrading. Used by the
\&\f(CW\*(C`upgrade\*(C'\fR command.
.SS "Abstract Instance Methods"
.IX Subsection "Abstract Instance Methods"
These methods must be overridden in subclasses.
.PP
\fI\f(CI\*(C`begin_work\*(C'\fI\fR
.IX Subsection "begin_work"
.PP
.Vb 1
\&  $engine\->begin_work($change);
.Ve
.PP
This method is called just before a change is deployed or reverted. It should
create a lock to prevent any other processes from making changes to the
database, to be freed in \f(CW\*(C`finish_work\*(C'\fR or \f(CW\*(C`rollback_work\*(C'\fR.
.PP
\fI\f(CI\*(C`finish_work\*(C'\fI\fR
.IX Subsection "finish_work"
.PP
.Vb 1
\&  $engine\->finish_work($change);
.Ve
.PP
This method is called after a change has been deployed or reverted. It should
unlock the lock created by \f(CW\*(C`begin_work\*(C'\fR.
.PP
\fI\f(CI\*(C`rollback_work\*(C'\fI\fR
.IX Subsection "rollback_work"
.PP
.Vb 1
\&  $engine\->rollback_work($change);
.Ve
.PP
This method is called after a change has been deployed or reverted and the
logging of that change has failed. It should rollback changes started by
\&\f(CW\*(C`begin_work\*(C'\fR.
.PP
\fI\f(CI\*(C`initialized\*(C'\fI\fR
.IX Subsection "initialized"
.PP
.Vb 1
\&  $engine\->initialize unless $engine\->initialized;
.Ve
.PP
Returns true if the database has been initialized for Sqitch, and false if it
has not.
.PP
\fI\f(CI\*(C`initialize\*(C'\fI\fR
.IX Subsection "initialize"
.PP
.Vb 1
\&  $engine\->initialize;
.Ve
.PP
Initializes the target database for Sqitch by installing the Sqitch registry
schema and/or tables. Should be overridden by subclasses. This implementation
throws an exception
.PP
\fI\f(CI\*(C`register_project\*(C'\fI\fR
.IX Subsection "register_project"
.PP
.Vb 1
\&  $engine\->register_project;
.Ve
.PP
Registers the current project plan in the registry database. The
implementation should insert the project name and \s-1URI\s0 if they have not already
been inserted. If a project already exists with the same name but different
\&\s-1URI,\s0 or a different name and the same \s-1URI,\s0 an exception should be thrown.
.PP
\fI\f(CI\*(C`is_deployed_tag\*(C'\fI\fR
.IX Subsection "is_deployed_tag"
.PP
.Vb 1
\&  say \*(AqTag deployed\*(Aq if $engine\->is_deployed_tag($tag);
.Ve
.PP
Should return true if the tag has been applied to
the database, and false if it has not.
.PP
\fI\f(CI\*(C`is_deployed_change\*(C'\fI\fR
.IX Subsection "is_deployed_change"
.PP
.Vb 1
\&  say \*(AqChange deployed\*(Aq if $engine\->is_deployed_change($change);
.Ve
.PP
Should return true if the change has been
deployed to the database, and false if it has not.
.PP
\fI\f(CI\*(C`are_deployed_changes\*(C'\fI\fR
.IX Subsection "are_deployed_changes"
.PP
.Vb 1
\&  say "Change $_ is deployed" for $engine\->are_deployed_change(@changes);
.Ve
.PP
Should return the IDs of any of the changes passed in that are currently
deployed. Used by \f(CW\*(C`deploy\*(C'\fR to ensure that no changes already deployed are
re-deployed.
.PP
\fI\f(CI\*(C`change_id_for\*(C'\fI\fR
.IX Subsection "change_id_for"
.PP
.Vb 5
\&  say $engine\->change_id_for(
\&      change  => $change_name,
\&      tag     => $tag_name,
\&      project => $project,
\&  );
.Ve
.PP
Searches the database for the change with the specified name, tag, project,
or \s-1ID.\s0 Returns \f(CW\*(C`undef\*(C'\fR if it matches no changes. If it matches more than one
change, it returns the earliest deployed change if the \f(CW\*(C`first\*(C'\fR parameter is
passed; otherwise it throws an exception The parameters are as follows:
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
The name of a change. Required unless \f(CW\*(C`tag\*(C'\fR or \f(CW\*(C`change_id\*(C'\fR is passed.
.ie n .IP """change_id""" 4
.el .IP "\f(CWchange_id\fR" 4
.IX Item "change_id"
The \s-1ID\s0 of a change. Required unless \f(CW\*(C`tag\*(C'\fR or \f(CW\*(C`change\*(C'\fR is passed. Useful
to determine whether an \s-1ID\s0 in a plan has been deployed to the database.
.ie n .IP """tag""" 4
.el .IP "\f(CWtag\fR" 4
.IX Item "tag"
The name of a tag. Required unless \f(CW\*(C`change\*(C'\fR is passed.
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
The name of the project to search. Defaults to the current project.
.ie n .IP """first""" 4
.el .IP "\f(CWfirst\fR" 4
.IX Item "first"
Return the earliest deployed change \s-1ID\s0 if the search matches more than one
change. If false or not passed and more than one change is found, an
exception will be thrown.
.PP
If both \f(CW\*(C`change\*(C'\fR and \f(CW\*(C`tag\*(C'\fR are passed, \f(CW\*(C`find_change_id\*(C'\fR will search for the
last instance of the named change deployed \fIbefore\fR the tag.
.PP
\fI\f(CI\*(C`changes_requiring_change\*(C'\fI\fR
.IX Subsection "changes_requiring_change"
.PP
.Vb 1
\&  my @requiring = $engine\->changes_requiring_change($change);
.Ve
.PP
Returns a list of hash references representing currently deployed changes that
require the passed change. When this method returns one or more hash
references, the change should not be reverted. Each hash reference should
contain the following keys:
.ie n .IP """change_id""" 4
.el .IP "\f(CWchange_id\fR" 4
.IX Item "change_id"
The requiring change \s-1ID.\s0
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
The requiring change name.
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
The project the requiring change is from.
.ie n .IP """asof_tag""" 4
.el .IP "\f(CWasof_tag\fR" 4
.IX Item "asof_tag"
Name of the first tag to be applied after the requiring change was deployed,
if any.
.PP
\fI\f(CI\*(C`log_deploy_change\*(C'\fI\fR
.IX Subsection "log_deploy_change"
.PP
.Vb 1
\&  $engine\->log_deploy_change($change);
.Ve
.PP
Should write the records to the registry necessary to indicate that the change
has been deployed.
.PP
\fI\f(CI\*(C`log_fail_change\*(C'\fI\fR
.IX Subsection "log_fail_change"
.PP
.Vb 1
\&  $engine\->log_fail_change($change);
.Ve
.PP
Should write to the database event history a record reflecting that deployment
of the change failed.
.PP
\fI\f(CI\*(C`log_revert_change\*(C'\fI\fR
.IX Subsection "log_revert_change"
.PP
.Vb 1
\&  $engine\->log_revert_change($change);
.Ve
.PP
Should write to and/or remove from the registry the records necessary to
indicate that the change has been reverted.
.PP
\fI\f(CI\*(C`log_new_tags\*(C'\fI\fR
.IX Subsection "log_new_tags"
.PP
.Vb 1
\&  $engine\->log_new_tags($change);
.Ve
.PP
Given a change, if it has any tags that are not currently logged in the
database, they should be logged. This is assuming, of course, that the change
itself has previously been logged.
.PP
\fI\f(CI\*(C`earliest_change_id\*(C'\fI\fR
.IX Subsection "earliest_change_id"
.PP
.Vb 1
\&  my $change_id = $engine\->earliest_change_id($offset);
.Ve
.PP
Returns the \s-1ID\s0 of the earliest applied change from the current project. With
the optional \f(CW$offset\fR argument, the \s-1ID\s0 of the change the offset number of
changes following the earliest change will be returned.
.PP
\fI\f(CI\*(C`latest_change_id\*(C'\fI\fR
.IX Subsection "latest_change_id"
.PP
.Vb 2
\&  my $change_id = $engine\->latest_change_id;
\&  my $change_id = $engine\->latest_change_id($offset);
.Ve
.PP
Returns the \s-1ID\s0 of the latest applied change from the current project.
With the optional \f(CW$offset\fR argument, the \s-1ID\s0 of the change the offset
number of changes before the latest change will be returned.
.PP
\fI\f(CI\*(C`deployed_changes\*(C'\fI\fR
.IX Subsection "deployed_changes"
.PP
.Vb 1
\&  my @change_hashes = $engine\->deployed_changes;
.Ve
.PP
Returns a list of hash references, each representing a change from the current
project in the order in which they were deployed. The keys in each hash
reference must be:
.ie n .IP """id""" 4
.el .IP "\f(CWid\fR" 4
.IX Item "id"
The change \s-1ID.\s0
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The change name.
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
The name of the project with which the change is associated.
.ie n .IP """note""" 4
.el .IP "\f(CWnote\fR" 4
.IX Item "note"
The note attached to the change.
.ie n .IP """planner_name""" 4
.el .IP "\f(CWplanner_name\fR" 4
.IX Item "planner_name"
The name of the user who planned the change.
.ie n .IP """planner_email""" 4
.el .IP "\f(CWplanner_email\fR" 4
.IX Item "planner_email"
The email address of the user who planned the change.
.ie n .IP """timestamp""" 4
.el .IP "\f(CWtimestamp\fR" 4
.IX Item "timestamp"
An App::Sqitch::DateTime object representing the time the change was planned.
.ie n .IP """tags""" 4
.el .IP "\f(CWtags\fR" 4
.IX Item "tags"
An array reference of the tag names associated with the change.
.PP
\fI\f(CI\*(C`deployed_changes_since\*(C'\fI\fR
.IX Subsection "deployed_changes_since"
.PP
.Vb 1
\&  my @change_hashes = $engine\->deployed_changes_since($change);
.Ve
.PP
Returns a list of hash references, each representing a change from the current
project deployed after the specified change. The keys in the hash references
should be the same as for those returned by \f(CW\*(C`deployed_changes()\*(C'\fR.
.PP
\fI\f(CI\*(C`name_for_change_id\*(C'\fI\fR
.IX Subsection "name_for_change_id"
.PP
.Vb 1
\&  my $change_name = $engine\->name_for_change_id($change_id);
.Ve
.PP
Returns the tag-qualified name of the change identified by the \s-1ID.\s0 If a tag
was applied to a change after that change, the name will be returned with the
tag qualification, e.g., \f(CW\*(C`app_user@beta\*(C'\fR. Otherwise, it will include the
symbolic tag \f(CW@HEAD\fR. e.g., \f(CW\*(C`widgets@HEAD\*(C'\fR. This value should be suitable
for uniquely identifying the change, and passing to the \f(CW\*(C`get\*(C'\fR or \f(CW\*(C`index_of\*(C'\fR
methods of App::Sqitch::Plan.
.PP
\fI\f(CI\*(C`registered_projects\*(C'\fI\fR
.IX Subsection "registered_projects"
.PP
.Vb 1
\&  my @projects = $engine\->registered_projects;
.Ve
.PP
Returns a list of the names of Sqitch projects registered in the database.
.PP
\fI\f(CI\*(C`current_state\*(C'\fI\fR
.IX Subsection "current_state"
.PP
.Vb 2
\&  my $state = $engine\->current_state;
\&  my $state = $engine\->current_state($project);
.Ve
.PP
Returns a hash reference representing the current project deployment state of
the database, or \f(CW\*(C`undef\*(C'\fR if the database has no changes deployed. If a
project name is passed, the state will be returned for that project. Otherwise,
the state will be returned for the local project.
.PP
The hash contains information about the last successfully deployed change, as
well as any associated tags. The keys to the hash should include:
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
The name of the project for which the state is reported.
.ie n .IP """change_id""" 4
.el .IP "\f(CWchange_id\fR" 4
.IX Item "change_id"
The current change \s-1ID.\s0
.ie n .IP """script_hash""" 4
.el .IP "\f(CWscript_hash\fR" 4
.IX Item "script_hash"
The deploy script \s-1SHA\-1\s0 hash.
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
The current change name.
.ie n .IP """note""" 4
.el .IP "\f(CWnote\fR" 4
.IX Item "note"
A brief description of the change.
.ie n .IP """tags""" 4
.el .IP "\f(CWtags\fR" 4
.IX Item "tags"
An array reference of the names of associated tags.
.ie n .IP """committed_at""" 4
.el .IP "\f(CWcommitted_at\fR" 4
.IX Item "committed_at"
An App::Sqitch::DateTime object representing the date and time at which the
change was deployed.
.ie n .IP """committer_name""" 4
.el .IP "\f(CWcommitter_name\fR" 4
.IX Item "committer_name"
Name of the user who deployed the change.
.ie n .IP """committer_email""" 4
.el .IP "\f(CWcommitter_email\fR" 4
.IX Item "committer_email"
Email address of the user who deployed the change.
.ie n .IP """planned_at""" 4
.el .IP "\f(CWplanned_at\fR" 4
.IX Item "planned_at"
An App::Sqitch::DateTime object representing the date and time at which the
change was added to the plan.
.ie n .IP """planner_name""" 4
.el .IP "\f(CWplanner_name\fR" 4
.IX Item "planner_name"
Name of the user who added the change to the plan.
.ie n .IP """planner_email""" 4
.el .IP "\f(CWplanner_email\fR" 4
.IX Item "planner_email"
Email address of the user who added the change to the plan.
.PP
\fI\f(CI\*(C`current_changes\*(C'\fI\fR
.IX Subsection "current_changes"
.PP
.Vb 5
\&  my $iter = $engine\->current_changes;
\&  my $iter = $engine\->current_changes($project);
\&  while (my $change = $iter\->()) {
\&      say \*(Aq* \*(Aq, $change\->{change};
\&  }
.Ve
.PP
Returns a code reference that iterates over a list of the currently deployed
changes in reverse chronological order. If a project name is not passed, the
current project will be assumed. Each change is represented by a hash
reference containing the following keys:
.ie n .IP """change_id""" 4
.el .IP "\f(CWchange_id\fR" 4
.IX Item "change_id"
The current change \s-1ID.\s0
.ie n .IP """script_hash""" 4
.el .IP "\f(CWscript_hash\fR" 4
.IX Item "script_hash"
The deploy script \s-1SHA\-1\s0 hash.
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
The current change name.
.ie n .IP """committed_at""" 4
.el .IP "\f(CWcommitted_at\fR" 4
.IX Item "committed_at"
An App::Sqitch::DateTime object representing the date and time at which the
change was deployed.
.ie n .IP """committer_name""" 4
.el .IP "\f(CWcommitter_name\fR" 4
.IX Item "committer_name"
Name of the user who deployed the change.
.ie n .IP """committer_email""" 4
.el .IP "\f(CWcommitter_email\fR" 4
.IX Item "committer_email"
Email address of the user who deployed the change.
.ie n .IP """planned_at""" 4
.el .IP "\f(CWplanned_at\fR" 4
.IX Item "planned_at"
An App::Sqitch::DateTime object representing the date and time at which the
change was added to the plan.
.ie n .IP """planner_name""" 4
.el .IP "\f(CWplanner_name\fR" 4
.IX Item "planner_name"
Name of the user who added the change to the plan.
.ie n .IP """planner_email""" 4
.el .IP "\f(CWplanner_email\fR" 4
.IX Item "planner_email"
Email address of the user who added the change to the plan.
.PP
\fI\f(CI\*(C`current_tags\*(C'\fI\fR
.IX Subsection "current_tags"
.PP
.Vb 5
\&  my $iter = $engine\->current_tags;
\&  my $iter = $engine\->current_tags($project);
\&  while (my $tag = $iter\->()) {
\&      say \*(Aq* \*(Aq, $tag\->{tag};
\&  }
.Ve
.PP
Returns a code reference that iterates over a list of the currently deployed
tags in reverse chronological order. If a project name is not passed, the
current project will be assumed. Each tag is represented by a hash reference
containing the following keys:
.ie n .IP """tag_id""" 4
.el .IP "\f(CWtag_id\fR" 4
.IX Item "tag_id"
The tag \s-1ID.\s0
.ie n .IP """tag""" 4
.el .IP "\f(CWtag\fR" 4
.IX Item "tag"
The name of the tag.
.ie n .IP """committed_at""" 4
.el .IP "\f(CWcommitted_at\fR" 4
.IX Item "committed_at"
An App::Sqitch::DateTime object representing the date and time at which the
tag was applied.
.ie n .IP """committer_name""" 4
.el .IP "\f(CWcommitter_name\fR" 4
.IX Item "committer_name"
Name of the user who applied the tag.
.ie n .IP """committer_email""" 4
.el .IP "\f(CWcommitter_email\fR" 4
.IX Item "committer_email"
Email address of the user who applied the tag.
.ie n .IP """planned_at""" 4
.el .IP "\f(CWplanned_at\fR" 4
.IX Item "planned_at"
An App::Sqitch::DateTime object representing the date and time at which the
tag was added to the plan.
.ie n .IP """planner_name""" 4
.el .IP "\f(CWplanner_name\fR" 4
.IX Item "planner_name"
Name of the user who added the tag to the plan.
.ie n .IP """planner_email""" 4
.el .IP "\f(CWplanner_email\fR" 4
.IX Item "planner_email"
Email address of the user who added the tag to the plan.
.PP
\fI\f(CI\*(C`search_events\*(C'\fI\fR
.IX Subsection "search_events"
.PP
.Vb 4
\&  my $iter = $engine\->search_events( %params );
\&  while (my $change = $iter\->()) {
\&      say \*(Aq* $change\->{event}ed $change\->{change}";
\&  }
.Ve
.PP
Searches the deployment event log and returns an iterator code reference with
the results. If no parameters are provided, a list of all events will be
returned from the iterator reverse chronological order. The supported parameters
are:
.ie n .IP """event""" 4
.el .IP "\f(CWevent\fR" 4
.IX Item "event"
An array of the type of event to search for. Allowed values are \*(L"deploy\*(R",
\&\*(L"revert\*(R", and \*(L"fail\*(R".
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
Limit the events to those with project names matching the specified regular
expression.
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
Limit the events to those with changes matching the specified regular
expression.
.ie n .IP """committer""" 4
.el .IP "\f(CWcommitter\fR" 4
.IX Item "committer"
Limit the events to those logged for the actions of the committers with names
matching the specified regular expression.
.ie n .IP """planner""" 4
.el .IP "\f(CWplanner\fR" 4
.IX Item "planner"
Limit the events to those with changes who's planner's name matches the
specified regular expression.
.ie n .IP """limit""" 4
.el .IP "\f(CWlimit\fR" 4
.IX Item "limit"
Limit the number of events to the specified number.
.ie n .IP """offset""" 4
.el .IP "\f(CWoffset\fR" 4
.IX Item "offset"
Skip the specified number of events.
.ie n .IP """direction""" 4
.el .IP "\f(CWdirection\fR" 4
.IX Item "direction"
Return the results in the specified order, which must be a value matching
\&\f(CW\*(C`/^(:?a|de)sc/i\*(C'\fR for \*(L"ascending\*(R" or \*(L"descending\*(R".
.PP
Each event is represented by a hash reference containing the following keys:
.ie n .IP """event""" 4
.el .IP "\f(CWevent\fR" 4
.IX Item "event"
The type of event, which is one of:
.RS 4
.ie n .IP """deploy""" 4
.el .IP "\f(CWdeploy\fR" 4
.IX Item "deploy"
.PD 0
.ie n .IP """revert""" 4
.el .IP "\f(CWrevert\fR" 4
.IX Item "revert"
.ie n .IP """fail""" 4
.el .IP "\f(CWfail\fR" 4
.IX Item "fail"
.RE
.RS 4
.RE
.ie n .IP """project""" 4
.el .IP "\f(CWproject\fR" 4
.IX Item "project"
.PD
The name of the project with which the change is associated.
.ie n .IP """change_id""" 4
.el .IP "\f(CWchange_id\fR" 4
.IX Item "change_id"
The change \s-1ID.\s0
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
The name of the change.
.ie n .IP """note""" 4
.el .IP "\f(CWnote\fR" 4
.IX Item "note"
A brief description of the change.
.ie n .IP """tags""" 4
.el .IP "\f(CWtags\fR" 4
.IX Item "tags"
An array reference of the names of associated tags.
.ie n .IP """requires""" 4
.el .IP "\f(CWrequires\fR" 4
.IX Item "requires"
An array reference of the names of any changes required by the change.
.ie n .IP """conflicts""" 4
.el .IP "\f(CWconflicts\fR" 4
.IX Item "conflicts"
An array reference of the names of any changes that conflict with the change.
.ie n .IP """committed_at""" 4
.el .IP "\f(CWcommitted_at\fR" 4
.IX Item "committed_at"
An App::Sqitch::DateTime object representing the date and time at which the
event was logged.
.ie n .IP """committer_name""" 4
.el .IP "\f(CWcommitter_name\fR" 4
.IX Item "committer_name"
Name of the user who deployed the change.
.ie n .IP """committer_email""" 4
.el .IP "\f(CWcommitter_email\fR" 4
.IX Item "committer_email"
Email address of the user who deployed the change.
.ie n .IP """planned_at""" 4
.el .IP "\f(CWplanned_at\fR" 4
.IX Item "planned_at"
An App::Sqitch::DateTime object representing the date and time at which the
change was added to the plan.
.ie n .IP """planner_name""" 4
.el .IP "\f(CWplanner_name\fR" 4
.IX Item "planner_name"
Name of the user who added the change to the plan.
.ie n .IP """planner_email""" 4
.el .IP "\f(CWplanner_email\fR" 4
.IX Item "planner_email"
Email address of the user who added the change to the plan.
.PP
\fI\f(CI\*(C`run_file\*(C'\fI\fR
.IX Subsection "run_file"
.PP
.Vb 1
\&  $engine\->run_file($file);
.Ve
.PP
Should execute the commands in the specified file. This will generally be an
\&\s-1SQL\s0 file to run through the engine's native client.
.PP
\fI\f(CI\*(C`run_handle\*(C'\fI\fR
.IX Subsection "run_handle"
.PP
.Vb 1
\&  $engine\->run_handle($file_handle);
.Ve
.PP
Should execute the commands in the specified file handle. The file handle's
contents should be piped to the engine's native client.
.PP
\fI\f(CI\*(C`load_change\*(C'\fI\fR
.IX Subsection "load_change"
.PP
.Vb 1
\&  my $change = $engine\->load_change($change_id);
.Ve
.PP
Given a deployed change \s-1ID,\s0 loads an returns a hash reference representing the
change in the database. The keys should be the same as those in the hash
references returned by \f(CW\*(C`deployed_changes()\*(C'\fR. Returns \f(CW\*(C`undef\*(C'\fR if the change
has not been deployed.
.PP
\fI\f(CI\*(C`change_offset_from_id\*(C'\fI\fR
.IX Subsection "change_offset_from_id"
.PP
.Vb 1
\&  my $change = $engine\->change_offset_from_id( $change_id, $offset );
.Ve
.PP
Given a change \s-1ID\s0 and an offset, returns a hash reference of the data for a
deployed change (with the same keys as defined for \f(CW\*(C`deployed_changes()\*(C'\fR) in
the current project that was deployed \f(CW$offset\fR steps before the change
identified by \f(CW$change_id\fR. If \f(CW$offset\fR is \f(CW0\fR or \f(CW\*(C`undef\*(C'\fR, the change
represented by \f(CW$change_id\fR should be returned (just like \f(CW\*(C`load_change()\*(C'\fR).
Otherwise, the change returned should be \f(CW$offset\fR steps from that change \s-1ID,\s0
where \f(CW$offset\fR may be positive (later step) or negative (earlier step).
Returns \f(CW\*(C`undef\*(C'\fR if the change was not found or if the offset is more than the
number of changes before or after the change, as appropriate.
.PP
\fI\f(CI\*(C`change_id_offset_from_id\*(C'\fI\fR
.IX Subsection "change_id_offset_from_id"
.PP
.Vb 1
\&  my $id = $engine\->change_id_offset_from_id( $change_id, $offset );
.Ve
.PP
Like \f(CW\*(C`change_offset_from_id()\*(C'\fR but returns the change \s-1ID\s0 rather than the
change object.
.PP
\fI\f(CI\*(C`planned_deployed_common_ancestor_id\*(C'\fI\fR
.IX Subsection "planned_deployed_common_ancestor_id"
.PP
.Vb 1
\&  my $change_id = $engine\->planned_deployed_common_ancestor_id;
.Ve
.PP
Compares the \s-1SHA1\s0 hashes of the deploy scripts to their values at the time of
deployment to the database and returns the latest change \s-1ID\s0 prior to any
changes for which the values diverge. Used for the \f(CW\*(C`\-\-modified\*(C'\fR option to
the \f(CW\*(C`revert\*(C'\fR and \f(CW\*(C`rebase\*(C'\fR commands.
.PP
\fI\f(CI\*(C`registry_version\*(C'\fI\fR
.IX Subsection "registry_version"
.PP
Should return the current version of the target's registry.
.SH "See Also"
.IX Header "See Also"
.IP "sqitch" 4
.IX Item "sqitch"
The Sqitch command-line client.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
