.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sqitch-configuration 3"
.TH sqitch-configuration 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
sqitch-configuration \- Hierarchical engine and target configuration
.SH "Description"
.IX Header "Description"
The specification of database targets is core to Sqitch database change
management. A target consists of a
database connection \s-1URI\s0 <https://github.com/libwww-perl/uri-db>, a plan file,
change script directories, a registry schema or database name, and the path to
a database engine command-line client. Sqitch determines the values for these
attributes via a hierarchical evaluation of the runtime configuration,
examining and selecting from these values:
.IP "1." 4
Command-line options
.IP "2." 4
Target-specific configuration
.IP "3." 4
Engine-specific configuration
.IP "4." 4
Core configuration
.IP "5." 4
A reasonable default
.PP
This document explains how this evaluation works, and how to use the
\&\f(CW\*(C`init\*(C'\fR, \f(CW\*(C`config\*(C'\fR,
\&\f(CW\*(C`engine\*(C'\fR, and \f(CW\*(C`target\*(C'\fR commands to
configure these values for various deployment scenarios.
.SH "Project Initialization"
.IX Header "Project Initialization"
Typically, the first thing you do with Sqitch is use the
\&\f(CW\*(C`init\*(C'\fR command to start a new project. Now, the most important
thing Sqitch needs to know is what database engine you'll be managing, so it's
best to use \f(CW\*(C`\-\-engine\*(C'\fR to configure the engine right up front to start off on
the right foot. Here, we start a project called \*(L"widgets\*(R" to manage PostgreSQL
databases:
.PP
.Vb 6
\&  > sqitch init widgets \-\-engine pg
\&  Created sqitch.conf
\&  Created sqitch.plan
\&  Created deploy/
\&  Created revert/
\&  Created verify/
.Ve
.PP
This creates a very simple configuration file with most of the settings
commented out, like so:
.PP
.Vb 9
\&  > cat sqitch.conf
\&  [core]
\&    engine = pg
\&    # plan_file = sqitch.plan
\&    # top_dir = .
\&  # [engine "pg"]
\&    # target = db:pg:
\&    # registry = sqitch
\&    # client = psql
.Ve
.PP
The \f(CW\*(C`[core]\*(C'\fR section contains default configurations, the most important of
which is the default engine, \f(CW\*(C`pg\*(C'\fR. Of course, it's the \fIonly\fR engine this
project supports, and the values of the other configuration variables are
reasonable for a single-engine project. If your Sqitch project never needs to
manage more than one database engine, this might be all you need: the current
directory is the top directory of the project, and it's here you'll find the
plan file as well as the deploy, revert, and verify script directories. Once
you start using the \f(CW\*(C`add\*(C'\fR command to add changes, and the
\&\f(CW\*(C`deploy\*(C'\fR command to deploy changes to a database, these
variables will be used extensively.
.PP
The \f(CW\*(C`[engine "pg"]\*(C'\fR section houses the variables specific to the engine. The
\&\f(CW\*(C`target\*(C'\fR defines the default database \s-1URI\s0 <https://github.com/libwww-perl/uri-db>
for connecting to a PostgreSQL database. As you can see there isn't much here,
but if you were to distribute this project, it's likely that your users would
specify a target \s-1URI\s0 when deploying to their own databases. The \f(CW\*(C`registry\*(C'\fR
determines where Sqitch will store its own metadata when managing a database;
generally the default, \*(L"sqitch\*(R", is fine.
.PP
More interesting, perhaps, is the \f(CW\*(C`client\*(C'\fR setting, which defaults to the
appropriate engine-specific client name appropriate for your \s-1OS.\s0 In this
example, sqitch will assume it can find \fIpsql\fR in your path.
.SH "Global Configuration"
.IX Header "Global Configuration"
But sometimes that's not the case. Let's say that the \f(CW\*(C`psql\*(C'\fR client on your
system is not in the path, but instead in \fI/usr/local/pgsql/bin/psql\fR. You
could set its location right here in the project configuration file, but that
won't do if you end up distributing the project to other users who might have
their client somewhere else. For that use case, the default path-specific
value is probably best.
.PP
A better idea is to tell Sqitch where to find \fIpsql\fR for \fIall\fR of your
projects. Use the \f(CW\*(C`config\*(C'\fR command's \f(CW\*(C`\-\-user\*(C'\fR option to set
that configuration for yourself:
.PP
.Vb 1
\&  > sqitch config \-\-user engine.pg.client /usr/local/pgsql/bin/psql
.Ve
.PP
This won't change the project configuration file at all, but add the value to
\&\fI~/.sqitch/sqitch.conf\fR, which is your personal cross-project Sqitch
configuration. In other words, it sets the PostgreSQL client for all Sqitch
projects you manage on this host. In fact, it can be a good idea to configure
clients not in the path first thing whenever you start working on a new host:
.PP
.Vb 5
\&  > sqitch config \-\-user user.name \*(AqMarge N. OXVera\*(Aq
\&  > sqitch config \-\-user user.email \*(Aqmarge@example.com\*(Aq
\&  > sqitch config \-\-user engine.pg.client /usr/local/pgsql/bin/psql
\&  > sqitch config \-\-user engine.mysql.client /usr/local/mysql/bin/mysql
\&  > sqitch config \-\-user engine.sqlite.client /sbin/sqlite3
.Ve
.PP
If you'd like to make the configuration global to all accounts on your host,
use the \f(CW\*(C`\-\-system\*(C'\fR option, instead:
.PP
.Vb 3
\&  > sudo sqitch config \-\-system engine.pg.client /usr/local/pgsql/bin/psql
\&  > sudo sqitch config \-\-system engine.mysql.client /usr/local/mysql/bin/mysql
\&  > sudo sqitch config \-\-system engine.sqlite.client /sbin/sqlite3
.Ve
.PP
That will put the values into the global Sqitch configuration file, which is
in \f(CW\*(C`\`sqitch \-\-etc\-path\`/sqitch.conf\*(C'\fR.
.SH "Engine Configuration"
.IX Header "Engine Configuration"
So you've got the widgets project well developed, and now you've been asked to
port it to SQLite. Fundamentally, that means porting all of your deploy,
revert, and verify scripts. The simplest way to organize files for this
configuration is with top-level directories for each engine. First, let's move
the existing PostgreSQL stuff to a subdirectory.
.PP
.Vb 4
\&  > mkdir pg
\&  > mv deploy revert verify sqitch.plan pg
\&  > ls  pg  
\&  deploy/ revert/ sqitch.plan verify/
.Ve
.PP
Now we need to tell Sqitch where things are. To create an engine-specific
configuration, use the \f(CW\*(C`engine\*(C'\fR command's \f(CW\*(C`add\*(C'\fR action:
.PP
.Vb 1
\&  sqitch engine add pg \-\-top\-dir pg
.Ve
.PP
The \f(CW\*(C`add\*(C'\fR action adds the \f(CW\*(C`pg\*(C'\fR engine to the configuration, setting the top
directory to our newly-created \f(CW\*(C`pg\*(C'\fR directory. The configuration looks like
this (with comments removed for clarity):
.PP
.Vb 5
\&  [core]
\&    engine = pg
\&  [engine "pg"]
\&    target = db:pg:
\&    top_dir = pg
.Ve
.PP
Curious about all the other settings for the engine? Let \f(CW\*(C`sqitch engine show\*(C'\fR
show you:
.PP
.Vb 10
\&  > sqitch engine show pg
\&  * pg
\&      Target:        db:pg:
\&      Registry:      sqitch
\&      Client:        psql
\&      Top Directory: pg
\&      Plan File:     pg/sqitch.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      Reworked Script Directories:
\&        Reworked:    pg
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      No Variables
.Ve
.PP
The \f(CW\*(C`show\*(C'\fR action nicely presents the result of the fully-evaluated
configuration, even though only the top directory and client have been set.
Nice, right?
.PP
Now, to add the SQLite support. There are two basic ways to go about it. We'll
start with the more obvious one.
.SS "Separate Plans"
.IX Subsection "Separate Plans"
The first approach is to create an entirely independent SQLite project with
its own plan and scripts. This is \fIalmost\fR like starting from scratch: just
create a new directory and add the Sqitch engine using it for its top
directory: add initialize it as a new Sqitch project:
.PP
.Vb 6
\&  > sqitch engine add sqlite \-\-top\-dir sqlite
\&  Created sqlite/
\&  Created sqlite/sqitch.plan
\&  Created sqlite/deploy/
\&  Created sqlite/revert/
\&  Created sqlite/verify/
.Ve
.PP
Note the creation of a new \fIsqlite/sqitch.conf\fR file. It will have copied the
project name and \s-1URI\s0 from the existing plan file. The SQLite configuration is
now added to the configuration file:
.PP
.Vb 10
\&  > sqitch engine show sqlite
\&  * sqlite
\&      Target:        db:sqlite:
\&      Registry:      sqitch
\&      Client:        sqlite3
\&      Top Directory: sqlite
\&      Plan File:     sqlite/sqitch.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      sqlite/deploy
\&        Revert:      sqlite/revert
\&        Verify:      sqlite/verify
\&      Reworked Script Directories:
\&        Reworked:    sqlite
\&        Deploy:      sqlite/deploy
\&        Revert:      sqlite/revert
\&        Verify:      sqlite/verify
\&      No Variables
.Ve
.PP
Good, everything's in the right place. Start adding changes to the SQLite plan
by passing the engine name to the \f(CW\*(C`add\*(C'\fR command:
.PP
.Vb 5
\&  > sqitch add users sqlite \-m \*(AqCreates users table.\*(Aq
\&  Created sqlite/deploy/users.sql
\&  Created sqlite/revert/users.sql
\&  Created sqlite/verify/users.sql
\&  Added "users" to sqlite/sqitch.plan
.Ve
.PP
Pass \f(CW\*(C`pg\*(C'\fR when adding PostgreSQL changes, or omit it, in which case Sqitch
will fall back on the default engine, defined by the \f(CW\*(C`core.engine\*(C'\fR variable
set when we created the PostgreSQL project. Want to add a change with the same
name to both engines? Simply pass them both, or use the \f(CW\*(C`\-\-all\*(C'\fR option:
.PP
.Vb 11
\&  > sqitch add users \-\-all \-m \*(AqCreates users table.\*(Aq
\&  Created pg/deploy/users.sql
\&  Created pg/revert/users.sql
\&  Created pg/test/users.sql
\&  Created pg/verify/users.sql
\&  Added "users" to pg/sqitch.plan
\&  Created sqlite/deploy/users.sql
\&  Created sqlite/revert/users.sql
\&  Created sqlite/test/users.sql
\&  Created sqlite/verify/users.sql
\&  Added "users" to sqlite/sqitch.plan
.Ve
.SS "Shared Plan"
.IX Subsection "Shared Plan"
The other approach is to have both the PostgreSQL and the SQLite projects
share the same plan. In that case, we should move the plan file out of the
PostgreSQL directory:
.PP
.Vb 10
\&  > mv pg/sqitch.plan .
\&  > sqitch engine alter pg \-\-plan\-file sqitch.plan
\&  > sqitch engine show pg
\&  * pg
\&      Target:        db:pg:
\&      Registry:      sqitch
\&      Client:        psql
\&      Top Directory: pg
\&      Plan File:     sqitch.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      Reworked Script Directories:
\&        Reworked:    pg
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      No Variables
.Ve
.PP
Good, it's now using \fI./sqitch.plan\fR. Now let's start the SQLite project.
Since we're going to use the same plan, we'll need to port all the scripts
from PostgreSQL. Let's just copy them, and then configure the SQLite engine to
use the shared plan file:
.PP
.Vb 10
\&  > cp \-rf pg sqlite
\&  > sqitch engine add sqlite \-\-plan\-file sqitch.plan \-\-top\-dir sqlite
\&  > sqitch engine show sqlite
\&  * sqlite
\&      Target:           db:sqlite:
\&      Registry:         sqitch
\&      Client:           sqlite3
\&      Top Directory:    sqlite
\&      Plan File:        sqitch.plan
\&      Extension:        sql
\&      Script Directories:
\&        Deploy:      sqlite/deploy
\&        Revert:      sqlite/revert
\&        Verify:      sqlite/verify
\&      Reworked Script Directories:
\&        Reworked:    sqlite
\&        Deploy:      sqlite/deploy
\&        Revert:      sqlite/revert
\&        Verify:      sqlite/verify
\&      No Variables
.Ve
.PP
Looks good! Now port all the scripts in the \fIsqlite\fR directory from
PostgreSQL to SQLite and you're ready to go.
.PP
Later, when you want to add a new change to both projects, just pass the
\&\f(CW\*(C`\-\-all\*(C'\fR option to the \f(CW\*(C`add\*(C'\fR command:
.PP
.Vb 8
\&  > sqitch add users \-\-all \-n \*(AqCreates users table.\*(Aq
\&  Created pg/deploy/users.sql
\&  Created pg/revert/users.sql
\&  Created pg/verify/users.sql
\&  Created sqlite/deploy/users.sql
\&  Created sqlite/revert/users.sql
\&  Created sqlite/verify/users.sql
\&  Added "users" to sqitch.plan
.Ve
.PP
This option also works for the \f(CW\*(C`tag\*(C'\fR, \f(CW\*(C`rework\*(C'\fR, and \f(CW\*(C`bundle\*(C'\fR commands. If
you know you always want to act on all plans, set the \f(CW\*(C`all\*(C'\fR configuration
variable for each command:
.PP
.Vb 4
\&  sqitch config \-\-bool add.all 1
\&  sqitch config \-\-bool tag.all 1
\&  sqitch config \-\-bool rework.all 1
\&  sqitch config \-\-bool bundle.all 1
.Ve
.SS "Database Interactions"
.IX Subsection "Database Interactions"
With either of these two approaches, you can manage database interactions by
passing an engine name or a database \s-1URI\s0 <https://github.com/libwww-perl/uri-db>
to the database commands. For example, to deploy to a PostgreSQL database to
the default PostgreSQL database:
.PP
.Vb 1
\&  sqitch deploy pg
.Ve
.PP
You usually won't want to use the default database in production, though.
Here's how to deploy to a PostgreSQL database named \*(L"widgets\*(R" on host
\&\f(CW\*(C`db.example.com\*(C'\fR:
.PP
.Vb 1
\&  sqitch deploy db:pg://db.example.com/widgets
.Ve
.PP
Sqitch is smart enough to pick out the proper engine from the \s-1URI.\s0 If you pass
a \f(CW\*(C`db:pg:\*(C'\fR \s-1URI,\s0 rest assured that Sqitch won't try to deploy the SQLite
changes. Use a \f(CW\*(C`db:sqlite:\*(C'\fR \s-1URI\s0 to interact with an SQLite database:
.PP
.Vb 1
\&  sqitch log db:sqlite:/var/db/widgets.db
.Ve
.PP
The commands that take engine and target \s-1URI\s0 arguments include:
.IP "\(bu" 4
\&\f(CW\*(C`status\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`log\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`deploy\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`revert\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`rebase\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`checkout\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`verify\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`verify\*(C'\fR
.SH "Target Configuration"
.IX Header "Target Configuration"
Great, now we can easily manage changes for multiple database engines. But
what about multiple databases for the same engine? For example, you might want
to deploy your database to two hosts in a primary/standby configuration. To
make things as simple as possible for your \s-1IT\s0 organization, set up named
targets for those servers:
.PP
.Vb 2
\&  > sqitch target add prod\-primary db:pg://sqitch@db1.example.com/widgets
\&  > sqitch target add prod\-standby db:pg://sqitch@db2.example.com/widgets
.Ve
.PP
Targets inherit configuration from engines, based on the engine specified in
the \s-1URI.\s0 Thus the configuration all comes together:
.PP
.Vb 10
\&  > sqitch target show prod\-primary prod\-standby
\&  * prod\-primary
\&      URI:           db:pg://sqitch@db1.example.com/widgets
\&      Registry:      sqitch
\&      Client:        psql
\&      Top Directory: pg
\&      Plan File:     sqitch.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      Reworked Script Directories:
\&        Reworked:    pg
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      No Variables
\&  * prod\-standby
\&      URI:           db:pg://sqitch@db2.example.com/widgets
\&      Registry:      sqitch
\&      Client:        psql
\&      Top Directory: pg
\&      Plan File:     sqitch.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      Reworked Script Directories:
\&        Reworked:    pg
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      No Variables
.Ve
.PP
Note the use of the shared plan and the \fIpg\fR directory for scripts. We can
add a target for our SQLite database, too. Maybe it's used for development?
.PP
.Vb 10
\&  > sqitch target add dev\-sqlite db:sqlite:/var/db/widgets_dev.db
\&  > sqitch target show dev\-sqlite
\&  * dev\-sqlite
\&      URI:           db:sqlite:/var/db/widgets_dev.db
\&      Registry:      sqitch
\&      Client:        sqlite3
\&      Top Directory: sqlite
\&      Plan File:     sqitch.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      sqlite/deploy
\&        Revert:      sqlite/revert
\&        Verify:      sqlite/verify
\&      Reworked Script Directories:
\&        Reworked:    sqlite
\&        Deploy:      sqlite/deploy
\&        Revert:      sqlite/revert
\&        Verify:      sqlite/verify
\&      No Variables
.Ve
.PP
Now deploying any of these databases is as simple as specifying the target
name when executing the \f(CW\*(C`deploy\*(C'\fR command (assuming the
\&\f(CW\*(C`sqitch\*(C'\fR user is configured to authenticate to PostgreSQL without prompting
for a password):
.PP
.Vb 2
\&  > sqitch deploy prod\-primary
\&  > sqitch deploy prod\-standby
.Ve
.PP
Want them all? Just query the targets and pass each in turn:
.PP
.Vb 3
\&  for target in \`sqitch target | grep prod\-\`; do
\&      sqitch deploy $target
\&  done
.Ve
.PP
The commands that accept a target name are identical to those that take
an engine name or target \s-1URI,\s0 as described in \*(L"Database Interactions\*(R".
.PP
\fIDifferent Target, Different Plan\fR
.IX Subsection "Different Target, Different Plan"
.PP
What about a project that manages different \*(-- but related \*(-- schemas on the
same engine? For example, say you have two plans for PostgreSQL, one for a
canonical data store, and one for a read-only copy that will have a subset of
data replicated to it. Maybe your billing database just needs an up-to-date
copy of the \f(CW\*(C`customers\*(C'\fR and \f(CW\*(C`users\*(C'\fR tables.
.PP
Targets can help us here, too. Just create the new plan file. It might use
some of the same change scripts as the canonical plan, or its own scripts, or
some of each. Just be sure all of its scripts are in the same top directory.
Then add targets for the specific servers and plans:
.PP
.Vb 10
\&  > sqitch target add prod\-primary db:pg://db1.example.com/widgets
\&  > sqitch target add prod\-billing db:pg://cpa.example.com/billing \-\-plan\-file target.plan
\&  > sqitch target show prod\-billing
\&  * prod\-billing
\&      URI:           db:pg://cpa.example.com/billing
\&      Registry:      sqitch
\&      Client:        psql
\&      Top Directory: pg
\&      Plan File:     target.plan
\&      Extension:     sql
\&      Script Directories:
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      Reworked Script Directories:
\&        Reworked:    pg
\&        Deploy:      pg/deploy
\&        Revert:      pg/revert
\&        Verify:      pg/verify
\&      No Variables
.Ve
.PP
Now, any management of the \f(CW\*(C`prod\-billing\*(C'\fR target will use the \fItarget.plan\fR
plan file. Want to add changes to that plan? specify the plan file. Here's
an example that re-uses the existing change scripts:
.PP
.Vb 6
\&  > sqitch add users target.plan \-n \*(AqCreates users table.\*(Aq
\&  Skipped pg/deploy/users.sql: already exists
\&  Skipped pg/revert/users.sql: already exists
\&  Skipped pg/test/users.sql: already exists
\&  Skipped pg/verify/users.sql: already exists
\&  Added "users" to target.plan
.Ve
.SH "Overworked"
.IX Header "Overworked"
Say you've been working on your project for some time, and now you have a slew
of changes you've reworked. (You really only do that with
procedures and views, right? Because it's silly to use for \f(CW\*(C`ALTER\*(C'\fR
statements; just add new changes in those cases.) As a result, your deploy,
revert, and verify directories are full of files representing older versions
of the changes, all containing the \f(CW\*(C`@\*(C'\fR symbol, and they're starting to get in
the way (in general you'll never modify them). Here's an example adapted from
a real project:
.PP
.Vb 10
\&  > find pg \-name \*(Aq*@*\*(Aq
\&  pg/deploy/extensions@v2.9.0.sql
\&  pg/deploy/jobs/func_enabler@v2.6.1.sql
\&  pg/deploy/stem/func_check_all_widgets@v2.11.0.sql
\&  pg/deploy/stem/func_check_all_widgets@v2.12.2.sql
\&  pg/deploy/stem/func_check_all_widgets@v2.12.3.sql
\&  pg/deploy/crank/func_update_jobs@v2.12.0.sql
\&  pg/deploy/crank/func_update_jobs@v2.8.0.sql
\&  pg/deploy/utility/func_get_sleepercell@v2.9.0.sql
\&  pg/deploy/utility/func_update_connection@v2.10.0.sql
\&  pg/deploy/utility/func_update_connection@v2.10.1.sql
\&  pg/deploy/utility/func_update_connection@v2.11.0.sql
\&  pg/revert/extensions@v2.9.0.sql
\&  pg/revert/jobs/func_enabler@v2.6.1.sql
\&  pg/revert/stem/func_check_all_widgets@v2.11.0.sql
\&  pg/revert/stem/func_check_all_widgets@v2.12.2.sql
\&  pg/revert/stem/func_check_all_widgets@v2.12.3.sql
\&  pg/revert/crank/func_update_jobs@v2.12.0.sql
\&  pg/revert/crank/func_update_jobs@v2.8.0.sql
\&  pg/revert/utility/func_get_sleepercell@v2.9.0.sql
\&  pg/revert/utility/func_update_connection@v2.10.0.sql
\&  pg/revert/utility/func_update_connection@v2.10.1.sql
\&  pg/revert/utility/func_update_connection@v2.11.0.sql
\&  pg/verify/extensions@v2.9.0.sql
\&  pg/verify/jobs/func_enabler@v2.6.1.sql
\&  pg/verify/stem/func_check_all_widgets@v2.11.0.sql
\&  pg/verify/stem/func_check_all_widgets@v2.12.2.sql
\&  pg/verify/stem/func_check_all_widgets@v2.12.3.sql
\&  pg/verify/crank/func_update_jobs@v2.12.0.sql
\&  pg/verify/crank/func_update_jobs@v2.8.0.sql
\&  pg/verify/utility/func_get_sleepercell@v2.9.0.sql
\&  pg/verify/utility/func_update_connection@v2.10.0.sql
\&  pg/verify/utility/func_update_connection@v2.10.1.sql
\&  pg/verify/utility/func_update_connection@v2.11.0.sql
.Ve
.PP
Ugh. Wouldn't it be nice to move them out of the way? Of course it would! So
let's do that. We want all of the PostgreSQL engine's reworked scripts all to
go into to a new directory named \*(L"reworked\*(R", so tell Sqitch where to find
them:
.PP
.Vb 4
\&  > sqitch engine alter pg \-\-dir reworked=pg/reworked
\&  Created pg/reworked/deploy/
\&  Created pg/reworked/revert/
\&  Created pg/reworked/verify/
.Ve
.PP
Great, it created the new directories. Note that if you wanted the directories
to have different names or locations, you can use the \f(CW\*(C`reworked_deploy\*(C'\fR,
\&\f(CW\*(C`reworked_revert\*(C'\fR, and \f(CW\*(C`reworked_verify\*(C'\fR options.
.PP
Now all we have to do is move the files:
.PP
.Vb 7
\&  cd pg
\&  for file in \`find . \-name \*(Aq*@*\*(Aq\`
\&  do
\&      mkdir \-p reworked/\`dirname $file\`
\&      mv $file reworked/\`dirname $file\`
\&  done
\&  cd ..
.Ve
.PP
Now all the reworked deploy files are in \fIpg/reworked/deploy\fR, the reworked
revert files are in \fIpg/reworked/revert\fR, and the reworked verify files are
in \fIpg/reworked/verify\fR. And you're good to go! From here on in Sqitch always
knows to find the reworked scripts when doing a deploy,
revert, or bundle. And meanwhile, they're
tucked out of the way, less likely to break your brain or your \s-1IDE.\s0
.SH "Other Options"
.IX Header "Other Options"
You can see by the output of the \f(CW\*(C`init\*(C'\fR,
\&\f(CW\*(C`engine\*(C'\fR, and \f(CW\*(C`target\*(C'\fR commands that there
are quite a few other properties that can be set on a per-engine or per-target
database. To determine the value of each, Sqitch looks at a combination of
command-line options and configuration variables. Here's a complete list,
including specification of their values and how to set them.
.ie n .IP """target""" 4
.el .IP "\f(CWtarget\fR" 4
.IX Item "target"
The target database. May be a database \s-1URI\s0 <https://github.com/libwww-perl/uri-db> or
a named target managed by the \f(CW\*(C`target\*(C'\fR commands. On each run,
its value will be determined by examining each of the following in turn:
.RS 4
.IP "Command target argument or option" 4
.IX Item "Command target argument or option"
.Vb 2
\&  sqitch deploy $target
\&  sqitch revert \-\-target $target
.Ve
.ie n .IP "$SQITCH_TARGET environment variable" 4
.el .IP "\f(CW$SQITCH_TARGET\fR environment variable" 4
.IX Item "$SQITCH_TARGET environment variable"
.Vb 2
\&  env SQITCH_TARGET=$target sqitch deploy
\&  env SQITCH_TARGET=$target sqitch revert
.Ve
.ie n .IP """engine.$engine.target""" 4
.el .IP "\f(CWengine.$engine.target\fR" 4
.IX Item "engine.$engine.target"
.Vb 3
\&  sqitch init $project \-\-engine $engine \-\-target $target
\&  sqitch engine add $engine \-\-target $target
\&  sqitch engine alter $engine \-\-target target
.Ve
.ie n .IP """core.target""" 4
.el .IP "\f(CWcore.target\fR" 4
.IX Item "core.target"
.Vb 1
\&  sqitch config core.target $target
.Ve
.RE
.RS 4
.RE
.ie n .IP """uri""" 4
.el .IP "\f(CWuri\fR" 4
.IX Item "uri"
The database \s-1URI\s0 <https://github.com/libwww-perl/uri-db> to which to connect. May
only be specified as a target argument or via a named target:
.RS 4
.IP "Command target argument or option" 4
.IX Item "Command target argument or option"
.Vb 2
\&  sqitch deploy $uri
\&  sqitch revert \-\-target $uri
.Ve
.ie n .IP "$SQITCH_TARGET environment variable" 4
.el .IP "\f(CW$SQITCH_TARGET\fR environment variable" 4
.IX Item "$SQITCH_TARGET environment variable"
.Vb 2
\&  env SQITCH_TARGET=$uri sqitch deploy
\&  env SQITCH_TARGET=$uri sqitch revert
.Ve
.ie n .IP """target.$target.uri""" 4
.el .IP "\f(CWtarget.$target.uri\fR" 4
.IX Item "target.$target.uri"
.Vb 3
\&  sqitch init $project \-\-engine $engine \-\-target $uri
\&  sqitch target add $target \-\-uri $uri
\&  sqitch target alter $target \-\-uri $uri
.Ve
.RE
.RS 4
.RE
.ie n .IP """client""" 4
.el .IP "\f(CWclient\fR" 4
.IX Item "client"
The path to the engine client. The default is engine\- and OS-specific, which
will generally work for clients in the path. If you need a custom client, you
can specify it via the following:
.RS 4
.ie n .IP """\-\-client""" 4
.el .IP "\f(CW\-\-client\fR" 4
.IX Item "--client"
.Vb 1
\&  sqitch deploy \-\-client $client
.Ve
.ie n .IP """target.$target.client""" 4
.el .IP "\f(CWtarget.$target.client\fR" 4
.IX Item "target.$target.client"
.Vb 3
\&  sqitch target add $target \-\-client $client
\&  sqitch target alter $target \-\-client $client
\&  sqitch config \-\-user target.$target.client $client
.Ve
.ie n .IP """engine.$engine.client""" 4
.el .IP "\f(CWengine.$engine.client\fR" 4
.IX Item "engine.$engine.client"
.Vb 4
\&  sqitch init $project \-\-engine $engine \-\-client client
\&  sqitch engine add $engine \-\-client $client
\&  sqitch engine alter $engine \-\-client $client
\&  sqitch config \-\-user engine.$engine.client $client
.Ve
.ie n .IP """core.client""" 4
.el .IP "\f(CWcore.client\fR" 4
.IX Item "core.client"
.Vb 2
\&  sqitch config core.client $client
\&  sqitch config \-\-user core.client $client
.Ve
.RE
.RS 4
.RE
.ie n .IP """registry""" 4
.el .IP "\f(CWregistry\fR" 4
.IX Item "registry"
The name of the Sqitch registry schema or database. The default is \f(CW\*(C`sqitch\*(C'\fR,
which should work for most uses. If you need a custom registry, specify it via
the following:
.RS 4
.ie n .IP """\-\-registry""" 4
.el .IP "\f(CW\-\-registry\fR" 4
.IX Item "--registry"
.Vb 1
\&  sqitch deploy \-\-registry $registry
.Ve
.ie n .IP """target.$target.registry""" 4
.el .IP "\f(CWtarget.$target.registry\fR" 4
.IX Item "target.$target.registry"
.Vb 2
\&  sqitch target add $target \-\-registry $registry
\&  sqitch target alter $target \-\-registry $registry
.Ve
.ie n .IP """engine.$engine.registry""" 4
.el .IP "\f(CWengine.$engine.registry\fR" 4
.IX Item "engine.$engine.registry"
.Vb 3
\&  sqitch init $project \-\-engine $engine \-\-registry $registry
\&  sqitch engine add $engine \-\-registry $registry
\&  sqitch engine alter $engine \-\-registry $registry
.Ve
.ie n .IP """core.registry""" 4
.el .IP "\f(CWcore.registry\fR" 4
.IX Item "core.registry"
.Vb 1
\&  sqitch config core.registry $registry
.Ve
.RE
.RS 4
.RE
.ie n .IP """top_dir""" 4
.el .IP "\f(CWtop_dir\fR" 4
.IX Item "top_dir"
The directory in which project files an subdirectories can be found, including
the plan file and script directories. The default is the current directory. If
you need a custom directory, specify it via the following:
.RS 4
.ie n .IP """target.$target.top_dir""" 4
.el .IP "\f(CWtarget.$target.top_dir\fR" 4
.IX Item "target.$target.top_dir"
.Vb 2
\&  sqitch target add $target \-\-top\-dir $top_dir
\&  sqitch target alter $target \-\-top\-dir $top_dir
.Ve
.ie n .IP """engine.$engine.top_dir""" 4
.el .IP "\f(CWengine.$engine.top_dir\fR" 4
.IX Item "engine.$engine.top_dir"
.Vb 2
\&  sqitch engine add $engine \-\-top\-dir $top_dir
\&  sqitch engine alter $engine \-\-top\-dir $top_dir
.Ve
.ie n .IP """core.top_dir""" 4
.el .IP "\f(CWcore.top_dir\fR" 4
.IX Item "core.top_dir"
.Vb 2
\&  sqitch init $project \-\-top\-dir $top_dir
\&  sqitch config core.top_dir $top_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """plan_file""" 4
.el .IP "\f(CWplan_file\fR" 4
.IX Item "plan_file"
The project deployment plan file, which defaults to \fI\f(CI\*(C`$top_dir/sqitch.plan\*(C'\fI\fR.
If you need a different file, specify it via the following:
.RS 4
.ie n .IP """\-\-plan\-file""" 4
.el .IP "\f(CW\-\-plan\-file\fR" 4
.IX Item "--plan-file"
.PD 0
.ie n .IP """\-f""" 4
.el .IP "\f(CW\-f\fR" 4
.IX Item "-f"
.PD
.Vb 1
\&  sqitch $command \-\-plan\-file $plan_file
.Ve
.ie n .IP """target.$target.plan_file""" 4
.el .IP "\f(CWtarget.$target.plan_file\fR" 4
.IX Item "target.$target.plan_file"
.Vb 2
\&  sqitch target add $target \-\-plan\-file $plan_file
\&  sqitch target alter $target \-\-plan\-file $plan_file
.Ve
.ie n .IP """engine.$engine.plan_file""" 4
.el .IP "\f(CWengine.$engine.plan_file\fR" 4
.IX Item "engine.$engine.plan_file"
.Vb 2
\&  sqitch engine add $engine \-\-plan\-file $plan_file
\&  sqitch engine alter $engine \-\-plan\-file $plan_file
.Ve
.ie n .IP """core.plan_file""" 4
.el .IP "\f(CWcore.plan_file\fR" 4
.IX Item "core.plan_file"
.Vb 2
\&  sqitch init $project \-\-plan\-file $plan_file
\&  sqitch config core.plan_file $plan_file
.Ve
.RE
.RS 4
.RE
.ie n .IP """extension""" 4
.el .IP "\f(CWextension\fR" 4
.IX Item "extension"
The file name extension to append to change names for change script file
names. Defaults to \f(CW\*(C`sql\*(C'\fR. If you need a custom extension, specify it via the
following:
.RS 4
.ie n .IP """target.$target.extension""" 4
.el .IP "\f(CWtarget.$target.extension\fR" 4
.IX Item "target.$target.extension"
.Vb 2
\&  sqitch target add $target \-\-extension $extension
\&  sqitch target alter $target \-\-extension $extension
.Ve
.ie n .IP """engine.$engine.extension""" 4
.el .IP "\f(CWengine.$engine.extension\fR" 4
.IX Item "engine.$engine.extension"
.Vb 2
\&  sqitch engine add $engine \-\-extension $extension
\&  sqitch engine alter $engine \-\-extension $extension
.Ve
.ie n .IP """core.extension""" 4
.el .IP "\f(CWcore.extension\fR" 4
.IX Item "core.extension"
.Vb 2
\&  sqitch init $project \-\-extension $extension
\&  sqitch config core.extension $extension
.Ve
.RE
.RS 4
.RE
.ie n .IP """variables""" 4
.el .IP "\f(CWvariables\fR" 4
.IX Item "variables"
Database client variables. Useful if your database engine
supports variables in scripts, such as PostgreSQL's
\&\f(CW\*(C`psql\*(C'\fR variables <https://www.postgresql.org/docs/current/static/app-psql.html#APP-PSQL-INTERPOLATION>,
Vertica's
\&\f(CW\*(C`vsql\*(C'\fR variables <https://my.vertica.com/docs/7.1.x/HTML/index.htm#Authoring/ConnectingToHPVertica/vsql/Variables.htm>
MySQL's
user variables <https://dev.mysql.com/doc/refman/5.6/en/user-variables.html>,
SQL*Plus's
\&\f(CW\*(C`DEFINE\*(C'\fR variables <https://docs.oracle.com/cd/B19306_01/server.102/b14357/ch12017.htm>,
and Snowflake's
SnowSQL variables <https://docs.snowflake.net/manuals/user-guide/snowsql-use.html#using-variables>.
To set variables, specify them via the following:
.RS 4
.IP "Command variable option" 4
.IX Item "Command variable option"
.Vb 7
\&  sqitch deploy \-\-set $key=$val \-s $key2=$val2
\&  sqitch revert \-\-set $key=$val \-s $key2=$val2
\&  sqitch verify \-\-set $key=$val \-s $key2=$val2
\&  sqitch rework \-\-set $key=$val \-s $key2=$val2
\&  sqitch rework \-\-set\-deploy $key=$val \-\-set\-revert $key=$val
\&  sqitch checkout \-\-set $key=$val \-s $key2=$val2
\&  sqitch checkout \-\-set\-deploy $key=$val \-\-set\-revert $key=$val
.Ve
.ie n .IP """target.$target.variables""" 4
.el .IP "\f(CWtarget.$target.variables\fR" 4
.IX Item "target.$target.variables"
.Vb 2
\&  sqitch target add $target \-\-set $key=$val \-s $key2=$val2
\&  sqitch target alter $target \-\-set $key=$val \-s $key2=$val2
.Ve
.ie n .IP """engine.$engine.variables""" 4
.el .IP "\f(CWengine.$engine.variables\fR" 4
.IX Item "engine.$engine.variables"
.Vb 2
\&  sqitch engine add $engine \-\-set $key=$val \-s $key2=$val2
\&  sqitch engine alter $engine \-\-set $key=$val \-s $key2=$val2
.Ve
.ie n .IP """$command.variables""" 4
.el .IP "\f(CW$command.variables\fR" 4
.IX Item "$command.variables"
.Vb 3
\&  sqitch config deploy.variables.$key $val
\&  sqitch config revert.variables.$key $val
\&  sqitch config verify.variables.$key $val
.Ve
.ie n .IP """core.variables""" 4
.el .IP "\f(CWcore.variables\fR" 4
.IX Item "core.variables"
.Vb 3
\&  sqitch init $project \-\-set $key=$val \-s $key2=$val2
\&  sqitch config core.variables.$key $val
\&  sqitch config core.variables.$key2 $val2
.Ve
.RE
.RS 4
.RE
.ie n .IP """deploy_dir""" 4
.el .IP "\f(CWdeploy_dir\fR" 4
.IX Item "deploy_dir"
The directory in which project deploy scripts can be found. Defaults to
\&\fI\f(CI\*(C`$top_dir/deploy\*(C'\fI\fR. If you need a different directory, specify it via the
following:
.RS 4
.ie n .IP """target.$target.deploy_dir""" 4
.el .IP "\f(CWtarget.$target.deploy_dir\fR" 4
.IX Item "target.$target.deploy_dir"
.Vb 2
\&  sqitch target add $target \-\-dir deploy=$deploy_dir
\&  sqitch target alter $target \-\-dir deploy=$deploy_dir
.Ve
.ie n .IP """engine.$engine.deploy_dir""" 4
.el .IP "\f(CWengine.$engine.deploy_dir\fR" 4
.IX Item "engine.$engine.deploy_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir deploy=$deploy_dir
\&  sqitch engine alter \-\-dir deploy=$deploy_dir
.Ve
.ie n .IP """core.deploy_dir""" 4
.el .IP "\f(CWcore.deploy_dir\fR" 4
.IX Item "core.deploy_dir"
.Vb 2
\&  sqitch init $project \-\-dir deploy=$deploy_dir
\&  sqitch config core.deploy_dir $deploy_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """revert_dir""" 4
.el .IP "\f(CWrevert_dir\fR" 4
.IX Item "revert_dir"
.PD 0
.ie n .IP "\fI\f(CI""$top_dir/deploy""\fI\fR" 4
.el .IP "\fI\f(CI$top_dir/deploy\fI\fR" 4
.IX Item "$top_dir/deploy"
.PD
The directory in which project revert scripts can be found. Defaults to
\&\fI\f(CI\*(C`$top_dir/revert\*(C'\fI\fR. If you need a different directory, specify it via the
following:
.RS 4
.ie n .IP """target.$target.revert_dir""" 4
.el .IP "\f(CWtarget.$target.revert_dir\fR" 4
.IX Item "target.$target.revert_dir"
.Vb 2
\&  sqitch target add $target \-\-dir revert=$revert_dir
\&  sqitch target alter $target \-\-dir revert=$revert_dir
.Ve
.ie n .IP """engine.$engine.revert_dir""" 4
.el .IP "\f(CWengine.$engine.revert_dir\fR" 4
.IX Item "engine.$engine.revert_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir revert=$revert_dir
\&  sqitch engine alter \-\-dir revert=$revert_dir
.Ve
.ie n .IP """core.revert_dir""" 4
.el .IP "\f(CWcore.revert_dir\fR" 4
.IX Item "core.revert_dir"
.Vb 2
\&  sqitch init $project \-\-dir revert=$revert_dir
\&  sqitch config core.revert_dir $revert_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """verify_dir""" 4
.el .IP "\f(CWverify_dir\fR" 4
.IX Item "verify_dir"
The directory in which project verify scripts can be found. Defaults to
\&\fI\f(CI\*(C`$top_dir/verify\*(C'\fI\fR. If you need a different directory, specify it via the
following:
.RS 4
.ie n .IP """target.$target.verify_dir""" 4
.el .IP "\f(CWtarget.$target.verify_dir\fR" 4
.IX Item "target.$target.verify_dir"
.Vb 2
\&  sqitch target add $target \-\-dir verify=$verify_dir
\&  sqitch target alter $target \-\-dir verify=$verify_dir
.Ve
.ie n .IP """engine.$engine.verify_dir""" 4
.el .IP "\f(CWengine.$engine.verify_dir\fR" 4
.IX Item "engine.$engine.verify_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir verify=$verify_dir
\&  sqitch engine alter $engine \-\-dir verify=$verify_dir
.Ve
.ie n .IP """core.verify_dir""" 4
.el .IP "\f(CWcore.verify_dir\fR" 4
.IX Item "core.verify_dir"
.Vb 2
\&  sqitch init $project \-\-dir verify=$verify_dir
\&  sqitch config core.verify_dir $verify_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """reworked_dir""" 4
.el .IP "\f(CWreworked_dir\fR" 4
.IX Item "reworked_dir"
The directory in which subdirectories for reworked scripts can be found.
Defaults to \fI\f(CI$top_dir\fI\fR. If you need a different directory, specify it via
the following:
.RS 4
.ie n .IP """target.$target.reworked_dir""" 4
.el .IP "\f(CWtarget.$target.reworked_dir\fR" 4
.IX Item "target.$target.reworked_dir"
.Vb 2
\&  sqitch target add $target \-\-dir reworked=$reworked_dir
\&  sqitch target alter $target \-\-dir reworked=$reworked_dir
.Ve
.ie n .IP """engine.$engine.reworked_dir""" 4
.el .IP "\f(CWengine.$engine.reworked_dir\fR" 4
.IX Item "engine.$engine.reworked_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir reworked=$reworked_dir
\&  sqitch engine alter $engine \-\-dir reworked=$reworked_dir
.Ve
.ie n .IP """core.reworked_dir""" 4
.el .IP "\f(CWcore.reworked_dir\fR" 4
.IX Item "core.reworked_dir"
.Vb 2
\&  sqitch init $project \-\-dir reworked=$reworked_dir
\&  sqitch config core.reworked_dir $reworked_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """reworked_deploy_dir""" 4
.el .IP "\f(CWreworked_deploy_dir\fR" 4
.IX Item "reworked_deploy_dir"
The directory in which project deploy scripts can be found. Defaults to
\&\fI\f(CI\*(C`reworked_dir/deploy\*(C'\fI\fR. If you need a different directory, specify it via the
following:
.RS 4
.ie n .IP """target.$target.reworked_deploy_dir""" 4
.el .IP "\f(CWtarget.$target.reworked_deploy_dir\fR" 4
.IX Item "target.$target.reworked_deploy_dir"
.Vb 2
\&  sqitch target add $target \-\-dir deploy=$reworked_deploy_dir
\&  sqitch target alter $target \-\-dir deploy=$reworked_deploy_dir
.Ve
.ie n .IP """engine.$engine.reworked_deploy_dir""" 4
.el .IP "\f(CWengine.$engine.reworked_deploy_dir\fR" 4
.IX Item "engine.$engine.reworked_deploy_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir deploy=$reworked_deploy_dir
\&  sqitch engine alter \-\-dir deploy=$reworked_deploy_dir
.Ve
.ie n .IP """core.reworked_deploy_dir""" 4
.el .IP "\f(CWcore.reworked_deploy_dir\fR" 4
.IX Item "core.reworked_deploy_dir"
.Vb 2
\&  sqitch init $project \-\-dir deploy=$reworked_deploy_dir
\&  sqitch config core.reworked_deploy_dir $reworked_deploy_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """reworked_revert_dir""" 4
.el .IP "\f(CWreworked_revert_dir\fR" 4
.IX Item "reworked_revert_dir"
The directory in which project revert scripts can be found. Defaults to
\&\fI\f(CI\*(C`reworked_dir/revert\*(C'\fI\fR. If you need a different directory, specify it via the
following:
.RS 4
.ie n .IP """target.$target.reworked_revert_dir""" 4
.el .IP "\f(CWtarget.$target.reworked_revert_dir\fR" 4
.IX Item "target.$target.reworked_revert_dir"
.Vb 2
\&  sqitch target add $target \-\-dir revert=$reworked_revert_dir
\&  sqitch target alter $target \-\-dir revert=$reworked_revert_dir
.Ve
.ie n .IP """engine.$engine.reworked_revert_dir""" 4
.el .IP "\f(CWengine.$engine.reworked_revert_dir\fR" 4
.IX Item "engine.$engine.reworked_revert_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir revert=$reworked_revert_dir
\&  sqitch engine alter \-\-dir revert=$reworked_revert_dir
.Ve
.ie n .IP """core.reworked_revert_dir""" 4
.el .IP "\f(CWcore.reworked_revert_dir\fR" 4
.IX Item "core.reworked_revert_dir"
.Vb 2
\&  sqitch init $project \-\-dir revert=$reworked_revert_dir
\&  sqitch config core.reworked_revert_dir $reworked_revert_dir
.Ve
.RE
.RS 4
.RE
.ie n .IP """reworked_verify_dir""" 4
.el .IP "\f(CWreworked_verify_dir\fR" 4
.IX Item "reworked_verify_dir"
The directory in which project verify scripts can be found. Defaults to
\&\fI\f(CI\*(C`reworked_dir/verify\*(C'\fI\fR. If you need a different directory, specify it via the
following:
.RS 4
.ie n .IP """target.$target.reworked_verify_dir""" 4
.el .IP "\f(CWtarget.$target.reworked_verify_dir\fR" 4
.IX Item "target.$target.reworked_verify_dir"
.Vb 2
\&  sqitch target add $target \-\-dir verify=$reworked_verify_dir
\&  sqitch target alter $target \-\-dir verify=$reworked_verify_dir
.Ve
.ie n .IP """engine.$engine.reworked_verify_dir""" 4
.el .IP "\f(CWengine.$engine.reworked_verify_dir\fR" 4
.IX Item "engine.$engine.reworked_verify_dir"
.Vb 2
\&  sqitch engine add $engine \-\-dir verify=$reworked_verify_dir
\&  sqitch engine alter $engine \-\-dir verify=$reworked_verify_dir
.Ve
.ie n .IP """core.reworked_verify_dir""" 4
.el .IP "\f(CWcore.reworked_verify_dir\fR" 4
.IX Item "core.reworked_verify_dir"
.Vb 2
\&  sqitch init $project \-\-dir verify=$reworked_verify_dir
\&  sqitch config core.reworked_verify_dir $reworked_verify_dir
.Ve
.RE
.RS 4
.RE
.SH "See Also"
.IX Header "See Also"
.IP "\(bu" 4
sqitch-init
.IP "\(bu" 4
sqitch-target
.IP "\(bu" 4
sqitch-engine
.IP "\(bu" 4
sqitch-config
.SH "Sqitch"
.IX Header "Sqitch"
Part of the sqitch suite.
