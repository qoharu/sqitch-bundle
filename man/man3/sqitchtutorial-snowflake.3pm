.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "sqitchtutorial-snowflake 3"
.TH sqitchtutorial-snowflake 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
sqitchtutorial-snowflake \- A tutorial introduction to Sqitch change management on Snowflake
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 1
\&  sqitch *
.Ve
.SH "Description"
.IX Header "Description"
This tutorial explains how to create a sqitch-enabled Snowflake project, use a
\&\s-1VCS\s0 for deployment planning, and work with other developers to make sure
changes remain in sync and in the proper order.
.PP
We'll start by creating a new project from scratch, a fictional antisocial
networking site called Flipr. All examples use Git <https://git-scm.com/> as
the \s-1VCS\s0 and Snowflake <https://www.snowflake.net/> as the storage engine, but
for the most part you can substitute other VCSes and database engines in the
examples as appropriate.
.PP
If you'd like to manage a PostgreSQL database, see sqitchtutorial.
.PP
If you'd like to manage an SQLite database, see sqitchtutorial-sqlite.
.PP
If you'd like to manage an Oracle database, see sqitchtutorial-oracle.
.PP
If you'd like to manage a MySQL database, see sqitchtutorial-mysql.
.PP
If you'd like to manage a Firebird database, see sqitchtutorial-firebird.
.PP
If you'd like to manage a Vertica database, see sqitchtutorial-vertica.
.PP
If you'd like to manage an Exasol database, see sqitchtutorial-exasol.
.SS "Connection Configuration"
.IX Subsection "Connection Configuration"
Sqitch requires \s-1ODBC\s0 to connect to the Snowflake database. As such, you'll
need to make sure that the
Snowflake \s-1ODBC\s0 driver <https://docs.snowflake.net/manuals/user-guide/odbc.html>
is installed and properly configured. At its simplest, on Unix-like systems,
name the driver \*(L"Snowflake\*(R" by adding this entry to \f(CW\*(C`odbcinst.ini\*(C'\fR (usually
found in \f(CW\*(C`/etc\*(C'\fR, \f(CW\*(C`/usr/etc\*(C'\fR, or \f(CW\*(C`/usr/local/etc\*(C'\fR):
.PP
.Vb 3
\&  [Snowflake]
\&  Description = ODBC for Snowflake
\&  Driver      = /usr/lib64/snowflake/odbc/lib/libSnowflake.so
.Ve
.PP
Note that you'll need to adjust the path depending on the version of the \s-1ODBC\s0
driver, and where you installed it.
.PP
See the Snowflake \s-1ODBC\s0 documentation <https://docs.snowflake.net/manuals/user-guide/odbc.html>
for details on downloading, installing, and configuring \s-1ODBC\s0 for your
platform.
.SH "Starting a New Project"
.IX Header "Starting a New Project"
Usually the first thing to do when starting a new project is to create a
source code repository. So let's do that with Git:
.PP
.Vb 7
\&  > mkdir flipr
\&  > cd flipr
\&  > git init .
\&  Initialized empty Git repository in /flipr/.git/
\&  > touch README.md
\&  > git add .
\&  > git commit \-am \*(AqInitialize project, add README.\*(Aq
.Ve
.PP
If you're a Git user and want to follow along the history, the repository
used in these examples is
on GitHub <https://github.com/sqitchers/sqitch-snowflake-intro>.
.PP
Now that we have a repository, let's get started with Sqitch. Every Sqitch
project must have a name associated with it, and, optionally, a unique \s-1URI.\s0 We
recommend including the \s-1URI,\s0 as it increases the uniqueness of object
identifiers internally, and will prevent the deployment of a different project
with the same name. So let's specify one when we initialize Sqitch:
.PP
.Vb 6
\&  > sqitch init flipr \-\-uri https://github.com/sqitchers/sqitch\-snowflake\-intro/ \-\-engine snowflake
\&  Created sqitch.conf
\&  Created sqitch.plan
\&  Created deploy/
\&  Created revert/
\&  Created verify/
.Ve
.PP
Let's have a look at \fIsqitch.conf\fR:
.PP
.Vb 9
\&  > cat sqitch.conf
\&  [core]
\&    engine = snowflake
\&    # plan_file = sqitch.plan
\&    # top_dir = .
\&  # [engine "snowflake"]
\&    # target = db:snowflake:
\&    # registry = sqitch
\&    # client = snowsql
.Ve
.PP
Good, it picked up on the fact that we're creating changes for the Snowflake
engine, thanks to the \f(CW\*(C`\-\-engine snowflake\*(C'\fR option, and saved it to the
file. Furthermore, it wrote a commented-out \f(CW\*(C`[engine "snowflake"]\*(C'\fR section with
all the available Snowflake engine-specific settings commented out and ready to
be edited as appropriate.
.PP
By default, Sqitch will read \fIsqitch.conf\fR in the current directory for
settings. But it will also read \fI~/.sqitch/sqitch.conf\fR for user-specific
settings. Since Snowflake's \f(CW\*(C`snowsql\*(C'\fR client is not in the path on my system,
let's go ahead an tell it where to find the client on our computer (don't bother
if you're using the
Docker image <https://hub.docker.com/r/sqitch/sqitch/> because it uses the
client inside the container, not on your host machine):
.PP
.Vb 1
\&  > sqitch config \-\-user engine.snowflake.client /Applications/SnowSQL.app/Contents/MacOS/snowsql
.Ve
.PP
And let's also tell it who we are, since this data will be used in all
of our projects:
.PP
.Vb 2
\&  > sqitch config \-\-user user.name \*(AqMarge N. OXVera\*(Aq
\&  > sqitch config \-\-user user.email \*(Aqmarge@example.com\*(Aq
.Ve
.PP
Have a look at \fI~/.sqitch/sqitch.conf\fR and you'll see this:
.PP
.Vb 6
\&  > cat ~/.sqitch/sqitch.conf
\&  [engine "snowflake"]
\&    client = /Applications/SnowSQL.app/Contents/MacOS/snowsql
\&  [user]
\&    name = Marge N. OXVera
\&    email = marge@example.com
.Ve
.PP
Which means that Sqitch should be able to find \f(CW\*(C`snowsql\*(C'\fR for any project, and
that it will always properly identify us when planning and committing changes.
.PP
Back to the repository. Have a look at the plan file, \fIsqitch.plan\fR:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-snowflake\-intro/
.Ve
.PP
Note that it has picked up on the name and \s-1URI\s0 of the app we're building.
Sqitch uses this data to manage cross-project dependencies. The
\&\f(CW\*(C`%syntax\-version\*(C'\fR pragma is always set by Sqitch, so that it always knows how
to parse the plan, even if the format changes in the future.
.PP
Let's commit these changes and start creating the database changes.
.PP
.Vb 6
\&  > git add .
\&  > git commit \-am \*(AqInitialize Sqitch configuration.\*(Aq
\&  [master b731cc3] Initialize Sqitch configuration.
\&   2 files changed, 15 insertions(+)
\&   create mode 100644 sqitch.conf
\&   create mode 100644 sqitch.plan
.Ve
.SH "Our First Change"
.IX Header "Our First Change"
First, our project will need a schema. This creates a nice namespace for all
of the objects that will be part of the flipr app. Run this command:
.PP
.Vb 5
\&  > sqitch add appschema \-n \*(AqAdd schema for all flipr objects.\*(Aq
\&  Created deploy/appschema.sql
\&  Created revert/appschema.sql
\&  Created verify/appschema.sql
\&  Added "appschema" to sqitch.plan
.Ve
.PP
The \f(CW\*(C`add\*(C'\fR command adds a database change to the plan and writes
deploy, revert, and verify scripts that represent the change. Now we edit
these files. The \f(CW\*(C`deploy\*(C'\fR script's job is to create the schema. So we add
this to \fIdeploy/appschema.sql\fR:
.PP
.Vb 1
\&  CREATE SCHEMA flipr;
.Ve
.PP
The \f(CW\*(C`revert\*(C'\fR script's job is to precisely revert the change to the deploy
script, so we add this to \fIrevert/appschema.sql\fR:
.PP
.Vb 1
\&  DROP SCHEMA flipr;
.Ve
.PP
Now we can try deploying this change. We tell Sqitch where to send the change
via a database \s-1URI\s0 <https://github.com/libwww-perl/uri-db/>. Let's say we're
using the account name \f(CW\*(C`example\*(C'\fR, username \f(CW\*(C`movera\*(C'\fR, database \f(CW\*(C`flipr\*(C'\fR, and
warehouse \f(CW\*(C`sqitch\*(C'\fR, and an \s-1ODBC\s0 driver named \f(CW\*(C`Snowflake\*(C'\fR (see
\&\*(L"Connection Configuration\*(R" for details). The \s-1URI\s0 would be structured like
this:
.PP
.Vb 1
\&  db:snowflake://movera@example/flipr?Driver=Snowflake;warehouse=sqitch
.Ve
.PP
Note that Sqitch requires a \f(CW\*(C`warehouse\*(C'\fR parameter in order to record its work
in the registry. The default warehouse is named \f(CW\*(C`sqitch\*(C'\fR, so you can omit it
from the \s-1URI\s0 if that's the warehouse you want Sqitch to use (we'll omit it for
the remainder of this tutorial). Otherwise, specify it in the \s-1URI.\s0 Snowflake
also requires a password, which could also be included in the \s-1URI,\s0 but it's
best to put it in the \f(CW\*(C`connections\*(C'\fR section of the
\&\fI.snowsql/config\fR file <https://docs.snowflake.net/manuals/user-guide/snowsql-start.html#configuring-default-connection-settings>.
See sqitch-authentication for details.
.PP
We just tell Sqitch to use that \s-1URI\s0 to deploy the change:
.PP
.Vb 4
\&  > sqitch deploy \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Adding registry tables to db:snowflake://movera@example/flipr?Driver=Snowflake
\&  Deploying changes to db:snowflake://movera@example/flipr?Driver=Snowflake
\&    + appschema .. ok
.Ve
.PP
First Sqitch created registry tables used to track database changes. The
structure and name of the registry varies between databases (Snowflake uses a
schema to namespace its registry, while SQLite and MySQL use separate
databases). Next, Sqitch deploys changes. We only have one so far; the \f(CW\*(C`+\*(C'\fR
reinforces the idea that the change is being \f(CW\*(C`added\*(C'\fR to the database.
.PP
Note that this process can take quite a bit of time. Sqitch connects to the
database via \s-1ODBC\s0 and retains the connection throughout, but the creation of
the registry and all change scripts run through individual runs of \f(CW\*(C`snowsql\*(C'\fR.
These connections can be quite slow. So if Sqitch seems hung, just wait; it's
most likely waiting on Snowflake.
.PP
With this change deployed, if you connect to the database, you'll be able to
see the schema:
.PP
.Vb 8
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE SCHEMAS LIKE \*(Aqflipr\*(Aq"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name  | kind | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 14:47:22.614 +0000 | FLIPR | NULL | DWHEELER      | NULL        |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.283s
.Ve
.SS "Trust, But Verify"
.IX Subsection "Trust, But Verify"
But that's too much work. Do you really want to do something like that after
every deploy?
.PP
Here's where the \f(CW\*(C`verify\*(C'\fR script comes in. Its job is to test that the deploy
did was it was supposed to. It should do so without regard to any data that
might be in the database, and should throw an error if the deploy was not
successful. In Snowflake, the simplest way to do so for schema is probably to
simply create an object in the schema. Put this \s-1SQL\s0 into
\&\fIverify/appschema.sql\fR:
.PP
.Vb 1
\&  CREATE TEMPORARY TABLE flipr.verify_\|_ (id INT);
.Ve
.PP
In truth, you can use \fIany\fR query that generates an \s-1SQL\s0 error if the schema
doesn't exist. Another handy way to do that is to divide by zero if an object
doesn't exist. For example, to throw an error when the \f(CW\*(C`flipr\*(C'\fR schema does
not exist, you could do something like this:
.PP
.Vb 2
\&  USE WAREHOUSE &warehouse;
\&  SELECT 1/COUNT(*) FROM information_schema.schemata WHERE schema_name = \*(AqFLIPR\*(Aq;
.Ve
.PP
Note the \f(CW\*(C`USE WAREHOUSE\*(C'\fR statement which is provided in the default Snowflake
change script templates. For scripts that execute queries requiring compute
resources (typically \s-1DML\s0 and \f(CW\*(C`SELECT\*(C'\fR statements), we'll need to use a
virtual warehouse <https://docs.snowflake.net/manuals/user-guide/warehouses.html>.
This statement lets the script use the warehouse that Sqitch itself uses for
its registry, which should be a reasonable default, since Sqitch is 
already using this warehouse. You can always change it to a different
warehouse if need be. If not, Sqitch always sets this variable (as well as
\&\f(CW&registry\fR containing the name of the Sqitch registry schema) for all
deploy, revert, and verify script executions.
.PP
Now run the \f(CW\*(C`verify\*(C'\fR script with the \f(CW\*(C`verify\*(C'\fR command:
.PP
.Vb 4
\&  > sqitch verify \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake
\&    * appschema .. ok
\&  Verify successful
.Ve
.PP
Looks good! If you want to make sure that the verify script correctly dies if
the schema doesn't exist, temporarily change the schema name in the script to
something that doesn't exist, something like:
.PP
.Vb 1
\&  CREATE TEMPORARY TABLE nonesuch.verify_\|_ (id INT);
.Ve
.PP
Then \f(CW\*(C`verify\*(C'\fR again:
.PP
.Vb 7
\&  > sqitch verify \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake
\&  * appschema ..
\&  002003 (02000): SQL compilation error:
\&  Schema \*(AqFLIPR.NONESUCH\*(Aq does not exist.
\&  # Verify script "verify/appschema.sql" failed.
\&  not ok
\&
\&  Verify Summary Report
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Changes: 1
\&  Errors:  1
\&  Verify failed
.Ve
.PP
It's even nice enough to tell us what the problem is. Or, for the
divide-by-zero example, change the schema name:
.PP
.Vb 2
\&  USE WAREHOUSE &warehouse;
\&  SELECT 1/COUNT(*) FROM information_schema.schemata WHERE schema_name = \*(AqNONESUCH\*(Aq;
.Ve
.PP
Then the verify will look something like:
.PP
.Vb 6
\&  > sqitch verify \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake
\&  * appschema ..
\&  100051 (22012): Division by zero
\&  # Verify script "verify/appschema.sql" failed.
\&  not ok
\&
\&  Verify Summary Report
\&  \-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-
\&  Changes: 1
\&  Errors:  1
\&  Verify failed
.Ve
.PP
Less useful error output, but enough to alert us that something has gone
wrong.
.PP
Don't forget to change the schema name back before continuing!
.SS "Status, Revert, Log, Repeat"
.IX Subsection "Status, Revert, Log, Repeat"
For purely informational purposes, we can always see how a deployment was
recorded via the \f(CW\*(C`status\*(C'\fR command, which reads the registry
tables from the database:
.PP
.Vb 9
\&  > sqitch status \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  # On database db:snowflake://movera@example/flipr?Driver=Snowflake
\&  # Project:  flipr
\&  # Change:   5a2ac4ae6801bfe392483ee5912b4e3592cdd57a
\&  # Name:     appschema
\&  # Deployed: 2018\-07\-27 10:47:23 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Let's make sure that we can revert the change:
.PP
.Vb 3
\&  > sqitch revert \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Revert all changes from db:snowflake://movera@example/flipr?Driver=Snowflake? [Yes]
\&    \- appschema .. ok
.Ve
.PP
The \f(CW\*(C`revert\*(C'\fR command first prompts to make sure that we
really do want to revert. This is to prevent unnecessary accidents. You can
pass the \f(CW\*(C`\-y\*(C'\fR option to disable the prompt. Also, notice the \f(CW\*(C`\-\*(C'\fR before the
change name in the output, which reinforces that the change is being
\&\fIremoved\fR from the database. And now the schema should be gone:
.PP
.Vb 7
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE SCHEMAS LIKE \*(Aqflipr\*(Aq"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on | name | kind | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  0 Row(s) produced. Time Elapsed: 0.204s
.Ve
.PP
And the status message should reflect as much:
.PP
.Vb 3
\&  > sqitch status \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  # On database db:snowflake://movera@example/flipr?Driver=Snowflake
\&  No changes deployed
.Ve
.PP
Of course, since nothing is deployed, the \f(CW\*(C`verify\*(C'\fR command
has nothing to verify:
.PP
.Vb 3
\&  > sqitch verify \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Verifying db:snowflake://movera@example/flipr?Driver=Snowflake
\&  No changes deployed
.Ve
.PP
However, we still have a record that the change happened, visible via the
\&\f(CW\*(C`log\*(C'\fR command:
.PP
.Vb 6
\&  > sqitch log \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  On database db:snowflake://movera@example/flipr?Driver=Snowflake
\&  Revert 5a2ac4ae6801bfe392483ee5912b4e3592cdd57a
\&  Name:      appschema
\&  Committer: Marge N. OXVera <marge@example.com>
\&  Date:      2018\-07\-27 10:48:48 \-0400
\&
\&      Add schema for all flipr objects.
\&
\&  Deploy 5a2ac4ae6801bfe392483ee5912b4e3592cdd57a
\&  Name:      appschema
\&  Committer: Marge N. OXVera <marge@example.com>
\&  Date:      2018\-07\-27 10:47:24 \-0400
\&
\&      Add schema for all flipr objects.
.Ve
.PP
Note that the actions we took are shown in reverse chronological order, with
the revert first and then the deploy.
.PP
Cool. Now let's commit it.
.PP
.Vb 7
\&  > git add .
\&  > git commit \-m \*(AqAdd flipr schema.\*(Aq
\&  [master 7fd5ace] Add flipr schema.
\&  4 files changed, 10 insertions(+)
\&  create mode 100644 deploy/appschema.sql
\&  create mode 100644 revert/appschema.sql
\&  create mode 100644 verify/appschema.sql
.Ve
.PP
And then deploy again. This time, let's use the \f(CW\*(C`\-\-verify\*(C'\fR option, so that
the \f(CW\*(C`verify\*(C'\fR script is applied when the change is deployed:
.PP
.Vb 3
\&  > sqitch deploy \-\-verify \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  Deploying changes to db:snowflake://movera@example/flipr?Driver=Snowflake
\&    + appschema .. ok
.Ve
.PP
And now the schema should be back:
.PP
.Vb 8
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE SCHEMAS LIKE \*(Aqflipr\*(Aq"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name  | kind | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 14:52:50.116 +0000 | FLIPR | NULL | DWHEELER      | NULL        |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.283s
.Ve
.PP
When we look at the status, the deployment will be there:
.PP
.Vb 9
\&  > sqitch status \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
\&  # On database db:snowflake://movera@example/flipr?Driver=Snowflake
\&  # Project:  flipr
\&  # Change:   5a2ac4ae6801bfe392483ee5912b4e3592cdd57a
\&  # Name:     appschema
\&  # Deployed: 2018\-07\-27 10:52:54 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.SH "On Target"
.IX Header "On Target"
I'm getting a little tired of always having to type
\&\f(CW\*(C`db:snowflake://movera@example/flipr?Driver=Snowflake\*(C'\fR, aren't you?
This database connection \s-1URI\s0 <https://github.com/libwww-perl/uri-db/> tells
Sqitch how to connect to the deployment target, but we don't have to keep
using the \s-1URI.\s0 We can name the target:
.PP
.Vb 1
\&  > sqitch target add flipr_test \*(Aqdb:snowflake://movera@example/flipr?Driver=Snowflake\*(Aq
.Ve
.PP
The \f(CW\*(C`target\*(C'\fR command, inspired by
\&\f(CW\*(C`git\-remote\*(C'\fR <https://git-scm.com/docs/git-remote>, allows management of one
or more named deployment targets. We've just added a target named
\&\f(CW\*(C`flipr_test\*(C'\fR, which means we can use the string \f(CW\*(C`flipr_test\*(C'\fR for the target,
rather than the \s-1URI.\s0 But since we're doing so much testing, we can also tell
Sqitch to deploy to the \f(CW\*(C`flipr_test\*(C'\fR target by default:
.PP
.Vb 1
\&  > sqitch engine add snowflake flipr_test
.Ve
.PP
Now we can omit the target argument altogether, unless we need to deploy to
another database. Which we will, eventually, but at least our examples will be
simpler from here on in, e.g.:
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   5a2ac4ae6801bfe392483ee5912b4e3592cdd57a
\&  # Name:     appschema
\&  # Deployed: 2018\-07\-27 10:52:54 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Yay, that allows things to be a little more concise. Let's also make sure that
changes are verified after deploying them:
.PP
.Vb 2
\&  > sqitch config \-\-bool deploy.verify true
\&  > sqitch config \-\-bool rebase.verify true
.Ve
.PP
We'll see the \f(CW\*(C`rebase\*(C'\fR command a bit later. In the meantime,
let's commit the new configuration and and make some more changes!
.PP
.Vb 3
\&  > git commit \-am \*(AqSet default deployment target and always verify.\*(Aq
\&  [master 3834a8d] Set default deployment target and always verify.
\&   1 files changed, 8 insertions(+), 0 deletions(\-)
.Ve
.SH "Deploy with Dependency"
.IX Header "Deploy with Dependency"
Let's add another change, this time to create a table. Our app will need
users, of course, so we'll create a table for them. First, add the new change:
.PP
.Vb 5
\&  > sqitch add users \-\-requires appschema \-n \*(AqCreates table to track our users.\*(Aq
\&  Created deploy/users.sql
\&  Created revert/users.sql
\&  Created verify/users.sql
\&  Added "users [appschema]" to sqitch.plan
.Ve
.PP
Note that we're requiring the \f(CW\*(C`appschema\*(C'\fR change as a dependency of the new
\&\f(CW\*(C`users\*(C'\fR change. Although that change has already been added to the plan and
therefore should always be applied before the \f(CW\*(C`users\*(C'\fR change, it's a good
idea to be explicit about dependencies.
.PP
Now edit the scripts. When you're done, \fIdeploy/users.sql\fR should look like
this:
.PP
.Vb 2
\&  \-\- Deploy flipr:users to snowflake
\&  \-\- requires: appschema
\&
\&  USE WAREHOUSE &warehouse;
\&  CREATE TABLE flipr.users (
\&      nickname  TEXT         PRIMARY KEY,
\&      password  TEXT         NOT NULL,
\&      fullname  TEXT         NOT NULL,
\&      twitter   TEXT         NOT NULL,
\&      timestamp TIMESTAMP_TZ NOT NULL DEFAULT CURRENT_TIMESTAMP
\&  );
.Ve
.PP
A few things to notice here. On the second line, the dependence on the
\&\f(CW\*(C`appschema\*(C'\fR change has been listed. This doesn't do anything, but the default
\&\f(CW\*(C`deploy\*(C'\fR Snowflake template lists it here for your reference while editing
the file. Useful, right?
.PP
The table itself will be created in the \f(CW\*(C`flipr\*(C'\fR schema. This is why we need
to require the \f(CW\*(C`appschema\*(C'\fR change.
.PP
On the fourth line, the \f(CW\*(C`USE WAREHOUSE\*(C'\fR statement was inserted by the default
Snowflake template. We don't actually need it to create a table, but there's
no harm in leaving it here.
.PP
Now for the verify script. The simplest way to check that the table was
created and has the expected columns without touching the data? Just select
from the table with a false \f(CW\*(C`WHERE\*(C'\fR clause. Here the \f(CW\*(C`USE WAREHOUSE\*(C'\fR
statement is required so that the \f(CW\*(C`SELECT\*(C'\fR statement can actually execute.
Probably easiest just to leave the default, which uses the warehouse that
Sqitch uses to maintain its registry. Edit \fIverify/users.sql\fR to look like
this:
.PP
.Vb 4
\&  USE WAREHOUSE &warehouse;
\&  SELECT nickname, password, fullname, twitter, timestamp
\&    FROM flipr.users
\&  WHERE FALSE;
.Ve
.PP
Now for the revert script: all we have to do is drop the table. Add this to
\&\fIrevert/users.sql\fR:
.PP
.Vb 1
\&  DROP TABLE flipr.users;
.Ve
.PP
Couldn't be much simpler, right? Let's deploy this bad boy:
.PP
.Vb 3
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + users .. ok
.Ve
.PP
We know, since verification is enabled, that the table must have been created.
But for the purposes of visibility, let's have a quick look:
.PP
.Vb 8
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE TABLES LIKE \*(Aqusers\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name  | kind  | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 15:13:21.767 +0000 | USERS | TABLE | DWHEELER      | FLIPR       |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.318s
.Ve
.PP
We can also verify all currently deployed changes with the
\&\f(CW\*(C`verify\*(C'\fR command:
.PP
.Vb 5
\&  > sqitch verify
\&  Verifying flipr_test
\&    * appschema .. ok
\&    * users ...... ok
\&  Verify successful
.Ve
.PP
Now have a look at the status:
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   d251b2c9b4bc46a4b4db6b7a8a637951484e6f6b
\&  # Name:     users
\&  # Deployed: 2018\-07\-27 11:09:12 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Success! Let's make sure we can revert the change, as well:
.PP
.Vb 3
\&  > sqitch revert \-\-to @HEAD^ \-y
\&  Reverting changes to appschema from flipr_test
\&    \- users .. ok
.Ve
.PP
Note that we've used the \f(CW\*(C`\-\-to\*(C'\fR option to specify the change to revert to.
And what do we revert to? The symbolic tag \f(CW@HEAD\fR, when passed to
\&\f(CW\*(C`revert\*(C'\fR, always refers to the last change deployed to the
database. (For other commands, it refers to the last change in the plan.)
Appending the caret (\f(CW\*(C`^\*(C'\fR) tells Sqitch to select the change \fIprior\fR to the
last deployed change. So we revert to \f(CW\*(C`appschema\*(C'\fR, the penultimate change.
The other potentially useful symbolic tag is \f(CW@ROOT\fR, which refers to the
first change deployed to the database (or in the plan, depending on the
command).
.PP
Back to the database. The \f(CW\*(C`users\*(C'\fR table should be gone but the \f(CW\*(C`flipr\*(C'\fR schema
should still be around:
.PP
.Vb 7
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE TABLES LIKE \*(Aqusers\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on | name | kind | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  0 Row(s) produced. Time Elapsed: 0.367s
.Ve
.PP
The \f(CW\*(C`status\*(C'\fR command politely informs us that we have
undeployed changes:
.PP
.Vb 9
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   5a2ac4ae6801bfe392483ee5912b4e3592cdd57a
\&  # Name:     appschema
\&  # Deployed: 2018\-07\-27 10:52:54 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Undeployed change:
\&    * users
.Ve
.PP
As does the \f(CW\*(C`verify\*(C'\fR command:
.PP
.Vb 6
\&  > sqitch verify
\&  Verifying flipr_test
\&    * appschema .. ok
\&  Undeployed change:
\&    * users
\&  Verify successful
.Ve
.PP
Note that the verify is successful, because all currently-deployed changes are
verified. The list of undeployed changes (just \*(L"users\*(R" here) reminds us about
the current state.
.PP
Okay, let's commit and deploy again:
.PP
.Vb 10
\&  > git add .
\&  > git commit \-am \*(AqAdd users table.\*(Aq
\&  [master 8c16c09] Add users table.
\&   4 files changed, 22 insertions(+)
\&   create mode 100644 deploy/users.sql
\&   create mode 100644 revert/users.sql
\&   create mode 100644 verify/users.sql
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + users .. ok
.Ve
.PP
Looks good. Check the status:
.PP
.Vb 8
\&  > sqitch status
\&  # Project:  flipr
\&  # Change:   d251b2c9b4bc46a4b4db6b7a8a637951484e6f6b
\&  # Name:     users
\&  # Deployed: 2018\-07\-27 11:19:30 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Excellent. Let's do some more!
.SH "Add Two at Once"
.IX Header "Add Two at Once"
Let's add a couple more changes. Our app will need to store status messages
from users. Let's call them \*(-- and the table to store them \*(-- \*(L"flips\*(R". And
we'll also need a view that lists user names with their flips. Let's add
changes for them both:
.PP
.Vb 5
\&  > sqitch add flips \-r appschema \-r users \-n \*(AqAdds table for storing flips.\*(Aq
\&  Created deploy/flips.sql
\&  Created revert/flips.sql
\&  Created verify/flips.sql
\&  Added "flips [appschema users]" to sqitch.plan
\&
\&  > sqitch add userflips \-r appschema \-r users \-r flips \e
\&    \-n \*(AqCreates the userflips view.\*(Aq
\&  Created deploy/userflips.sql
\&  Created revert/userflips.sql
\&  Created verify/userflips.sql
\&  Added "userflips [appschema users flips]" to sqitch.plan
.Ve
.PP
Now might be a good time to have a look at the deployment plan:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-snowflake\-intro/
\&
\&  appschema 2018\-07\-27T14:27:24Z Marge N. OXVera <marge@example.com> # Add schema for all flipr objects.
\&  users [appschema] 2018\-07\-27T15:03:56Z Marge N. OXVera <marge@example.com> # Creates table to track our users.
\&  flips [appschema users] 2018\-07\-27T15:23:41Z Marge N. OXVera <marge@example.com> # Adds table for storing flips.
\&  userflips [appschema users flips] 2018\-07\-27T15:23:50Z Marge N. OXVera <marge@example.com> # Creates the userflips view.
.Ve
.PP
Each change appears on a single line with the name of the change, a bracketed
list of dependencies, a timestamp, the name and email address of the user who
planned the change, and a note.
.PP
Let's write the code for the new changes. Here's what \fIdeploy/flips.sql\fR
should look like:
.PP
.Vb 3
\&  \-\- Deploy flipr:flips to snowflake
\&  \-\- requires: appschema
\&  \-\- requires: users
\&
\&  USE WAREHOUSE &warehouse;
\&  CREATE TABLE flipr.flips (
\&      id        INTEGER        PRIMARY KEY,
\&      nickname  TEXT           NOT NULL REFERENCES flipr.users(nickname),
\&      body      VARCHAR(180)   NOT NULL DEFAULT \*(Aq\*(Aq,
\&      timestamp TIMESTAMP_TZ NOT NULL DEFAULT CURRENT_TIMESTAMP
\&  );
.Ve
.PP
Here's what \fIverify/flips.sql\fR might look like:
.PP
.Vb 1
\&  \-\- Verify flipr:flips on snowflake
\&
\&  USE WAREHOUSE &warehouse;
\&  SELECT id, nickname, body, timestamp
\&    FROM flipr.flips
\&   WHERE FALSE;
.Ve
.PP
And \fIrevert/flips.sql\fR should look something like this:
.PP
.Vb 1
\&  \-\- Revert flipr:flips from snowflake
\&
\&  USE WAREHOUSE &warehouse;
\&  DROP TABLE flipr.flips;
.Ve
.PP
Now for \f(CW\*(C`userflips\*(C'\fR; \fIdeploy/userflips.sql\fR might look like this:
.PP
.Vb 4
\&  \-\- Deploy flipr:userflips to snowflake
\&  \-\- requires: appschema
\&  \-\- requires: users
\&  \-\- requires: flips
\&
\&  USE WAREHOUSE &warehouse;
\&  CREATE OR REPLACE VIEW flipr.userflips AS
\&  SELECT f.id, u.nickname, u.fullname, f.body, f.timestamp
\&    FROM flipr.users u
\&    JOIN flipr.flips f ON u.nickname = f.nickname;
.Ve
.PP
Use a \f(CW\*(C`SELECT\*(C'\fR statement in \fIverify/userflips.sql\fR again:
.PP
.Vb 1
\&  \-\- Verify flipr:userflips on snowflake
\&
\&  USE WAREHOUSE &warehouse;
\&  SELECT id, nickname, fullname, body, timestamp
\&    FROM flipr.userflips
\&   WHERE FALSE;
.Ve
.PP
And of course, its \f(CW\*(C`revert\*(C'\fR script, \fIrevert/userflips.sql\fR, should look
something like:
.PP
.Vb 1
\&  \-\- Revert flipr:userflips from snowflake
\&
\&  USE WAREHOUSE &warehouse;
\&  DROP VIEW flipr.userflips;
.Ve
.PP
Try em out!
.PP
.Vb 4
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + flips ...... ok
\&    + userflips .. ok
.Ve
.PP
Do we have the new table and view? Of course we do, they were verified. Still,
have a look:
.PP
.Vb 8
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE TABLES LIKE \*(Aqflips\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name  | kind  | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 15:31:07.137 +0000 | FLIPS | TABLE | DWHEELER      | FLIPR       |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.225s
\&
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE VIEWS LIKE \*(Aquserflips\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name      | kind | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 15:29:25.733 +0000 | USERFLIPS | VIEW | DWHEELER      | FLIPR       |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.299s
.Ve
.PP
And what's the status?
.PP
.Vb 9
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   73cd50c99de2a8b3eab206c73514afbeb952023c
\&  # Name:     userflips
\&  # Deployed: 2018\-07\-27 11:31:24 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Looks good. Let's make sure revert works:
.PP
.Vb 4
\&  > sqitch revert \-y \-\-to @HEAD^^
\&  Reverting changes to users from flipr_test
\&    \- userflips .. ok
\&    \- flips ...... ok
\&
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW TERSE TABLES LIKE \*(Aqflips\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on | name | kind | database_name | schema_name |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-|
\&  +\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+
\&  0 Row(s) produced. Time Elapsed: 0.306s
.Ve
.PP
Note the use of \f(CW\*(C`@HEAD^^\*(C'\fR to specify that the revert be to two changes prior
the last deployed change. Looks good. Let's do the commit and re-deploy dance:
.PP
.Vb 10
\&  > git add .
\&  > git commit \-m \*(AqAdd flips table and userflips view.\*(Aq
\&  [master b36f48b] Add flips table and userflips view.
\&   7 files changed, 43 insertions(+)
\&   create mode 100644 deploy/flips.sql
\&   create mode 100644 deploy/userflips.sql
\&   create mode 100644 revert/flips.sql
\&   create mode 100644 revert/userflips.sql
\&   create mode 100644 verify/flips.sql
\&   create mode 100644 verify/userflips.sql
\&
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + flips ...... ok
\&    + userflips .. ok
\&
\&  > sqitch status
\&  # Project:  flipr
\&  # Change:   73cd50c99de2a8b3eab206c73514afbeb952023c
\&  # Name:     userflips
\&  # Deployed: 2018\-07\-27 11:38:02 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
\&
\&  > sqitch verify
\&  Verifying flipr_test
\&    * appschema .. ok
\&    * users ...... ok
\&    * flips ...... ok
\&    * userflips .. ok
\&  Verify successful
.Ve
.PP
Great, we're fully up-to-date!
.SH "Ship It!"
.IX Header "Ship It!"
Let's do a first release of our app. Let's call it \f(CW\*(C`1.0.0\-dev1\*(C'\fR Since we want
to have it go out with deployments tied to the release, let's tag it:
.PP
.Vb 6
\&  > sqitch tag v1.0.0\-dev1 \-n \*(AqTag v1.0.0\-dev1.\*(Aq
\&  Tagged "userflips" with @v1.0.0\-dev1
\&  > git commit \-am \*(AqTag the database with v1.0.0\-dev1.\*(Aq
\&  [master 84ed9db] Tag the database with v1.0.0\-dev1.
\&   1 files changed, 1 insertion(+)
\&  > git tag v1.0.0\-dev1 \-am \*(AqTag v1.0.0\-dev1\*(Aq
.Ve
.PP
We can try deploying to make sure the tag gets picked up like so:
.PP
.Vb 12
\&  > sqitch deploy
\&  Nothing to deploy (up\-to\-date)
\&  > sqitch status
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   73cd50c99de2a8b3eab206c73514afbeb952023c
\&  # Name:     userflips
\&  # Tag:      @v1.0.0\-dev1
\&  # Deployed: 2018\-07\-27 11:38:02 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  #
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Note the new \*(L"Tag\*(R" line in the output of \f(CW\*(C`sqitch status\*(C'\fR: no new changes
needed to be deployed, but Sqitch did deploy the tag on the \f(CW\*(C`userflips\*(C'\fR
change. Now let's bundle everything up for release:
.PP
.Vb 9
\&  > sqitch bundle
\&  Bundling into bundle
\&  Writing config
\&  Writing plan
\&  Writing scripts
\&    + appschema
\&    + users
\&    + flips
\&    + userflips @v1.0.0\-dev1
.Ve
.PP
Now we can package the \fIbundle\fR directory and distribute it. When it gets
installed somewhere, users can use Sqitch to deploy to the database. Let's try
deploying it to another database, \f(CW\*(C`flipr_prod\*(C'\fR:
.PP
.Vb 8
\&  > cd bundle
\&  > sqitch deploy \*(Aqdb:snowflake://movera@example/flipr_prod?Driver=Snowflake\*(Aq
\&  Adding registry tables to db:snowflake://movera@example/flipr_prod?Driver=Snowflake\*(Aq
\&  Deploying changes to db:snowflake://movera@example/flipr_prod?Driver=Snowflake\*(Aq
\&    + appschema ............... ok
\&    + users ................... ok
\&    + flips ................... ok
\&    + userflips @v1.0.0\-dev1 .. ok
.Ve
.PP
Notice how the tag on \f(CW\*(C`userflips\*(C'\fR now appears in the deploy output. Nice, eh?
Now, package it up and ship it!
.PP
.Vb 3
\&  > cd ..
\&  > mv bundle flipr\-v1.0.0\-dev1
\&  > tar \-czf flipr\-v1.0.0\-dev1.tgz flipr\-v1.0.0\-dev1
.Ve
.SH "Making a Hash of Things"
.IX Header "Making a Hash of Things"
Now that we've got the basics of the app done, let's add a feature. Gotta
track the hashtags associated with flips, right? Let's add a table for them.
But since other folks are working on other tasks in the repository, we'll work
on a branch, so we can all stay out of each other's way. So let's branch:
.PP
.Vb 2
\&  > git checkout \-b hashtags
\&  Switched to a new branch \*(Aqhashtags\*(Aq
.Ve
.PP
Now we can add a new change to create a table for hashtags.
.PP
.Vb 5
\&  > sqitch add hashtags \-\-requires flips \-n \*(AqAdds table for storing hashtags.\*(Aq
\&  Created deploy/hashtags.sql
\&  Created revert/hashtags.sql
\&  Created verify/hashtags.sql
\&  Added "hashtags [appschema flips]" to sqitch.plan
.Ve
.PP
You know the drill by now. Add this to \fIdeploy/hashtags.sql\fR
.PP
.Vb 5
\&  CREATE TABLE flipr.hashtags (
\&      flip_id   INTEGER       NOT NULL REFERENCES flipr.flips(id),
\&      hashtag   VARCHAR(128)  NOT NULL,
\&      PRIMARY KEY (flip_id, hashtag)
\&  );
.Ve
.PP
Again, select from the table in \fIverify/hashtags.sql\fR:
.PP
.Vb 1
\&  SELECT flip_id, hashtag FROM flipr.hashtags WHERE FALSE;
.Ve
.PP
And drop it in \fIrevert/hashtags.sql\fR
.PP
.Vb 1
\&  DROP TABLE flipr.hashtags;
.Ve
.PP
And give it a whirl:
.PP
.Vb 3
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + hashtags .. ok
.Ve
.PP
Look good?
.PP
.Vb 12
\&  > sqitch status \-\-show\-tags
\&  # On database flipr_test
\&  # Project:  flipr
\&  # Change:   d750cbeec487841c45715115a31297739fbb4046
\&  # Name:     hashtags
\&  # Deployed: 2018\-07\-27 11:53:02 \-0400
\&  # By:       Marge N. OXVera <marge@example.com>
\&  # 
\&  # Tag:
\&  #   @v1.0.0\-dev1 \- 2018\-07\-27 11:41:13 \-0400 \- Marge N. OXVera <marge@example.com>
\&  # 
\&  Nothing to deploy (up\-to\-date)
.Ve
.PP
Note the use of \f(CW\*(C`\-\-show\-tags\*(C'\fR to show all the deployed tags. Make sure we can
revert, too:
.PP
.Vb 6
\&  > sqitch revert \-y \-\-onto @HEAD^
\&  Reverting changes to userflips @v1.0.0\-dev1 from flipr_test
\&    \- hashtags .. ok
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + hashtags .. ok
.Ve
.PP
Great! Now make it so:
.PP
.Vb 7
\&  > git add .
\&  > git commit \-m \*(AqAdd hashtags table.\*(Aq
\&  [hashtags 06a0bf4] Add hashtags table.
\&   4 files changed, 19 insertions(+)
\&   create mode 100644 deploy/hashtags.sql
\&   create mode 100644 revert/hashtags.sql
\&   create mode 100644 verify/hashtags.sql
.Ve
.PP
Good, we've finished this feature. Time to merge back into \f(CW\*(C`master\*(C'\fR.
.SS "Emergency"
.IX Subsection "Emergency"
Let's do it:
.PP
.Vb 10
\&  > git checkout master
\&  Switched to branch \*(Aqmaster\*(Aq
\&  > git pull
\&  Updating 84ed9db..31d026c
\&  Fast\-forward
\&   deploy/lists.sql | 11 +++++++++++
\&   revert/lists.sql |  4 ++++
\&   sqitch.plan      |  2 ++
\&   verify/lists.sql |  6 ++++++
\&   4 files changed, 23 insertions(+)
\&   create mode 100644 deploy/lists.sql
\&   create mode 100644 revert/lists.sql
\&   create mode 100644 verify/lists.sql
.Ve
.PP
Hrm, that's interesting. Looks like someone made some changes to \f(CW\*(C`master\*(C'\fR.
They added list support. Well, let's see what happens when we merge our
changes.
.PP
.Vb 4
\&  > git merge \-\-no\-ff hashtags
\&  Auto\-merging sqitch.plan
\&  CONFLICT (content): Merge conflict in sqitch.plan
\&  Automatic merge failed; fix conflicts and then commit the result.
.Ve
.PP
Oh, a conflict in \fIsqitch.plan\fR. Not too surprising, since both the merged
\&\f(CW\*(C`lists\*(C'\fR branch and our \f(CW\*(C`hashtags\*(C'\fR branch added changes to the plan. Let's
try a different approach.
.PP
The truth is, we got lazy. Those changes when we pulled master from the origin
should have raised a red flag. It's considered a bad practice not to look at
what's changed in \f(CW\*(C`master\*(C'\fR before merging in a branch. What one \fIshould\fR do
is either:
.IP "\(bu" 4
Rebase the \fIhashtags\fR branch from master before merging. This \*(L"rewinds\*(R" the
branch changes, pulls from \f(CW\*(C`master\*(C'\fR, and then replays the changes back on top
of the pulled changes.
.IP "\(bu" 4
Create a patch and apply \fIthat\fR to master. This is the sort of thing you
might have to do if you're sending changes to another user, especially if the
\&\s-1VCS\s0 is not Git.
.PP
So let's restore things to how they were at master:
.PP
.Vb 2
\&  > git reset \-\-hard HEAD
\&  HEAD is now at 31d026c Merge branch \*(Aqlists\*(Aq
.Ve
.PP
That throws out our botched merge. Now let's go back to our branch and rebase
it on \f(CW\*(C`master\*(C'\fR:
.PP
.Vb 10
\&  > git checkout hashtags
\&  Switched to branch \*(Aqhashtags\*(Aq
\&  > git rebase master
\&  First, rewinding head to replay your work on top of it...
\&  Applying: Add hashtags table.
\&  Using index info to reconstruct a base tree...
\&  M     sqitch.plan
\&  Falling back to patching base and 3\-way merge...
\&  Auto\-merging sqitch.plan
\&  CONFLICT (content): Merge conflict in sqitch.plan
\&  error: Failed to merge in the changes.
\&  Patch failed at 0001 Add hashtags table.
\&  Use \*(Aqgit am \-\-show\-current\-patch\*(Aq to see the failed patch
\&
\&  Resolve all conflicts manually, mark them as resolved with
\&  "git add/rm <conflicted_files>", then run "git rebase \-\-continue".
\&  You can instead skip this commit: run "git rebase \-\-skip".
\&  To abort and get back to the state before "git rebase", run "git rebase \-\-abort".
.Ve
.PP
Oy, that's kind of a pain. It seems like no matter what we do, we'll need to
resolve conflicts in that file. Except in Git. Fortunately for us, we can tell
Git to resolve conflicts in \fIsqitch.plan\fR differently. Because we only ever
append lines to the file, we can have it use the \*(L"union\*(R" merge driver, which,
according to
its docs <https://git-scm.com/docs/gitattributes#_built-in_merge_drivers>:
.Sp
.RS 4
Run 3\-way file level merge for text files, but take lines from both versions,
instead of leaving conflict markers. This tends to leave the added lines in
the resulting file in random order and the user should verify the result. Do
not use this if you do not understand the implications.
.RE
.PP
This has the effect of appending lines from all the merging files, which is
exactly what we need. So let's give it a try. First, back out the botched
rebase:
.PP
.Vb 2
\&  > git rebase \-\-abort
\&  HEAD is now at 06a0bf4 Add hashtags table.
.Ve
.PP
Now add the union merge driver to \fI.gitattributes\fR for \fIsqitch.plan\fR
and rebase again:
.PP
.Vb 8
\&  > echo sqitch.plan merge=union > .gitattributes
\&  > git rebase master
\&  First, rewinding head to replay your work on top of it...
\&  Applying: Add hashtags table.
\&  Using index info to reconstruct a base tree...
\&  M     sqitch.plan
\&  Falling back to patching base and 3\-way merge...
\&  Auto\-merging sqitch.plan
.Ve
.PP
Ah, that looks a bit better. Let's have a look at the plan:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-snowflake\-intro/
\&
\&  appschema 2018\-07\-27T14:27:24Z Marge N. OXVera <marge@example.com> # Add schema for all flipr objects.
\&  users [appschema] 2018\-07\-27T15:03:56Z Marge N. OXVera <marge@example.com> # Creates table to track our users.
\&  flips [appschema users] 2018\-07\-27T15:23:41Z Marge N. OXVera <marge@example.com> # Adds table for storing flips.
\&  userflips [appschema users flips] 2018\-07\-27T15:23:50Z Marge N. OXVera <marge@example.com> # Creates the userflips view.
\&  @v1.0.0\-dev1 2018\-07\-27T15:40:25Z Marge N. OXVera <marge@example.com> # Tag v1.0.0\-dev1.
\&
\&  lists [appschema flips] 2018\-07\-27T16:00:00Z Marge N. OXVera <marge@example.com> # Adds table for storing lists.
\&  hashtags [flips] 2018\-07\-27T15:51:16Z Marge N. OXVera <marge@example.com> # Adds table for storing hashtags.
.Ve
.PP
Note that it has appended the changes from the merged \*(L"lists\*(R" branch, and then
merged the changes from our \*(L"hashtags\*(R" branch. Test it to make sure it works
as expected:
.PP
.Vb 10
\&  > sqitch rebase \-y
\&  Reverting all changes from flipr_test
\&    \- hashtags ................ ok
\&    \- userflips @v1.0.0\-dev1 .. ok
\&    \- flips ................... ok
\&    \- users ................... ok
\&    \- appschema ............... ok
\&  Deploying changes to flipr_test
\&    + appschema ............... ok
\&    + users ................... ok
\&    + flips ................... ok
\&    + userflips @v1.0.0\-dev1 .. ok
\&    + lists ................... ok
\&    + hashtags ................ ok
.Ve
.PP
Note the use of \f(CW\*(C`rebase\*(C'\fR, which combines a
\&\f(CW\*(C`revert\*(C'\fR and a \f(CW\*(C`deploy\*(C'\fR into a single
command. Handy, right? It correctly reverted our changes, and then deployed
them all again in the proper order. So let's commit \fI.gitattributes\fR; seems
worthwhile to keep that change:
.PP
.Vb 5
\&  > git add .
\&  > git commit \-m \*(AqAdd \`.gitattributes\` with union merge for \`sqitch.plan\`.\*(Aq
\&  [hashtags 86596a9] Add \`.gitattributes\` with union merge for \`sqitch.plan\`.
\&   1 files changed, 1 insertions(+), 0 deletions(\-)
\&   create mode 100644 .gitattributes
.Ve
.SS "Merges Mastered"
.IX Subsection "Merges Mastered"
And now, finally, we can merge into \f(CW\*(C`master\*(C'\fR:
.PP
.Vb 10
\&  > git checkout master
\&  Switched to branch \*(Aqmaster\*(Aq
\&  > git merge \-\-no\-ff hashtags \-m "Merge branch \*(Aqhashtags\*(Aq"
\&  Merge made by the \*(Aqrecursive\*(Aq strategy.
\&   .gitattributes      | 1 +
\&   deploy/hashtags.sql | 9 ++++++++++
\&   revert/hashtags.sql | 4 ++++
\&   sqitch.plan         | 1 +
\&   verify/hashtags.sql | 4 ++++
\&   5 files changed, 19 insertions(+)
\&   create mode 100644 .gitattributes
\&   create mode 100644 deploy/hashtags.sql
\&   create mode 100644 revert/hashtags.sql
\&   create mode 100644 verify/hashtags.sql
.Ve
.PP
And double-check our work:
.PP
.Vb 4
\&  > cat sqitch.plan
\&  %syntax\-version=1.0.0
\&  %project=flipr
\&  %uri=https://github.com/sqitchers/sqitch\-snowflake\-intro/
\&
\&  appschema 2018\-07\-27T14:27:24Z Marge N. OXVera <marge@example.com> # Add schema for all flipr objects.
\&  users [appschema] 2018\-07\-27T15:03:56Z Marge N. OXVera <marge@example.com> # Creates table to track our users.
\&  flips [appschema users] 2018\-07\-27T15:23:41Z Marge N. OXVera <marge@example.com> # Adds table for storing flips.
\&  userflips [appschema users flips] 2018\-07\-27T15:23:50Z Marge N. OXVera <marge@example.com> # Creates the userflips view.
\&  @v1.0.0\-dev1 2018\-07\-27T15:40:25Z Marge N. OXVera <marge@example.com> # Tag v1.0.0\-dev1.
\&
\&  lists [appschema flips] 2018\-07\-27T16:00:00Z Marge N. OXVera <marge@example.com> # Adds table for storing lists.
\&  hashtags [flips] 2018\-07\-27T15:51:16Z Marge N. OXVera <marge@example.com> # Adds table for storing hashtags.
.Ve
.PP
Much much better, a nice clean master now. And because it is now identical to
the \*(L"hashtags\*(R" branch, we can just carry on. Go ahead and tag it, bundle, and
release:
.PP
.Vb 10
\&  > sqitch tag v1.0.0\-dev2 \-n \*(AqTag v1.0.0\-dev2.\*(Aq
\&  Tagged "hashtags" with @v1.0.0\-dev2
\&  > git commit \-am \*(AqTag the database with v1.0.0\-dev2.\*(Aq
\&  [master 1c67e0d] Tag the database with v1.0.0\-dev2.
\&   1 files changed, 1 insertion(+)
\&  > git tag v1.0.0\-dev2 \-am \*(AqTag v1.0.0\-dev2\*(Aq
\&  > sqitch bundle \-\-dest\-dir flipr\-1.0.0\-dev2
\&  Bundling into flipr\-1.0.0\-dev2
\&  Writing config
\&  Writing plan
\&  Writing scripts
\&    + appschema
\&    + users
\&    + flips
\&    + userflips @v1.0.0\-dev1
\&    + lists
\&    + hashtags @v1.0.0\-dev2
.Ve
.PP
Note the use of the \f(CW\*(C`\-\-dest\-dir\*(C'\fR option to \f(CW\*(C`sqitch bundle\*(C'\fR. Just a nicer way
to create the top-level directory name so we don't have to rename it from
\&\fIbundle\fR.
.SH "In Place Changes"
.IX Header "In Place Changes"
Well, some folks have been testing the \f(CW\*(C`1.0.0\-dev2\*(C'\fR release and have demanded
that Twitter user links be added to Flipr pages. Why anyone would want to
include social network links in an anti-social networking app is beyond us
programmers, but we're just the plumbers, right? Gotta go with what Product
demands. The upshot is that we need to update the \f(CW\*(C`userflips\*(C'\fR view, which is
used for the feature in question, to include the Twitter user names.
.PP
Normally, modifying views in database changes is a
\&\s-1PITA\s0 <https://www.urbandictionary.com/define.php?term=pita>. You have to make
changes like these:
.IP "1." 4
Copy \fIdeploy/userflips.sql\fR to \fIdeploy/userflips_twitter.sql\fR.
.IP "2." 4
Edit \fIdeploy/userflips_twitter.sql\fR to drop and re-create the view with the
\&\f(CW\*(C`twitter\*(C'\fR column to the view.
.IP "3." 4
Copy \fIdeploy/userflips.sql\fR to \fIrevert/userflips_twitter.sql\fR.
Yes, copy the original change script to the new revert change.
.IP "4." 4
Add a \f(CW\*(C`DROP VIEW\*(C'\fR statement to \fIrevert/userflips_twitter.sql\fR.
.IP "5." 4
Copy \fIverify/userflips.sql\fR to \fIverify/userflips_twitter.sql\fR.
.IP "6." 4
Modify \fIverify/userflips_twitter.sql\fR to include a check for the \f(CW\*(C`twiter\*(C'\fR
column.
.IP "7." 4
Test the changes to make sure you can deploy and revert the
\&\f(CW\*(C`userflips_twitter\*(C'\fR change.
.PP
But you can have Sqitch do most of the work for you. The only requirement is
that a tag appear between the two instances of a change we want to modify. In
general, you're going to make a change like this after a release, which you've
tagged anyway, right? Well we have, with \f(CW\*(C`@v1.0.0\-dev2\*(C'\fR added in the previous
section. With that, we can let Sqitch do most of the hard work for us, thanks
to the \f(CW\*(C`rework\*(C'\fR command, which is similar to
\&\f(CW\*(C`add\*(C'\fR:
.PP
.Vb 6
\&  > sqitch rework userflips \-n \*(AqAdds userflips.twitter.\*(Aq
\&  Added "userflips [userflips@v1.0.0\-dev2]" to sqitch.plan.
\&  Modify these files as appropriate:
\&    * deploy/userflips.sql
\&    * revert/userflips.sql
\&    * verify/userflips.sql
.Ve
.PP
Oh, so we can edit those files in place. Nice! How does Sqitch do it? Well, in
point of fact, it has copied the files to stand in for the previous instance
of the \f(CW\*(C`userflips\*(C'\fR change, which we can see via \f(CW\*(C`git status\*(C'\fR:
.PP
.Vb 3
\&  > git status
\&  On branch master
\&  Your branch is up to date with \*(Aqorigin/master\*(Aq.
\&
\&  Changes not staged for commit:
\&    (use "git add <file>..." to update what will be committed)
\&    (use "git checkout \-\- <file>..." to discard changes in working directory)
\&
\&    modified:   revert/userflips.sql
\&    modified:   sqitch.plan
\&
\&  Untracked files:
\&    (use "git add <file>..." to include in what will be committed)
\&
\&    deploy/userflips@v1.0.0\-dev2.sql
\&    revert/userflips@v1.0.0\-dev2.sql
\&    verify/userflips@v1.0.0\-dev2.sql
\&
\&  no changes added to commit (use "git add" and/or "git commit \-a")
.Ve
.PP
The \*(L"Untracked files\*(R" part of the output is the first thing to notice. They're
all named \f(CW\*(C`userflips@v1.0.0\-dev2.sql\*(C'\fR. What that means is: "the \f(CW\*(C`userflips\*(C'\fR
change as it was implemented as of the \f(CW\*(C`@v1.0.0\-dev2\*(C'\fR tag." These are copies
of the original scripts, and thereafter Sqitch will find them when it needs to
run scripts for the first instance of the \f(CW\*(C`userflips\*(C'\fR change. As such, it's
important not to change them again. But hey, if you're reworking the change,
you shouldn't need to.
.PP
The other thing to notice is that \fIrevert/userflips.sql\fR has changed. Sqitch
replaced it with the original deploy script. As of now,
\&\fIdeploy/userflips.sql\fR and \fIrevert/userflips.sql\fR are identical. This is on
the assumption that the deploy script will be changed (we're reworking it,
remember?), and that the revert script should actually change things back to
how they were before. Of course, the original deploy script may not be
idempotent <https://en.wikipedia.org/wiki/Idempotence> \*(-- that is, able to be
applied multiple times without changing the result beyond the initial
application. If it's not, you will likely need to modify it so that it
properly restores things to how they were after the original deploy script was
deployed. Or, more simply, it should revert changes back to how they were
as-of the deployment of \fIdeploy/userflips@v1.0.0\-dev2.sql\fR.
.PP
Fortunately, our view deploy scripts are already idempotent, thanks to the
use of the \f(CW\*(C`OR REPLACE\*(C'\fR expression. No matter how many times a deployment
script is run, the end result will be the same instance of the view, with
no duplicates or errors.
.PP
As a result, there is no need to explicitly add changes. So go ahead. Modify
the script to add the \f(CW\*(C`twitter\*(C'\fR column to the view. Make this change to
\&\fIdeploy/userflips.sql\fR:
.PP
.Vb 1
\&  @@ \-5,6 +5,6 @@
\&  
\&  USE WAREHOUSE &warehouse;
\&  CREATE OR REPLACE VIEW flipr.userflips AS
\&  \-SELECT f.id, u.nickname, u.fullname, f.body, f.timestamp
\&  +SELECT SELECT f.id, u.nickname, u.fullname, u.twitter, f.body, f.timestamp
\&    FROM flipr.users u
\&    JOIN flipr.flips f ON u.nickname = f.nickname;
.Ve
.PP
Next, modify \fIverify/userflips.sql\fR to check for the \f(CW\*(C`twitter\*(C'\fR column.
Here's the diff:
.PP
.Vb 2
\&  @@ \-1,6 +1,6 @@
\&   \-\- Verify flipr:userflips on snowflake
\&
\&  \-SELECT id, nickname, fullname, body, timestamp
\&  +SELECT id, nickname, fullname, twitter, body, timestamp
\&     FROM flipr.userflips
\&    WHERE FALSE;
.Ve
.PP
Now try a deployment:
.PP
.Vb 3
\&  > sqitch deploy
\&  Deploying changes to flipr_test
\&    + userflips .. ok
.Ve
.PP
So, are the changes deployed?
.PP
.Vb 11
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW VIEWS LIKE \*(Aquserflips\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name      | reserved | database_name | schema_name | owner  | comment | text                                                                | is_secure |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 18:19:29.818 +0000 | USERFLIPS |          | DWHEELER      | FLIPR       | SQITCH |         | CREATE OR REPLACE VIEW flipr.userflips AS                           | false     |
\&  |                               |           |          |               |             |        |         | SELECT f.id, u.nickname, u.fullname, u.twitter, f.body, f.timestamp |           |
\&  |                               |           |          |               |             |        |         |   FROM flipr.users u                                                |           |
\&  |                               |           |          |               |             |        |         |   JOIN flipr.flips f ON u.nickname = f.nickname;                    |           |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.413s
.Ve
.PP
Awesome, the view now includes the \f(CW\*(C`twitter\*(C'\fR column. But can we revert?
.PP
.Vb 3
\&  > sqitch revert \-\-to @HEAD^ \-y
\&  Reverting changes to hashtags @v1.0.0\-dev2 from flipr_test
\&    \- userflips .. ok
.Ve
.PP
Did that work, is the \f(CW\*(C`twitter\*(C'\fR column gone?
.PP
.Vb 11
\&  > snowsql \-\-accountname example \-\-username movera \-\-dbname flipr \-o friendly=false \e
\&    \-\-query "SHOW VIEWS LIKE \*(Aquserflips\*(Aq IN flipr"
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\&  | created_on                    | name      | reserved | database_name | schema_name | owner  | comment | text                                                     | is_secure |
\&  |\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-|
\&  | 2018\-07\-27 18:50:52.064 +0000 | USERFLIPS |          | DWHEELER      | FLIPR       | SQITCH |         | CREATE OR REPLACE VIEW flipr.userflips AS                | false     |
\&  |                               |           |          |               |             |        |         | SELECT f.id, u.nickname, u.fullname, f.body, f.timestamp |           |
\&  |                               |           |          |               |             |        |         |   FROM flipr.users u                                     |           |
\&  |                               |           |          |               |             |        |         |   JOIN flipr.flips f ON u.nickname = f.nickname;         |           |
\&  +\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-\-+\-\-\-\-\-\-\-\-\-\-\-+
\&  1 Row(s) produced. Time Elapsed: 0.362s
.Ve
.PP
Yes, it works! Sqitch properly finds the original instances of these changes
in the new script files that include tags.
.PP
Excellent. Let's go ahead and commit these changes:
.PP
.Vb 7
\&  > git add .
\&  > git commit \-m \*(AqAdd the twitter column to the userflips view.\*(Aq
\&  [master c004445] Add the twitter column to the userflips view.
\&   7 files changed, 31 insertions(+), 4 deletions(\-)
\&   create mode 100644 deploy/userflips@v1.0.0\-dev2.sql
\&   create mode 100644 revert/userflips@v1.0.0\-dev2.sql
\&   create mode 100644 verify/userflips@v1.0.0\-dev2.sql
.Ve
.SH "More to Come"
.IX Header "More to Come"
Sqitch is a work in progress. Better integration with version control systems
is planned to make managing idempotent reworkings even easier. Stay tuned.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
