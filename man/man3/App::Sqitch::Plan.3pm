.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Sqitch::Plan 3"
.TH App::Sqitch::Plan 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
App::Sqitch::Plan \- Sqitch Deployment Plan
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 4
\&  my $plan = App::Sqitch::Plan\->new( sqitch => $sqitch );
\&  while (my $change = $plan\->next) {
\&      say "Deploy ", $change\->format_name;
\&  }
.Ve
.SH "Description"
.IX Header "Description"
App::Sqitch::Plan provides the interface for a Sqitch plan. It parses a plan
file and provides an iteration interface for working with the plan.
.SH "Interface"
.IX Header "Interface"
.SS "Constants"
.IX Subsection "Constants"
\fI\f(CI\*(C`SYNTAX_VERSION\*(C'\fI\fR
.IX Subsection "SYNTAX_VERSION"
.PP
Returns the current version of the Sqitch plan syntax. Used for the
\&\f(CW\*(C`%sytax\-version\*(C'\fR pragma.
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`name_regex\*(C'\fI\fR
.IX Subsection "name_regex"
.PP
.Vb 1
\&  die "$this has no name" unless $this =~ App::Sqitch::Plan\->name_regex;
.Ve
.PP
Returns a regular expression that matches names. Note that it is not anchored,
so if you need to make sure that a string is a valid name and nothing else,
you will need to anchor it yourself, like so:
.PP
.Vb 2
\&    my $name_re = App::Sqitch::Plan\->name_regex;
\&    die "$this is not a valid name" if $this !~ /\eA$name_re\ez/;
.Ve
.SS "Constructors"
.IX Subsection "Constructors"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  my $plan = App::Sqitch::Plan\->new( sqitch => $sqitch );
.Ve
.PP
Instantiates and returns a App::Sqitch::Plan object. Takes a single parameter:
an App::Sqitch object.
.SS "Accessors"
.IX Subsection "Accessors"
\fI\f(CI\*(C`sqitch\*(C'\fI\fR
.IX Subsection "sqitch"
.PP
.Vb 1
\&  my $sqitch = $plan\->sqitch;
.Ve
.PP
Returns the App::Sqitch object that instantiated the plan.
.PP
\fI\f(CI\*(C`target\*(C'\fI\fR
.IX Subsection "target"
.PP
.Vb 1
\&  my $target = $plan\->target
.Ve
.PP
Returns the App::Sqitch::Target passed to the constructor.
.PP
\fI\f(CI\*(C`file\*(C'\fI\fR
.IX Subsection "file"
.PP
.Vb 1
\&  my $file = $plan\->file;
.Ve
.PP
The file name from which to read the plan.
.PP
\fI\f(CI\*(C`position\*(C'\fI\fR
.IX Subsection "position"
.PP
Returns the current position of the iterator. This is an integer that's used
as an index into plan. If \f(CW\*(C`next()\*(C'\fR has not been called, or if \f(CW\*(C`reset()\*(C'\fR has
been called, the value will be \-1, meaning it is outside of the plan. When
\&\f(CW\*(C`next\*(C'\fR returns \f(CW\*(C`undef\*(C'\fR, the value will be the last index in the plan plus 1.
.PP
\fI\f(CI\*(C`project\*(C'\fI\fR
.IX Subsection "project"
.PP
.Vb 1
\&  my $project = $plan\->project;
.Ve
.PP
Returns the name of the project as set via the \f(CW%project\fR pragma in the plan
file.
.PP
\fI\f(CI\*(C`uri\*(C'\fI\fR
.IX Subsection "uri"
.PP
.Vb 1
\&  my $uri = $plan\->uri;
.Ve
.PP
Returns the \s-1URI\s0 for the project as set via the \f(CW%uri\fR pragma, which is
optional. If it is not present, \f(CW\*(C`undef\*(C'\fR will be returned.
.PP
\fI\f(CI\*(C`syntax_version\*(C'\fI\fR
.IX Subsection "syntax_version"
.PP
.Vb 1
\&  my $syntax_version = $plan\->syntax_version;
.Ve
.PP
Returns the plan syntax version, which is always the latest version.
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`index_of\*(C'\fI\fR
.IX Subsection "index_of"
.PP
.Vb 5
\&  my $index      = $plan\->index_of(\*(Aq6c2f28d125aff1deea615f8de774599acf39a7a1\*(Aq);
\&  my $foo_index  = $plan\->index_of(\*(Aq@foo\*(Aq);
\&  my $bar_index  = $plan\->index_of(\*(Aqbar\*(Aq);
\&  my $bar1_index = $plan\->index_of(\*(Aqbar@alpha\*(Aq)
\&  my $bar2_index = $plan\->index_of(\*(Aqbar@HEAD\*(Aq);
.Ve
.PP
Returns the index of the specified change. Returns \f(CW\*(C`undef\*(C'\fR if no such change
exists. The argument may be any one of:
.IP "\(bu" 4
An \s-1ID\s0
.Sp
.Vb 1
\&  my $index = $plan\->index_of(\*(Aq6c2f28d125aff1deea615f8de774599acf39a7a1\*(Aq);
.Ve
.Sp
This is the \s-1SHA1\s0 hash of a change or tag. Currently, the full 40\-character hexed
hash string must be specified.
.IP "\(bu" 4
A change name
.Sp
.Vb 1
\&  my $index = $plan\->index_of(\*(Aqusers_table\*(Aq);
.Ve
.Sp
The name of a change. Will throw an exception if the named change appears more
than once in the list.
.IP "\(bu" 4
A tag name
.Sp
.Vb 1
\&  my $index = $plan\->index_of(\*(Aq@beta1\*(Aq);
.Ve
.Sp
The name of a tag, including the leading \f(CW\*(C`@\*(C'\fR.
.IP "\(bu" 4
A tag-qualified change name
.Sp
.Vb 1
\&  my $index = $plan\->index_of(\*(Aqusers_table@beta1\*(Aq);
.Ve
.Sp
The named change as it was last seen in the list before the specified tag.
.PP
\fI\f(CI\*(C`contains\*(C'\fI\fR
.IX Subsection "contains"
.PP
.Vb 1
\&  say \*(AqYes!\*(Aq if $plan\->contains(\*(Aq6c2f28d125aff1deea615f8de774599acf39a7a1\*(Aq);
.Ve
.PP
Like \f(CW\*(C`index_of()\*(C'\fR, but never throws an exception, and returns true if the
plan contains the specified change, and false if it does not.
.PP
\fI\f(CI\*(C`get\*(C'\fI\fR
.IX Subsection "get"
.PP
.Vb 5
\&  my $change = $plan\->get(\*(Aq6c2f28d125aff1deea615f8de774599acf39a7a1\*(Aq);
\&  my $foo    = $plan\->get(\*(Aq@foo\*(Aq);
\&  my $bar    = $plan\->get(\*(Aqbar\*(Aq);
\&  my $bar1   = $plan\->get(\*(Aqbar@alpha\*(Aq)
\&  my $bar2   = $plan\->get(\*(Aqbar@HEAD\*(Aq);
.Ve
.PP
Returns the change corresponding to the specified \s-1ID\s0 or name. The argument may
be in any of the formats described for \f(CW\*(C`index_of()\*(C'\fR.
.PP
\fI\f(CI\*(C`find\*(C'\fI\fR
.IX Subsection "find"
.PP
.Vb 5
\&  my $change = $plan\->find(\*(Aq6c2f28d125aff1deea615f8de774599acf39a7a1\*(Aq);
\&  my $foo    = $plan\->find(\*(Aq@foo\*(Aq);
\&  my $bar    = $plan\->find(\*(Aqbar\*(Aq);
\&  my $bar1   = $plan\->find(\*(Aqbar@alpha\*(Aq)
\&  my $bar2   = $plan\->find(\*(Aqbar@HEAD\*(Aq);
.Ve
.PP
Finds the change corresponding to the specified \s-1ID\s0 or name. The argument may be
in any of the formats described for \f(CW\*(C`index_of()\*(C'\fR. Unlike \f(CW\*(C`get()\*(C'\fR, \f(CW\*(C`find()\*(C'\fR
will not throw an error if more than one change exists with the specified name,
but will return the first instance.
.PP
\fI\f(CI\*(C`first_index_of\*(C'\fI\fR
.IX Subsection "first_index_of"
.PP
.Vb 2
\&  my $index = $plan\->first_index_of($change_name);
\&  my $index = $plan\->first_index_of($change_name, $change_or_tag_name);
.Ve
.PP
Returns the index of the first instance of the named change in the plan. If a
second argument is passed, the index of the first instance of the change
\&\fIafter\fR the index of the second argument will be returned. This is useful
for getting the index of a change as it was deployed after a particular tag, for
example, to get the first index of the \fIfoo\fR change since the \f(CW@beta\fR tag, do
this:
.PP
.Vb 1
\&  my $index = $plan\->first_index_of(\*(Aqfoo\*(Aq, \*(Aq@beta\*(Aq);
.Ve
.PP
You can also specify the first instance of a change after another change,
including such a change at the point of a tag:
.PP
.Vb 1
\&  my $index = $plan\->first_index_of(\*(Aqfoo\*(Aq, \*(Aqusers_table@beta1\*(Aq);
.Ve
.PP
The second argument must unambiguously refer to a single change in the plan. As
such, it should usually be a tag name or tag-qualified change name. Returns
\&\f(CW\*(C`undef\*(C'\fR if the change does not appear in the plan, or if it does not appear
after the specified second argument change name.
.PP
\fI\f(CI\*(C`last_tagged_change\*(C'\fI\fR
.IX Subsection "last_tagged_change"
.PP
.Vb 1
\&  my $change = $plan\->last_tagged_change;
.Ve
.PP
Returns the last tagged change object. Returns \f(CW\*(C`undef\*(C'\fR if no changes have
been tagged.
.PP
\fI\f(CI\*(C`change_at\*(C'\fI\fR
.IX Subsection "change_at"
.PP
.Vb 1
\&  my $change = $plan\->change_at($index);
.Ve
.PP
Returns the change at the specified index.
.PP
\fI\f(CI\*(C`seek\*(C'\fI\fR
.IX Subsection "seek"
.PP
.Vb 2
\&  $plan\->seek(\*(Aq@foo\*(Aq);
\&  $plan\->seek(\*(Aqbar\*(Aq);
.Ve
.PP
Move the plan position to the specified change. Dies if the change cannot be found
in the plan.
.PP
\fI\f(CI\*(C`reset\*(C'\fI\fR
.IX Subsection "reset"
.PP
.Vb 1
\&   $plan\->reset;
.Ve
.PP
Resets iteration. Same as \f(CW\*(C`$plan\->position(\-1)\*(C'\fR, but better.
.PP
\fI\f(CI\*(C`next\*(C'\fI\fR
.IX Subsection "next"
.PP
.Vb 3
\&  while (my $change = $plan\->next) {
\&      say "Deploy ", $change\->format_name;
\&  }
.Ve
.PP
Returns the next change in the plan. Returns \f(CW\*(C`undef\*(C'\fR
if there are no more changes.
.PP
\fI\f(CI\*(C`last\*(C'\fI\fR
.IX Subsection "last"
.PP
.Vb 1
\&  my $change = $plan\->last;
.Ve
.PP
Returns the last change in the plan. Does not change the current position.
.PP
\fI\f(CI\*(C`current\*(C'\fI\fR
.IX Subsection "current"
.PP
.Vb 1
\&   my $change = $plan\->current;
.Ve
.PP
Returns the same change as was last returned by \f(CW\*(C`next()\*(C'\fR. Returns \f(CW\*(C`undef\*(C'\fR if
\&\f(CW\*(C`next()\*(C'\fR has not been called or if the plan has been reset.
.PP
\fI\f(CI\*(C`peek\*(C'\fI\fR
.IX Subsection "peek"
.PP
.Vb 1
\&   my $change = $plan\->peek;
.Ve
.PP
Returns the next change in the plan without incrementing the iterator. Returns
\&\f(CW\*(C`undef\*(C'\fR if there are no more changes beyond the current change.
.PP
\fI\f(CI\*(C`changes\*(C'\fI\fR
.IX Subsection "changes"
.PP
.Vb 1
\&  my @changes = $plan\->changes;
.Ve
.PP
Returns all of the changes in the plan. This constitutes the entire plan.
.PP
\fI\f(CI\*(C`tags\*(C'\fI\fR
.IX Subsection "tags"
.PP
.Vb 1
\&  my @tags = $plan\->tags;
.Ve
.PP
Returns all of the tags in the plan.
.PP
\fI\f(CI\*(C`count\*(C'\fI\fR
.IX Subsection "count"
.PP
.Vb 1
\&  my $count = $plan\->count;
.Ve
.PP
Returns the number of changes in the plan.
.PP
\fI\f(CI\*(C`lines\*(C'\fI\fR
.IX Subsection "lines"
.PP
.Vb 1
\&  my @lines = $plan\->lines;
.Ve
.PP
Returns all of the lines in the plan. This includes all the
changes, tags,
pragmas, and blank
lines.
.PP
\fI\f(CI\*(C`do\*(C'\fI\fR
.IX Subsection "do"
.PP
.Vb 2
\&  $plan\->do(sub { say $_[0]\->name; return $_[0]; });
\&  $plan\->do(sub { say $_\->name;    return $_;    });
.Ve
.PP
Pass a code reference to this method to execute it for each change in the plan.
Each change will be stored in \f(CW$_\fR before executing the code reference, and
will also be passed as the sole argument. If \f(CW\*(C`next()\*(C'\fR has been called prior
to the call to \f(CW\*(C`do()\*(C'\fR, then only the remaining changes in the iterator will
passed to the code reference. Iteration terminates when the code reference
returns false, so be sure to have it return a true value if you want it to
iterate over every change.
.PP
\fI\f(CI\*(C`search_changes\*(C'\fI\fR
.IX Subsection "search_changes"
.PP
.Vb 4
\&  my $iter = $engine\->search_changes( %params );
\&  while (my $change = $iter\->()) {
\&      say \*(Aq* $change\->{event}ed $change\->{change}";
\&  }
.Ve
.PP
Searches the changes in the plan returns an iterator code reference with the
results. If no parameters are provided, a list of all changes will be returned
from the iterator in plan order. The supported parameters are:
.ie n .IP """event""" 4
.el .IP "\f(CWevent\fR" 4
.IX Item "event"
An array of the type of event to search for. Allowed values are \*(L"deploy\*(R" and
 \*(L"revert\*(R".
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
Limit the results to changes with names matching the specified regular
expression.
.ie n .IP """planner""" 4
.el .IP "\f(CWplanner\fR" 4
.IX Item "planner"
Limit the changes to those added by planners matching the specified regular
expression.
.ie n .IP """limit""" 4
.el .IP "\f(CWlimit\fR" 4
.IX Item "limit"
Limit the number of changes to the specified number.
.ie n .IP """offset""" 4
.el .IP "\f(CWoffset\fR" 4
.IX Item "offset"
Skip the specified number of events.
.ie n .IP """direction""" 4
.el .IP "\f(CWdirection\fR" 4
.IX Item "direction"
Return the results in the specified order, which must be a value matching
\&\f(CW\*(C`/^(:?a|de)sc/i\*(C'\fR for \*(L"ascending\*(R" or \*(L"descending\*(R".
.PP
\fI\f(CI\*(C`write_to\*(C'\fI\fR
.IX Subsection "write_to"
.PP
.Vb 2
\&  $plan\->write_to($file);
\&  $plan\->write_to($file, $from, $to);
.Ve
.PP
Write the plan to the named file, including notes and white space from the
original plan file. If \f(CW\*(C`from\*(C'\fR and/or \f(CW$to\fR are provided, the plan will be
written only with the pragmas headers and the lines between those specified
changes.
.PP
\fI\f(CI\*(C`open_script\*(C'\fI\fR
.IX Subsection "open_script"
.PP
.Vb 1
\&  my $file_handle = $plan\->open_script( $change\->deploy_file );
.Ve
.PP
Opens the script file passed to it and returns a file handle for reading. The
script file must be encoded in \s-1UTF\-8.\s0
.PP
\fI\f(CI\*(C`load\*(C'\fI\fR
.IX Subsection "load"
.PP
.Vb 1
\&  my $plan_data = $plan\->load;
.Ve
.PP
Loads the plan data. Called internally, not meant to be called directly, as it
parses the plan file and deploy scripts every time it's called. If you want
the all of the changes, call \f(CW\*(C`changes()\*(C'\fR instead. And if you want to load an
alternate plan, use \f(CW\*(C`parse()\*(C'\fR.
.PP
\fI\f(CI\*(C`parse\*(C'\fI\fR
.IX Subsection "parse"
.PP
.Vb 1
\&  $plan\->parse($plan_data);
.Ve
.PP
Load an alternate plan by passing the complete text of the plan. The text
should be \s-1UTF\-8\s0 encoded. Useful for loading a plan from a different \s-1VCS\s0
branch, for example.
.PP
\fI\f(CI\*(C`check_changes\*(C'\fI\fR
.IX Subsection "check_changes"
.PP
.Vb 2
\&  @changes = $plan\->check_changes( $project, @changes );
\&  @changes = $plan\->check_changes( $project, { \*(Aq@foo\*(Aq => 1 }, @changes );
.Ve
.PP
Checks a list of changes to validate their dependencies and returns them. If
the second argument is a hash reference, its keys should be previously-seen
change and tag names that can be assumed to be satisfied requirements for the
succeeding changes.
.PP
\fI\f(CI\*(C`tag\*(C'\fI\fR
.IX Subsection "tag"
.PP
.Vb 1
\&  $plan\->tag( name => \*(Aqwhee\*(Aq );
.Ve
.PP
Tags a change in the plan. Exits with a fatal error if the tag already exists
in the plan or if a change cannot be found to tag. The supported parameters
are:
.ie n .IP """name""" 4
.el .IP "\f(CWname\fR" 4
.IX Item "name"
The tag name to use. Required.
.ie n .IP """change""" 4
.el .IP "\f(CWchange\fR" 4
.IX Item "change"
The change to be tagged, specified as a supported change specification as
described in sqitchchanges. Defaults to the last change in the plan.
.ie n .IP """note""" 4
.el .IP "\f(CWnote\fR" 4
.IX Item "note"
A brief note about the tag.
.ie n .IP """planner_name""" 4
.el .IP "\f(CWplanner_name\fR" 4
.IX Item "planner_name"
The name of the user adding the tag to the plan. Defaults to the value of the
\&\f(CW\*(C`user.name\*(C'\fR configuration variable.
.ie n .IP """planner_email""" 4
.el .IP "\f(CWplanner_email\fR" 4
.IX Item "planner_email"
The email address of the user adding the tag to the plan. Defaults to the
value of the \f(CW\*(C`user.email\*(C'\fR configuration variable.
.PP
\fI\f(CI\*(C`add\*(C'\fI\fR
.IX Subsection "add"
.PP
.Vb 6
\&  $plan\->add( name => \*(Aqwhatevs\*(Aq );
\&  $plan\->add(
\&      name      => \*(Aqwidgets\*(Aq,
\&      requires  => [qw(foo bar)],
\&      conflicts => [qw(dr_evil)],
\&  );
.Ve
.PP
Adds a change to the plan. The supported parameters are the same as those
passed to the App::Sqitch::Plan::Change constructor. Exits with a fatal
error if the change already exists, or if the any of the dependencies are
unknown.
.PP
\fI\f(CI\*(C`rework\*(C'\fI\fR
.IX Subsection "rework"
.PP
.Vb 2
\&  $plan\->rework( \*(Aqwhatevs\*(Aq );
\&  $plan\->rework( \*(Aqwidgets\*(Aq, [qw(foo bar)], [qw(dr_evil)] );
.Ve
.PP
Reworks an existing change. Said change must already exist in the plan and be
tagged or have a tag following it or an exception will be thrown. The previous
occurrence of the change will have the suffix of the most recent tag added to
it, and a new tag instance will be added to the list.
.SH "Plan File"
.IX Header "Plan File"
A plan file describes the deployment changes to be run against a database, and
is typically maintained using the \f(CW\*(C`add\*(C'\fR and
\&\f(CW\*(C`rework\*(C'\fR commands. Its contents must be plain text encoded
as \s-1UTF\-8.\s0 Each line of a plan file may be one of four things:
.IP "\(bu" 4
A blank line. May include any amount of white space, which will be ignored.
.IP "\(bu" 4
A Pragma
.Sp
Begins with a \f(CW\*(C`%\*(C'\fR, followed by a pragma name, optionally followed by \f(CW\*(C`=\*(C'\fR and
a value. Currently, the only pragma recognized by Sqitch is \f(CW\*(C`syntax\-version\*(C'\fR.
.IP "\(bu" 4
A change.
.Sp
A named change change as defined in sqitchchanges. A change may then also
contain a space-delimited list of dependencies, which are the names of other
changes or tags prefixed with a colon (\f(CW\*(C`:\*(C'\fR) for required changes or with an
exclamation point (\f(CW\*(C`!\*(C'\fR) for conflicting changes.
.Sp
Changes with a leading \f(CW\*(C`\-\*(C'\fR are slated to be reverted, while changes with no
character or a leading \f(CW\*(C`+\*(C'\fR are to be deployed.
.IP "\(bu" 4
A tag.
.Sp
A named deployment tag, generally corresponding to a release name. Begins with
a \f(CW\*(C`@\*(C'\fR, followed by one or more non-blanks characters, excluding \*(L"@\*(R", \*(L":\*(R",
\&\*(L"#\*(R", and blanks. The first and last characters must not be punctuation
characters.
.IP "\(bu" 4
A note.
.Sp
Begins with a \f(CW\*(C`#\*(C'\fR and goes to the end of the line. Preceding white space is
ignored. May appear on a line after a pragma, change, or tag.
.PP
Here's an example of a plan file with a single deploy change and tag:
.PP
.Vb 3
\& %syntax\-version=1.0.0
\& +users_table
\& @alpha
.Ve
.PP
There may, of course, be any number of tags and changes. Here's an expansion:
.PP
.Vb 7
\& %syntax\-version=1.0.0
\& +users_table
\& +insert_user
\& +update_user
\& +delete_user
\& @root
\& @alpha
.Ve
.PP
Here we have four changes \*(-- \*(L"users_table\*(R", \*(L"insert_user\*(R", \*(L"update_user\*(R", and
\&\*(L"delete_user\*(R" \*(-- followed by two tags: \*(L"@root\*(R" and \*(L"@alpha\*(R".
.PP
Most plans will have many changes and tags. Here's a longer example with three
tagged deployment points, as well as a change that is deployed and later
reverted:
.PP
.Vb 8
\& %syntax\-version=1.0.0
\& +users_table
\& +insert_user
\& +update_user
\& +delete_user
\& +dr_evil
\& @root
\& @alpha
\&
\& +widgets_table
\& +list_widgets
\& @beta
\&
\& \-dr_evil
\& +ftw
\& @gamma
.Ve
.PP
Using this plan, to deploy to the \*(L"beta\*(R" tag, all of the changes up to the
\&\*(L"@root\*(R" and \*(L"@alpha\*(R" tags must be deployed, as must changes listed before the
\&\*(L"@beta\*(R" tag. To then deploy to the \*(L"@gamma\*(R" tag, the \*(L"dr_evil\*(R" change must be
reverted and the \*(L"ftw\*(R" change must be deployed. If you then choose to revert
to \*(L"@alpha\*(R", then the \*(L"ftw\*(R" change will be reverted, the \*(L"dr_evil\*(R" change
re-deployed, and the \*(L"@gamma\*(R" tag removed; then \*(L"list_widgets\*(R" must be
reverted and the associated \*(L"@beta\*(R" tag removed, then the \*(L"widgets_table\*(R"
change must be reverted.
.PP
Changes can only be repeated if one or more tags intervene. This allows Sqitch
to distinguish between them. An example:
.PP
.Vb 3
\& %syntax\-version=1.0.0
\& +users_table
\& @alpha
\&
\& +add_widget
\& +widgets_table
\& @beta
\&
\& +add_user
\& @gamma
\&
\& +widgets_created_at
\& @delta
\&
\& +add_widget
.Ve
.PP
Note that the \*(L"add_widget\*(R" change is repeated after the \*(L"@beta\*(R" tag, and at
the end. Sqitch will notice the repetition when it parses this file, and allow
it, because at least one tag \*(L"@beta\*(R" appears between the instances of
\&\*(L"add_widget\*(R". When deploying, Sqitch will fetch the instance of the deploy
script as of the \*(L"@delta\*(R" tag and apply it as the first change, and then, when
it gets to the last change, retrieve the current instance of the deploy
script. How does it find such files? The first instances files will either be
named \fIadd_widget@delta.sql\fR or (soon) findable in the \s-1VCS\s0 history as of a
\&\s-1VCS\s0 \*(L"delta\*(R" tag.
.SS "Grammar"
.IX Subsection "Grammar"
Here is the \s-1EBNF\s0 Grammar for the plan file:
.PP
.Vb 1
\&  plan\-file    = { <pragma> | <change\-line> | <tag\-line> | <note\-line> | <blank\-line> }* ;
\&
\&  blank\-line   = [ <blanks> ] <eol>;
\&  note\-line    = <note> ;
\&  change\-line  = <name> [ "[" { <requires> | <conflicts> } "]" ] ( <eol> | <note> ) ;
\&  tag\-line     = <tag> ( <eol> | <note> ) ;
\&  pragma       = "%" [ <blanks> ] <name> [ <blanks> ] = [ <blanks> ] <value> ( <eol> | <note> ) ;
\&
\&  tag          = "@" <name> ;
\&  requires     = <name> ;
\&  conflicts    = "!" <name> ;
\&  name         = <non\-punct> [ [ ? non\-blank and not "@", ":", or "#" characters ? ] <non\-punct> ] ;
\&  non\-punct    = ? non\-punctuation, non\-blank character ? ;
\&  value        = ? non\-EOL or "#" characters ?
\&
\&  note         = [ <blanks> ] "#" [ <string> ] <EOL> ;
\&  eol          = [ <blanks> ] <EOL> ;
\&
\&  blanks       = ? blank characters ? ;
\&  string       = ? non\-EOL characters ? ;
.Ve
.PP
And written as regular expressions:
.PP
.Vb 10
\&  my $eol          = qr/[[:blank:]]*$/
\&  my $note         = qr/(?:[[:blank:]]+)?[#].+$/;
\&  my $punct        = q{\-!"#$%&\*(Aq()*+,./:;<=>?@[\e\e]^\`{|}~};
\&  my $name         = qr/[^$punct[:blank:]](?:(?:[^[:space:]:#@]+)?[^$punct[:blank:]])?/;
\&  my $tag          = qr/[@]$name/;
\&  my $requires     = qr/$name/;
\&  my conflicts     = qr/[!]$name/;
\&  my $tag_line     = qr/^$tag(?:$note|$eol)/;
\&  my $change_line  = qr/^$name(?:[[](?:$requires|$conflicts)+[]])?(?:$note|$eol)/;
\&  my $note_line    = qr/^$note/;
\&  my $pragma       = qr/^][[:blank:]]*[%][[:blank:]]*$name[[:blank:]]*=[[:blank:]].+?(?:$note|$eol)$/;
\&  my $blank_line   = qr/^$eol/;
\&  my $plan         = qr/(?:$pragma|$change_line|$tag_line|$note_line|$blank_line)+/ms;
.Ve
.SH "See Also"
.IX Header "See Also"
.IP "sqitch" 4
.IX Item "sqitch"
The Sqitch command-line client.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
