.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Sqitch::Command 3"
.TH App::Sqitch::Command 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
App::Sqitch::Command \- Sqitch Command support
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 2
\&  my $cmd = App::Sqitch::Command\->load( deploy => \e%params );
\&  $cmd\->run;
.Ve
.SH "Description"
.IX Header "Description"
App::Sqitch::Command is the base class for all Sqitch commands.
.SH "Interface"
.IX Header "Interface"
.SS "Constants"
.IX Subsection "Constants"
\fI\f(CI\*(C`ENGINES\*(C'\fI\fR
.IX Subsection "ENGINES"
.PP
Returns the list of supported engines, currently:
.IP "\(bu" 4
\&\f(CW\*(C`firebird\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`mysql\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`oracle\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`pg\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`sqlite\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`vertica\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`exasol\*(C'\fR
.IP "\(bu" 4
\&\f(CW\*(C`snowflake\*(C'\fR
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`options\*(C'\fI\fR
.IX Subsection "options"
.PP
.Vb 1
\&  my @spec = App::Sqitch::Command\->options;
.Ve
.PP
Returns a list of Getopt::Long options specifications. When \f(CW\*(C`load\*(C'\fR loads
the class, any options passed to the command will be parsed using these
values. The keys in the resulting hash will be the first part of each option,
with dashes converted to underscores. This hash will be passed to \f(CW\*(C`configure\*(C'\fR
along with a App::Sqitch::Config object for munging into parameters to be
passed to the constructor.
.PP
Here's an example excerpted from the \f(CW\*(C`config\*(C'\fR command:
.PP
.Vb 10
\&  sub options {
\&      return qw(
\&          get
\&          unset
\&          list
\&          global
\&          system
\&          config\-file=s
\&      );
\&  }
.Ve
.PP
This will result in hash keys with the same names as each option except for
\&\f(CW\*(C`config\-file=s\*(C'\fR, which will be named \f(CW\*(C`config_file\*(C'\fR.
.PP
\fI\f(CI\*(C`configure\*(C'\fI\fR
.IX Subsection "configure"
.PP
.Vb 1
\&  my $params = App::Sqitch::Command\->configure($config, $options);
.Ve
.PP
Takes two arguments, an App::Sqitch::Config object and the hash of
command-line options as specified by \f(CW\*(C`options\*(C'\fR. The returned hash should be
the result of munging these two objects into a hash reference of parameters to
be passed to the command subclass constructor.
.PP
By default, this method converts dashes to underscores in command-line options
keys, and then merges the configuration values with the options, with the
command-line options taking priority. You may wish to override this method to
do something different.
.PP
\fI\f(CI\*(C`class_for\*(C'\fI\fR
.IX Subsection "class_for"
.PP
.Vb 1
\&  my $subclass = App::Sqitch::Command\->subclass_for($sqitch, $cmd_name);
.Ve
.PP
This method attempts to load the subclass of App::Sqitch::Commmand that
corresponds to the command name. Returns \f(CW\*(C`undef\*(C'\fR and sends errors to the
\&\f(CW\*(C`debug\*(C'\fR method of the <$sqitch> object if no such subclass can
be loaded.
.SS "Constructors"
.IX Subsection "Constructors"
\fI\f(CI\*(C`load\*(C'\fI\fR
.IX Subsection "load"
.PP
.Vb 1
\&  my $cmd = App::Sqitch::Command\->load( \e%params );
.Ve
.PP
A factory method for instantiating Sqitch commands. It loads the subclass for
the specified command and calls \f(CW\*(C`create\*(C'\fR to instantiate and return an
instance of the subclass. Sends error messages to the \f(CW\*(C`debug\*(C'\fR method of the
\&\f(CW\*(C`sqitch\*(C'\fR parameter and throws an exception if the subclass does not exist or
cannot be loaded. Supported parameters are:
.ie n .IP """sqitch""" 4
.el .IP "\f(CWsqitch\fR" 4
.IX Item "sqitch"
The App::Sqitch object driving the whole thing.
.ie n .IP """config""" 4
.el .IP "\f(CWconfig\fR" 4
.IX Item "config"
An App::Sqitch::Config representing the current application configuration
state.
.ie n .IP """command""" 4
.el .IP "\f(CWcommand\fR" 4
.IX Item "command"
The name of the command to be executed.
.ie n .IP """args""" 4
.el .IP "\f(CWargs\fR" 4
.IX Item "args"
An array reference of command-line arguments passed to the command.
.PP
\fI\f(CI\*(C`create\*(C'\fI\fR
.IX Subsection "create"
.PP
.Vb 7
\&  my $pkg = App::Sqitch::Command\->class_for( $sqitch, $cmd_name )
\&      or die "No such command $cmd_name";
\&  my $cmd = $pkg\->create({
\&      sqitch => $sqitch,
\&      config => $config,
\&      args   => \e@ARGV,
\&  });
.Ve
.PP
Creates and returns a new object for a subclass of App::Sqitch::Command. It
parses options from the \f(CW\*(C`args\*(C'\fR parameter, calls \f(CW\*(C`configure\*(C'\fR to merge
configuration with the options, and finally calls \f(CW\*(C`new\*(C'\fR with the resulting
hash. Supported parameters are the same as for \f(CW\*(C`load\*(C'\fR except for the
\&\f(CW\*(C`command\*(C'\fR parameter, which will be ignored.
.PP
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  my $cmd = App::Sqitch::Command\->new(%params);
.Ve
.PP
Instantiates and returns a App::Sqitch::Command object. This method is not
designed to be overridden by subclasses; they should implement
\&\f(CW\*(C`BUILDARGS\*(C'\fR or
\&\f(CW\*(C`BUILD\*(C'\fR, instead.
.SS "Accessors"
.IX Subsection "Accessors"
\fI\f(CI\*(C`sqitch\*(C'\fI\fR
.IX Subsection "sqitch"
.PP
.Vb 1
\&  my $sqitch = $cmd\->sqitch;
.Ve
.PP
Returns the App::Sqitch object that instantiated the command. Commands may
access its properties in order to manage global state.
.SS "Overridable Instance Methods"
.IX Subsection "Overridable Instance Methods"
These methods should be overridden by all subclasses.
.PP
\fI\f(CI\*(C`execute\*(C'\fI\fR
.IX Subsection "execute"
.PP
.Vb 1
\&  $cmd\->execute;
.Ve
.PP
Executes the command. This is the method that does the work of the command.
Must be overridden in all subclasses. Dies if the method is not overridden for
the object on which it is called, or if it is called against a base
App::Sqitch::Command object.
.PP
\fI\f(CI\*(C`command\*(C'\fI\fR
.IX Subsection "command"
.PP
.Vb 1
\&  my $command = $cmd\->command;
.Ve
.PP
The name of the command. Defaults to the last part of the package name, so as
a rule you should not need to override it, since it is that string that Sqitch
uses to find the command class.
.SS "Utility Instance Methods"
.IX Subsection "Utility Instance Methods"
These methods are mainly provided as utilities for the command subclasses to
use.
.PP
\fI\f(CI\*(C`default_target\*(C'\fI\fR
.IX Subsection "default_target"
.PP
.Vb 1
\&  my $target = $cmd\->default_target;
.Ve
.PP
This method returns the default target. It should only be used by commands
that don't use a \f(CW\*(C`parse_args()\*(C'\fR to find and load a target.
.PP
This method should always return a target option, never \f(CW\*(C`undef\*(C'\fR. If the
\&\f(CW\*(C`core.engine\*(C'\fR configuration option has been set, then the target will support
that engine. In the latter case, if \f(CW\*(C`engine.$engine.target\*(C'\fR is set, that
value will be used. Otherwise, the returned target will have a \s-1URI\s0 of \f(CW\*(C`db:\*(C'\fR
and no associated engine; the \f(CW\*(C`engine\*(C'\fR method will throw an exception. This
behavior should be fine for commands that don't need to load the engine.
.PP
\fI\f(CI\*(C`parse_args\*(C'\fI\fR
.IX Subsection "parse_args"
.PP
.Vb 5
\&  my ($name1, $name2, $targets, $changes) = $cmd\->parse_args(
\&    names  => \e@names,
\&    target => $target_name,
\&    args   => \e@args
\&  );
.Ve
.PP
Examines each argument to determine whether it's a known change spec or
identifies a target or engine. Unrecognized arguments will replace false
values in the \f(CW\*(C`names\*(C'\fR array reference. Any remaining unknown arguments will
trigger an error.
.PP
Returns a list consisting all the desired names, followed by an array
reference of target objects and an array reference of change specs.
.PP
This method is useful for commands that take a number of arguments where the
order may be mixed.
.PP
The supported parameters are:
.ie n .IP """args""" 4
.el .IP "\f(CWargs\fR" 4
.IX Item "args"
An array reference of the command arguments.
.ie n .IP """target""" 4
.el .IP "\f(CWtarget\fR" 4
.IX Item "target"
The name of a target, if any. Useful for commands that offer their own
\&\f(CW\*(C`\-\-target\*(C'\fR option. This target will be the default target, and the first
returned in the targets array.
.ie n .IP """names""" 4
.el .IP "\f(CWnames\fR" 4
.IX Item "names"
An array reference of names. If any is false, its place will be taken by an
otherwise unrecognized argument. The number of values in this array reference
determines the number of values returned as names in the return values. Such
values may still be false or undefined; it's up to the caller to decide what
to do about that.
.ie n .IP """all""" 4
.el .IP "\f(CWall\fR" 4
.IX Item "all"
In the event that no targets are recognized (or changes that implicitly
recognize the default target), if this parameter is true, then all known
targets from the configuration will be returned.
.ie n .IP """no_changes""" 4
.el .IP "\f(CWno_changes\fR" 4
.IX Item "no_changes"
If true, the parser will not check to see if any argument corresponds to a
change. The last value returned will be \f(CW\*(C`undef\*(C'\fR instead of the usual array
reference. Any argument that might have been recognized as a change will
instead be included in either the \f(CW\*(C`targets\*(C'\fR array \*(-- if it's recognized as a
target \*(-- or used to set names to return. Any remaining are considered
unknown arguments and will result in an exception.
.PP
If a target parameter is passed, it will always be instantiated and returned
as the first item in the \*(L"target\*(R" array, and arguments recognized as changes
in the plan associated with that target will be returned as changes.
.PP
If no target is passed or appears in the arguments, a default target will be
instantiated based on the command-line options and configuration. Unlike the
target returned by \f(CW\*(C`default_target\*(C'\fR, this target \fBmust\fR have an associated
engine specified by the configuration. This is on the assumption that it will
be used by commands that require an engine to do their work. Of course, any
changes must be recognized from the plan associated with this target.
.PP
Changes are only recognized if they're found in the plan of the target that
precedes them. If no target precedes them, the target specified by the
\&\f(CW\*(C`target\*(C'\fR parameter or the default target will be searched. Such changes can
be specified in any way documented in sqitchchanges.
.PP
Targets may be recognized by any one of these types of arguments:
.IP "\(bu" 4
Target Name
.IP "\(bu" 4
Database \s-1URI\s0
.IP "\(bu" 4
Engine Name
.IP "\(bu" 4
Plan File
.PP
In the case of plan files, \f(CW\*(C`parse_args()\*(C'\fR will return the first target it
finds for that plan file, even if multiple targets use the same plan file. The
order of precedence for this determination is the default project target,
followed by named targets, then engine targets.
.PP
\fI\f(CI\*(C`target_params\*(C'\fI\fR
.IX Subsection "target_params"
.PP
.Vb 1
\&  my $target = App::Sqitch::Target\->new( $cmd\->target_params );
.Ve
.PP
Returns a list of parameters suitable for passing to the \f(CW\*(C`new\*(C'\fR or
\&\f(CW\*(C`all_targets\*(C'\fR constructors of App::Sqitch::Target.
.PP
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
.Vb 1
\&  $cmd\->run(\*(Aqecho hello\*(Aq);
.Ve
.PP
Runs a system command and waits for it to finish. Throws an exception on
error.
.PP
\fI\f(CI\*(C`capture\*(C'\fI\fR
.IX Subsection "capture"
.PP
.Vb 1
\&  my @files = $cmd\->capture(qw(ls \-lah));
.Ve
.PP
Runs a system command and captures its output to \f(CW\*(C`STDOUT\*(C'\fR. Returns the output
lines in list context and the concatenation of the lines in scalar context.
Throws an exception on error.
.PP
\fI\f(CI\*(C`probe\*(C'\fI\fR
.IX Subsection "probe"
.PP
.Vb 1
\&  my $git_version = $cmd\->capture(qw(git \-\-version));
.Ve
.PP
Like \f(CW\*(C`capture\*(C'\fR, but returns just the \f(CW\*(C`chomp\*(C'\fRed first line of output.
.PP
\fI\f(CI\*(C`verbosity\*(C'\fI\fR
.IX Subsection "verbosity"
.PP
.Vb 1
\&  my $verbosity = $cmd\->verbosity;
.Ve
.PP
Returns the verbosity level.
.PP
\fI\f(CI\*(C`trace\*(C'\fI\fR
.IX Subsection "trace"
.PP
Send trace information to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 3 or higher.
Trace messages will have \f(CW\*(C`trace: \*(C'\fR prefixed to every line. If it's lower than
3, nothing will be output.
.PP
\fI\f(CI\*(C`debug\*(C'\fI\fR
.IX Subsection "debug"
.PP
.Vb 1
\&  $cmd\->debug(\*(AqFound snuggle in the crib.\*(Aq);
.Ve
.PP
Send debug information to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 2 or higher.
Debug messages will have \f(CW\*(C`debug: \*(C'\fR prefixed to every line. If it's lower than
2, nothing will be output.
.PP
\fI\f(CI\*(C`info\*(C'\fI\fR
.IX Subsection "info"
.PP
.Vb 1
\&  $cmd\->info(\*(AqNothing to deploy (up\-to\-date)\*(Aq);
.Ve
.PP
Send informational message to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 1 or higher,
which, by default, it is. Should be used for normal messages the user would
normally want to see. If verbosity is lower than 1, nothing will be output.
.PP
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
.Vb 1
\&  $cmd\->comment(\*(AqOn database flipr_test\*(Aq);
.Ve
.PP
Send comments to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 1 or higher, which, by
default, it is. Comments have \f(CW\*(C`# \*(C'\fR prefixed to every line. If verbosity is
lower than 1, nothing will be output.
.PP
\fI\f(CI\*(C`emit\*(C'\fI\fR
.IX Subsection "emit"
.PP
.Vb 1
\&  $cmd\->emit(\*(Aqcore.editor=emacs\*(Aq);
.Ve
.PP
Send a message to \f(CW\*(C`STDOUT\*(C'\fR, without regard to the verbosity. Should be used
only if the user explicitly asks for output, such as for
\&\f(CW\*(C`sqitch config \-\-get core.editor\*(C'\fR.
.PP
\fI\f(CI\*(C`vent\*(C'\fI\fR
.IX Subsection "vent"
.PP
.Vb 1
\&  $cmd\->vent(\*(AqThat was a misage.\*(Aq);
.Ve
.PP
Send a message to \f(CW\*(C`STDERR\*(C'\fR, without regard to the verbosity. Should be used
only for error messages to be printed before exiting with an error, such as
when reverting failed changes.
.PP
\fI\f(CI\*(C`page\*(C'\fI\fR
.IX Subsection "page"
.PP
.Vb 1
\&  $sqitch\->page(\*(AqSearch results:\*(Aq);
.Ve
.PP
Like \f(CW\*(C`emit()\*(C'\fR, but sends the output to a pager handle rather than \f(CW\*(C`STDOUT\*(C'\fR.
Unless there is no \s-1TTY\s0 (such as when output is being piped elsewhere), in
which case it \fIis\fR sent to \f(CW\*(C`STDOUT\*(C'\fR. Meant to be used to send a lot of data
to the user at once, such as when display the results of searching the event
log:
.PP
.Vb 4
\&  $iter = $engine\->search_events;
\&  while ( my $change = $iter\->() ) {
\&      $cmd\->page(join \*(Aq \- \*(Aq, @{ $change }{ qw(change_id event change) });
\&  }
.Ve
.PP
\fI\f(CI\*(C`warn\*(C'\fI\fR
.IX Subsection "warn"
.PP
.Vb 1
\&  $cmd\->warn(\*(AqCould not find nerble; using nobble instead.\*(Aq);
.Ve
.PP
Send a warning messages to \f(CW\*(C`STDERR\*(C'\fR. Warnings will have \f(CW\*(C`warning: \*(C'\fR prefixed
to every line. Use if something unexpected happened but you can recover from
it.
.PP
\fI\f(CI\*(C`usage\*(C'\fI\fR
.IX Subsection "usage"
.PP
.Vb 1
\&  $cmd\->usage(\*(AqMissing "value" argument\*(Aq);
.Ve
.PP
Sends the specified message to \f(CW\*(C`STDERR\*(C'\fR, followed by the usage sections of
the command's documentation. Those sections may be named \*(L"Name\*(R", \*(L"Synopsis\*(R",
or \*(L"Options\*(R". Any or all of these will be shown. The doc used to display them
will be the first found of:
.ie n .IP """sqitch\-$command\-usage""" 4
.el .IP "\f(CWsqitch\-$command\-usage\fR" 4
.IX Item "sqitch-$command-usage"
.PD 0
.ie n .IP """sqitch\-$command""" 4
.el .IP "\f(CWsqitch\-$command\fR" 4
.IX Item "sqitch-$command"
.ie n .IP """sqitch""" 4
.el .IP "\f(CWsqitch\fR" 4
.IX Item "sqitch"
.ie n .IP """App::Sqitch::Command::$command""" 4
.el .IP "\f(CWApp::Sqitch::Command::$command\fR" 4
.IX Item "App::Sqitch::Command::$command"
.ie n .IP """App::Sqitch::Command""" 4
.el .IP "\f(CWApp::Sqitch::Command\fR" 4
.IX Item "App::Sqitch::Command"
.PD
.PP
For an ideal usage messages, \f(CW\*(C`sqitch\-$command\-usage.pod\*(C'\fR should be created by
all command subclasses.
.SH "See Also"
.IX Header "See Also"
.IP "sqitch" 4
.IX Item "sqitch"
The Sqitch command-line client.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
