.\" Automatically generated by Pod::Man 4.11 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.nr rF 0
.if \n(.g .if rF .nr rF 1
.if (\n(rF:(\n(.g==0)) \{\
.    if \nF \{\
.        de IX
.        tm Index:\\$1\t\\n%\t"\\$2"
..
.        if !\nF==2 \{\
.            nr % 0
.            nr F 2
.        \}
.    \}
.\}
.rr rF
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "App::Sqitch 3"
.TH App::Sqitch 3 "2021-09-02" "perl v5.30.0" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "Name"
.IX Header "Name"
App::Sqitch \- Sensible database change management
.SH "Synopsis"
.IX Header "Synopsis"
.Vb 2
\&  use App::Sqitch;
\&  exit App::Sqitch\->go;
.Ve
.SH "Description"
.IX Header "Description"
This module provides the implementation for sqitch. You probably want to
read its documentation, or the tutorial. Unless
you want to hack on Sqitch itself, or provide support for a new engine or
command. In which case, you will find this \s-1API\s0
documentation useful.
.SH "Interface"
.IX Header "Interface"
.SS "Class Methods"
.IX Subsection "Class Methods"
\fI\f(CI\*(C`go\*(C'\fI\fR
.IX Subsection "go"
.PP
.Vb 1
\&  App::Sqitch\->go;
.Ve
.PP
Called from \f(CW\*(C`sqitch\*(C'\fR, this class method parses command-line options and
arguments in \f(CW@ARGV\fR, parses the configuration file, constructs an
App::Sqitch object, constructs a command object, and runs it.
.SS "Constructor"
.IX Subsection "Constructor"
\fI\f(CI\*(C`new\*(C'\fI\fR
.IX Subsection "new"
.PP
.Vb 1
\&  my $sqitch = App::Sqitch\->new(\e%params);
.Ve
.PP
Constructs and returns a new Sqitch object. The supported parameters include:
.ie n .IP """options""" 4
.el .IP "\f(CWoptions\fR" 4
.IX Item "options"
.PD 0
.ie n .IP """user_name""" 4
.el .IP "\f(CWuser_name\fR" 4
.IX Item "user_name"
.ie n .IP """user_email""" 4
.el .IP "\f(CWuser_email\fR" 4
.IX Item "user_email"
.ie n .IP """editor""" 4
.el .IP "\f(CWeditor\fR" 4
.IX Item "editor"
.ie n .IP """verbosity""" 4
.el .IP "\f(CWverbosity\fR" 4
.IX Item "verbosity"
.PD
.SS "Accessors"
.IX Subsection "Accessors"
\fI\f(CI\*(C`user_name\*(C'\fI\fR
.IX Subsection "user_name"
.PP
\fI\f(CI\*(C`user_email\*(C'\fI\fR
.IX Subsection "user_email"
.PP
\fI\f(CI\*(C`editor\*(C'\fI\fR
.IX Subsection "editor"
.PP
\fI\f(CI\*(C`options\*(C'\fI\fR
.IX Subsection "options"
.PP
.Vb 1
\&  my $options = $sqitch\->options;
.Ve
.PP
Returns a hashref of the core command-line options.
.PP
\fI\f(CI\*(C`config\*(C'\fI\fR
.IX Subsection "config"
.PP
.Vb 1
\&  my $config = $sqitch\->config;
.Ve
.PP
Returns the full configuration, combined from the project, user, and system
configuration files.
.PP
\fI\f(CI\*(C`verbosity\*(C'\fI\fR
.IX Subsection "verbosity"
.SS "Instance Methods"
.IX Subsection "Instance Methods"
\fI\f(CI\*(C`run\*(C'\fI\fR
.IX Subsection "run"
.PP
.Vb 1
\&  $sqitch\->run(\*(Aqecho\*(Aq, \*(Aq\-n\*(Aq, \*(Aqhello\*(Aq);
.Ve
.PP
Runs a system command and waits for it to finish. Throws an exception on
error. Does not use the shell, so arguments must be passed as a list. Use
\&\f(CW\*(C`shell\*(C'\fR to run a command and its arguments as a single string.
.ie n .IP """target""" 4
.el .IP "\f(CWtarget\fR" 4
.IX Item "target"
The name of the target, as passed.
.ie n .IP """uri""" 4
.el .IP "\f(CWuri\fR" 4
.IX Item "uri"
A database \s-1URI\s0 object, to be used to connect to the target
database.
.ie n .IP """registry""" 4
.el .IP "\f(CWregistry\fR" 4
.IX Item "registry"
The name of the Sqitch registry in the target database.
.PP
If the \f(CW$target\fR argument looks like a database \s-1URI,\s0 it will simply returned
in the hash reference. If the \f(CW$target\fR argument corresponds to a target
configuration key, the target configuration will be returned, with the \f(CW\*(C`uri\*(C'\fR
value a upgraded to a \s-1URI\s0 object. Otherwise returns \f(CW\*(C`undef\*(C'\fR.
.PP
\fI\f(CI\*(C`shell\*(C'\fI\fR
.IX Subsection "shell"
.PP
.Vb 1
\&  $sqitch\->shell(\*(Aqecho \-n hello\*(Aq);
.Ve
.PP
Shells out a system command and waits for it to finish. Throws an exception on
error. Always uses the shell, so a single string must be passed encapsulating
the entire command and its arguments. Use \f(CW\*(C`quote_shell\*(C'\fR to assemble strings
into a single shell command. Use \f(CW\*(C`run\*(C'\fR to execute a list without a shell.
.PP
\fI\f(CI\*(C`quote_shell\*(C'\fI\fR
.IX Subsection "quote_shell"
.PP
.Vb 1
\&  my $cmd = $sqitch\->quote_shell(\*(Aqecho\*(Aq, \*(Aq\-n\*(Aq, \*(Aqhello\*(Aq);
.Ve
.PP
Assemble a list into a single string quoted for execution by \f(CW\*(C`shell\*(C'\fR. Useful
for combining a specified command, such as \f(CW\*(C`editor()\*(C'\fR, which might include
the options in the string, for example:
.PP
.Vb 1
\&  $sqitch\->shell( $sqitch\->editor, $sqitch\->quote_shell($file) );
.Ve
.PP
\fI\f(CI\*(C`capture\*(C'\fI\fR
.IX Subsection "capture"
.PP
.Vb 1
\&  my @files = $sqitch\->capture(qw(ls \-lah));
.Ve
.PP
Runs a system command and captures its output to \f(CW\*(C`STDOUT\*(C'\fR. Returns the output
lines in list context and the concatenation of the lines in scalar context.
Throws an exception on error.
.PP
\fI\f(CI\*(C`probe\*(C'\fI\fR
.IX Subsection "probe"
.PP
.Vb 1
\&  my $git_version = $sqitch\->capture(qw(git \-\-version));
.Ve
.PP
Like \f(CW\*(C`capture\*(C'\fR, but returns just the \f(CW\*(C`chomp\*(C'\fRed first line of output.
.PP
\fI\f(CI\*(C`spool\*(C'\fI\fR
.IX Subsection "spool"
.PP
.Vb 2
\&  $sqitch\->spool($sql_file_handle, \*(Aqsqlite3\*(Aq, \*(Aqmy.db\*(Aq);
\&  $sqitch\->spool(\e@file_handles, \*(Aqsqlite3\*(Aq, \*(Aqmy.db\*(Aq);
.Ve
.PP
Like run, but spools the contents of one or ore file handle to the standard
input the system command. Returns true on success and throws an exception on
failure.
.PP
\fI\f(CI\*(C`trace\*(C'\fI\fR
.IX Subsection "trace"
.PP
\fI\f(CI\*(C`trace_literal\*(C'\fI\fR
.IX Subsection "trace_literal"
.PP
.Vb 2
\&  $sqitch\->trace_literal(\*(AqAbout to fuzzle the wuzzle.\*(Aq);
\&  $sqitch\->trace(\*(AqDone.\*(Aq);
.Ve
.PP
Send trace information to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 3 or higher.
Trace messages will have \f(CW\*(C`trace: \*(C'\fR prefixed to every line. If it's lower than
3, nothing will be output. \f(CW\*(C`trace\*(C'\fR appends a newline to the end of the
message while \f(CW\*(C`trace_literal\*(C'\fR does not.
.PP
\fI\f(CI\*(C`debug\*(C'\fI\fR
.IX Subsection "debug"
.PP
\fI\f(CI\*(C`debug_literal\*(C'\fI\fR
.IX Subsection "debug_literal"
.PP
.Vb 2
\&  $sqitch\->debug(\*(AqFound snuggle in the crib.\*(Aq);
\&  $sqitch\->debug_literal(\*(AqITYM "snuggie".\*(Aq);
.Ve
.PP
Send debug information to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 2 or higher.
Debug messages will have \f(CW\*(C`debug: \*(C'\fR prefixed to every line. If it's lower than
2, nothing will be output. \f(CW\*(C`debug\*(C'\fR appends a newline to the end of the
message while \f(CW\*(C`debug_literal\*(C'\fR does not.
.PP
\fI\f(CI\*(C`info\*(C'\fI\fR
.IX Subsection "info"
.PP
\fI\f(CI\*(C`info_literal\*(C'\fI\fR
.IX Subsection "info_literal"
.PP
.Vb 2
\&  $sqitch\->info(\*(AqNothing to deploy (up\-to\-date)\*(Aq);
\&  $sqitch\->info_literal(\*(AqGoing to frobble the shiznet.\*(Aq);
.Ve
.PP
Send informational message to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 1 or higher,
which, by default, it is. Should be used for normal messages the user would
normally want to see. If verbosity is lower than 1, nothing will be output.
\&\f(CW\*(C`info\*(C'\fR appends a newline to the end of the message while \f(CW\*(C`info_literal\*(C'\fR does
not.
.PP
\fI\f(CI\*(C`comment\*(C'\fI\fR
.IX Subsection "comment"
.PP
\fI\f(CI\*(C`comment_literal\*(C'\fI\fR
.IX Subsection "comment_literal"
.PP
.Vb 2
\&  $sqitch\->comment(\*(AqOn database flipr_test\*(Aq);
\&  $sqitch\->comment_literal(\*(AqUh\-oh...\*(Aq);
.Ve
.PP
Send comments to \f(CW\*(C`STDOUT\*(C'\fR if the verbosity level is 1 or higher, which, by
default, it is. Comments have \f(CW\*(C`# \*(C'\fR prefixed to every line. If verbosity is
lower than 1, nothing will be output. \f(CW\*(C`comment\*(C'\fR appends a newline to the end
of the message while \f(CW\*(C`comment_literal\*(C'\fR does not.
.PP
\fI\f(CI\*(C`emit\*(C'\fI\fR
.IX Subsection "emit"
.PP
\fI\f(CI\*(C`emit_literal\*(C'\fI\fR
.IX Subsection "emit_literal"
.PP
.Vb 2
\&  $sqitch\->emit(\*(Aqcore.editor=emacs\*(Aq);
\&  $sqitch\->emit_literal(\*(AqGetting ready...\*(Aq);
.Ve
.PP
Send a message to \f(CW\*(C`STDOUT\*(C'\fR, without regard to the verbosity. Should be used
only if the user explicitly asks for output, such as for \f(CW\*(C`sqitch config \-\-get
core.editor\*(C'\fR. \f(CW\*(C`emit\*(C'\fR appends a newline to the end of the message while
\&\f(CW\*(C`emit_literal\*(C'\fR does not.
.PP
\fI\f(CI\*(C`vent\*(C'\fI\fR
.IX Subsection "vent"
.PP
\fI\f(CI\*(C`vent_literal\*(C'\fI\fR
.IX Subsection "vent_literal"
.PP
.Vb 2
\&  $sqitch\->vent(\*(AqThat was a misage.\*(Aq);
\&  $sqitch\->vent_literal(\*(AqThis is going to be bad...\*(Aq);
.Ve
.PP
Send a message to \f(CW\*(C`STDERR\*(C'\fR, without regard to the verbosity. Should be used
only for error messages to be printed before exiting with an error, such as
when reverting failed changes. \f(CW\*(C`vent\*(C'\fR appends a newline to the end of the
message while \f(CW\*(C`vent_literal\*(C'\fR does not.
.PP
\fI\f(CI\*(C`page\*(C'\fI\fR
.IX Subsection "page"
.PP
\fI\f(CI\*(C`page_literal\*(C'\fI\fR
.IX Subsection "page_literal"
.PP
.Vb 2
\&  $sqitch\->page(\*(AqSearch results:\*(Aq);
\&  $sqitch\->page("Here we go\en");
.Ve
.PP
Like \f(CW\*(C`emit()\*(C'\fR, but sends the output to a pager handle rather than \f(CW\*(C`STDOUT\*(C'\fR.
Unless there is no \s-1TTY\s0 (such as when output is being piped elsewhere), in
which case it \fIis\fR sent to \f(CW\*(C`STDOUT\*(C'\fR. \f(CW\*(C`page\*(C'\fR appends a newline to the end of
the message while \f(CW\*(C`page_literal\*(C'\fR does not. Meant to be used to send a lot of
data to the user at once, such as when display the results of searching the
event log:
.PP
.Vb 4
\&  $iter = $engine\->search_events;
\&  while ( my $change = $iter\->() ) {
\&      $sqitch\->page(join \*(Aq \- \*(Aq, @{ $change }{ qw(change_id event change) });
\&  }
.Ve
.PP
\fI\f(CI\*(C`warn\*(C'\fI\fR
.IX Subsection "warn"
.PP
\fI\f(CI\*(C`warn_literal\*(C'\fI\fR
.IX Subsection "warn_literal"
.PP
.Vb 2
\&  $sqitch\->warn(\*(AqCould not find nerble; using nobble instead.\*(Aq);
\&  $sqitch\->warn_literal("Cannot read file: $!\en");
.Ve
.PP
Send a warning messages to \f(CW\*(C`STDERR\*(C'\fR. Warnings will have \f(CW\*(C`warning: \*(C'\fR prefixed
to every line. Use if something unexpected happened but you can recover from
it. \f(CW\*(C`warn\*(C'\fR appends a newline to the end of the message while \f(CW\*(C`warn_literal\*(C'\fR
does not.
.PP
\fI\f(CI\*(C`prompt\*(C'\fI\fR
.IX Subsection "prompt"
.PP
.Vb 1
\&  my $ans = $sqitch\->(\*(AqWhy would you want to do this?\*(Aq, \*(Aqbecause\*(Aq);
.Ve
.PP
Prompts the user for input and returns that input. Pass in an optional default
value for the user to accept or to be used if Sqitch is running unattended. An
exception will be thrown if there is no prompt message or if Sqitch is
unattended and there is no default value.
.PP
\fI\f(CI\*(C`ask_yes_no\*(C'\fI\fR
.IX Subsection "ask_yes_no"
.PP
.Vb 1
\&  if ( $sqitch\->ask_yes_no(\*(AqAre you sure?\*(Aq, 1) ) { # do it! }
.Ve
.PP
Prompts the user with a \*(L"yes\*(R" or \*(L"no\*(R" question. Returns true if the user
replies in the affirmative and false if the reply is in the negative. If the
optional second argument is passed and true, the answer will default to the
affirmative. If the second argument is passed but false, the answer will
default to the negative. When a translation library is in use, the affirmative
and negative replies from the user should be localized variants of \*(L"yes\*(R" and
\&\*(L"no\*(R", and will be matched as such. If no translation library is in use, the
answers will default to the English \*(L"yes\*(R" and \*(L"no\*(R".
.PP
If the user inputs an invalid value three times, an exception will be thrown.
An exception will also be thrown if there is no message. As with \f(CW\*(C`prompt()\*(C'\fR,
an exception will be thrown if Sqitch is running unattended and there is no
default.
.PP
\fI\f(CI\*(C`ask_y_n\*(C'\fI\fR
.IX Subsection "ask_y_n"
.PP
This method has been deprecated in favor of \f(CW\*(C`ask_yes_no()\*(C'\fR and will be
removed in a future version of Sqitch.
.SS "Constants"
.IX Subsection "Constants"
\fI\f(CI\*(C`ISWIN\*(C'\fI\fR
.IX Subsection "ISWIN"
.PP
.Vb 1
\&  my $app = \*(Aqsqitch\*(Aq . ( ISWIN ? \*(Aq.bat\*(Aq : \*(Aq\*(Aq );
.Ve
.PP
True when Sqitch is running on Windows, and false when it's not.
.SH "Author"
.IX Header "Author"
David E. Wheeler <david@justatheory.com>
.SH "License"
.IX Header "License"
Copyright (c) 2012\-2020 iovation Inc.
.PP
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the \*(L"Software\*(R"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:
.PP
The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.
.PP
\&\s-1THE SOFTWARE IS PROVIDED \*(L"AS IS\*(R", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.\s0
